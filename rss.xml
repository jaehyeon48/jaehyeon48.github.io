<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Jaehyeon's Dev Blog]]></title><description><![CDATA[개발자로서 성장해 나가는 것을 기록하는 블로그입니다. 개발을 통해 보다 나은 세상을 만드는데 기여하고 싶습니다.]]></description><link>https://jaehyeon48.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 21 Dec 2021 02:55:07 GMT</lastBuildDate><item><title><![CDATA[리팩토링 방법들 Part.1]]></title><description><![CDATA[Inline Variable Motivation…]]></description><link>https://jaehyeon48.github.io/architecture/refactoring-list-1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/refactoring-list-1/</guid><pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;inline-variable&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#inline-variable&quot; aria-label=&quot;inline variable permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Inline Variable&lt;/h2&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/refactoring/inline_variable.png&quot; alt=&quot;Inline Variable&quot;&gt;
    &lt;figcaption&gt;Inline Variable&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* Before */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; basePrice &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; anOrder&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;basePrice&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; basePrice &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* After */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; anOrder&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;basePrice &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;motivation&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#motivation&quot; aria-label=&quot;motivation permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Motivation&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;변수의 이름을 통해 코드의 흐름을 파악할 수 있기 때문에, 일반적으로 변수는 좋은 것으로 취급된다.&lt;/li&gt;
&lt;li&gt;하지만 변수의 이름이 원래의 표현식과 다를 바 없는 경우, 혹은 리팩토링 하는데 변수가 방해되는 경우 해당 변수를 인라인하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;mechanics&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mechanics&quot; aria-label=&quot;mechanics permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mechanics&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;변수의 오른쪽에 있는 표현식(Right-Hand Side)이 side effect로부터 자유로운지 살펴본다.&lt;/li&gt;
&lt;li&gt;만약 변수가 immutable이 아니라면 immutable로 만들고 테스트한다.&lt;/li&gt;
&lt;li&gt;해당 변수를 최초로 사용하는 지점을 찾아 변수의 RHS로 인라인 하고 테스트한다.&lt;/li&gt;
&lt;li&gt;변수를 사용하는 나머지 부분에 대해 3번 과정을 반복한다.&lt;/li&gt;
&lt;li&gt;변수 선언부를 제거한다.&lt;/li&gt;
&lt;li&gt;테스트한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599&quot;&gt;리팩토링 2판&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[클린 코드 요약 정리 Ch.1]]></title><description><![CDATA[클린 코드를 번역/요약한 글입니다. 스스로를 “프로”라고 부르기 위해선 반드시 클린 코드를 작성할 줄 알아야 한다. 클린 코드를 작성하기 위해 최선을 다해야만 한다. 도입 (Introduction…]]></description><link>https://jaehyeon48.github.io/architecture/clean-code-summary-1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/clean-code-summary-1/</guid><pubDate>Wed, 15 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=sr_1_1?keywords=clean+code&amp;#x26;qid=1639537087&amp;#x26;sr=8-1&quot;&gt;클린 코드&lt;/a&gt;를 번역/요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;스스로를 “프로”라고 부르기 위해선 반드시 클린 코드를 작성할 줄 알아야 한다. 클린 코드를 작성하기 위해 최선을 다해야만 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;도입-introduction&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%84%EC%9E%85-introduction&quot; aria-label=&quot;도입 introduction permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;도입 (Introduction)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클린 코드를 작성하는 방법을 배우는 것은 &lt;strong&gt;어렵다&lt;/strong&gt;. 단순히 원칙이나 패턴들을 외운다고 되는 것이 아니라, 그것들을 몸으로 체득해야만 한다.&lt;/li&gt;
&lt;li&gt;이 책을 통해 배운 내용들을 &lt;strong&gt;반드시&lt;/strong&gt; 연습해보라. 눈으로만 읽고 넘기면 아무 소용없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;나쁜-코드-bad-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%98%EC%81%9C-%EC%BD%94%EB%93%9C-bad-code&quot; aria-label=&quot;나쁜 코드 bad code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나쁜 코드 (Bad Code)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;나쁜 코드는 회사를 망하게 할 수도 있다.&lt;/li&gt;
&lt;li&gt;자신이 짠 쓰레기같은 코드를 보며 “나중에 고쳐야지”라고 다짐한 적이 있을 것이다. 하지만 &lt;a href=&quot;https://en.wikipedia.org/wiki/Talk%3AList_of_eponymous_laws#:~:text=LeBlanc&amp;#x27;s%20Law%20states%3A%20%22Later%20equals,is%20attributed%20to%20Dave%20LeBlanc.&quot;&gt;르블랑의 법칙&lt;/a&gt;에 의하면 &lt;strong&gt;나중은 절대 오지 않는다&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;전면-재설계-the-grand-redesign-in-the-sky&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%84%EB%A9%B4-%EC%9E%AC%EC%84%A4%EA%B3%84-the-grand-redesign-in-the-sky&quot; aria-label=&quot;전면 재설계 the grand redesign in the sky permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;전면 재설계 (The Grand Redesign in the Sky)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클린 코드를 유지하기 위해 노력하는 것은 비용 효율적인 문제뿐만 아니라 생존과도 직결되어 있는 문제이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;태도-attitude&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%83%9C%EB%8F%84-attitude&quot; aria-label=&quot;태도 attitude permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;태도 (Attitude)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;한 시간이면 해결될 일을 몇 주에 걸쳐 했다든가, 한 줄만 고치면 될 것을 수백 개의 모듈을 건드린 적이 있는가? 이는 우리가 프로답지 못했기 때문에 발생한 일이다.&lt;/li&gt;
&lt;li&gt;스케줄과 요구 사항을 사수하는 것은 매니저의 역할이다. 우리(개발자)의 역할은 코드를 사수하는 것이다.&lt;/li&gt;
&lt;li&gt;당신이 의사라고 해보자. 만약에 환자가 당신보고 수술을 하기 전에 손을 씻는 것은 시간 낭비이니 하지 말라고 해서 손을 안 씻을 것인가? 당신은 환자보다 질병과 감염의 위험성에 대해 더 잘 알기 때문에 환자가 당신의 고객임에도 불구하고 당신은 환자의 말을 무시하고 손을 씻을 것이다. 의사가 환자의 말을 곧이곧대로 따르는 것은 프로답지 못한 행동일 것이다. 이와 마찬가지로, 나쁜 코드를 만드는 것에 대한 위험성을 잘 알지 못하는 매니저의 말을 곧이곧대로 따르는 개발자는 프로답지 못하다고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;원시적인-수수께끼-the-primal-conundrum&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9B%90%EC%8B%9C%EC%A0%81%EC%9D%B8-%EC%88%98%EC%88%98%EA%BB%98%EB%81%BC-the-primal-conundrum&quot; aria-label=&quot;원시적인 수수께끼 the primal conundrum permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;원시적인 수수께끼 (The Primal Conundrum)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“데드라인을 맞춰야 한다는 압박감으로 인해 개발을 서두르다 보니 나쁜 코드를 짜게 되었다”라는 말은 모순이다. 나쁜 코드를 짜게 되는 그 즉시 생산성이 하락해서 개발 속도가 늦어지고, 그로 인해 데드라인을 못 맞추게 된다.&lt;/li&gt;
&lt;li&gt;데드라인을 맞추는 방법, 즉 빠르게 개발하는 방법은 항상 코드를 클린 하게 유지하는것 밖에 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;클린-코드의-기술-the-art-of-clean-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B8%B0%EC%88%A0-the-art-of-clean-code&quot; aria-label=&quot;클린 코드의 기술 the art of clean code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클린 코드의 기술? (The Art of Clean Code?)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;“코드가 클린 하다”라는 말의 의미를 모른 채 클린 코드를 짜려고 하는 것은 좋지 않다.&lt;/li&gt;
&lt;li&gt;클린 코드를 짜는 것은 그림을 그리는 것과 상당히 비슷하다. 대부분은 잘 그린 그림과 못 그린 그림을 구분할 줄 안다. 하지만 이렇게 구분할 줄 안다고 해서 그림을 그릴 줄 안다는 뜻은 아니다. 이와 마찬가지로, 클린 코드와 나쁜 코드를 구분할 줄 안다고 해서 클린 코드를 짤 줄 안다는 뜻은 아니다.&lt;/li&gt;
&lt;li&gt;클린 코드를 짜기 위해선 힘들게 습득한 “깨끗함”에 대한 직감을 바탕으로 무수히 많은 작은 기술들을 규칙에 따라 적용해야 한다.&lt;/li&gt;
&lt;li&gt;코드에 대한 직감이 핵심이다. 직감을 타고난 사람도 있고, 직감을 얻기 위해 부단히 노력해야 하는 사람도 있다. 직감은 좋은 코드와 나쁜 코드를 구별할 수 있게 해줄 뿐만 아니라, 나쁜 코드를 좋은 코드로 변환하기 위한 원칙을 적용하는 전략을 알 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;코드에 대한 직감이 없는 사람은 좋은 코드와 나쁜 코드를 구분할 줄은 알지만, 그것뿐이다. 반면 직감이 있는 사람은 나쁜 코드를 보고, 어떻게 좋은 코드로 변환해야 할지 여러 옵션들 중에 최적의 해답을 찾아 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;클린-코드란-무엇인가-what-is-clean-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%93%9C%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-what-is-clean-code&quot; aria-label=&quot;클린 코드란 무엇인가 what is clean code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클린 코드란 무엇인가? (What Is Clean Code?)&lt;/h2&gt;
&lt;h3 id=&quot;비야네-스트롭스트룹-bjarne-stroustrup&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B9%84%EC%95%BC%EB%84%A4-%EC%8A%A4%ED%8A%B8%EB%A1%AD%EC%8A%A4%ED%8A%B8%EB%A3%B9-bjarne-stroustrup&quot; aria-label=&quot;비야네 스트롭스트룹 bjarne stroustrup permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;비야네 스트롭스트룹 (Bjarne Stroustrup)&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;나는 우아하고 효율적인 코드를 좋아한다. …(중략) 클린 코드는 한 가지 일을 잘 하는 코드이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;우아하다&lt;/em&gt;의 사전적 정의를 보면, “외모나 태도가 기분 좋게 품위 있고 세련된, 기분 좋게 독창적이고 간단한”이라고 한다. 비야네는 클린 코드를 &lt;strong&gt;읽기 즐거운 코드&lt;/strong&gt;라고 여긴다.&lt;/li&gt;
&lt;li&gt;또한 &lt;em&gt;효율성&lt;/em&gt;을 강조하고 있는데, 그도 그럴것이 비효율적인 코드는 우아하지 못하고 재미가 없다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리팩토링 2판 요약 정리 Ch.4]]></title><description><![CDATA[리팩토링 2판을 번역/요약한 글입니다. 테스트 만들기 (Building Tests) 리팩토링은 그 자체로 매우 훌륭한 도구이지만, 이것만으론 부족하다. 혹시 모를 실수에 대비해 반드시 견고한 테스트 코드가 있어야 한다. (IDE…]]></description><link>https://jaehyeon48.github.io/architecture/refactoring-summary-4/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/refactoring-summary-4/</guid><pubDate>Tue, 14 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599&quot;&gt;리팩토링 2판&lt;/a&gt;을 번역/요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h1 id=&quot;테스트-만들기-building-tests&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0-building-tests&quot; aria-label=&quot;테스트 만들기 building tests permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;테스트 만들기 (Building Tests)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링은 그 자체로 매우 훌륭한 도구이지만, 이것만으론 부족하다. 혹시 모를 실수에 대비해 반드시 견고한 테스트 코드가 있어야 한다. (IDE와 같은 도구에서 제공하는) 자동 리팩토링 기능을 사용한다고 하더라도 테스트 코드를 통해 테스트하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;굳이 리팩토링 때문만이 아니더라도, 좋은 테스트를 작성하고 사용하면 개발자로서의 효율을 높일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;자가-테스트-코드의-가치-the-value-of-self-testing-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EA%B0%80-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%EA%B0%80%EC%B9%98-the-value-of-self-testing-code&quot; aria-label=&quot;자가 테스트 코드의 가치 the value of self testing code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자가 테스트 코드의 가치 (The Value of Self-Testing Code)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;사실, 대부분의 개발자들은 디버깅하는데 대부분의 시간을 보낸다. 실제 개발을 하는 시간은 상대적으로 적다. 일반적으로 버그를 &lt;strong&gt;해결&lt;/strong&gt;하는 것은 그렇게 어렵진 않지만(?), 버그를 &lt;strong&gt;찾는&lt;/strong&gt; 것은 지옥이다. 그리고 버그를 하나 해결하면 또 다른 곳에서 버그가 튀어나온다. &lt;del&gt;버그 보존의 법칙&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;모든 테스트가 자동으로 결과를 체크하도록 하는 것이 좋다 (콘솔 창 같은 곳에 찍힌 테스트 로그를 수동으로 일일이 비교하고 있을 순 없지 않은가?).&lt;/li&gt;
&lt;li&gt;이렇게 테스트를 자동화하면 생산성을 (훨씬) 증대할 수 있다. 나의 경험을 예로 들자면, 기능(함수)을 추가할 때마다 테스트 코드를 추가하고 테스트를 돌렸더니 버그를 찾는데 걸리는 시간이 감소하여 결과적으로 디버깅 시간이 감소했다.&lt;/li&gt;
&lt;li&gt;또한, 테스트를 자주 돌렸기에 버그가 발생한 지점이 내가 방금 작성한 코드에 있음을 빠르게 파악할 수 있었고, 살펴봐야 하는 코드의 양이 적기 때문에 빠르게 디버깅할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;기타-요약&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B8%B0%ED%83%80-%EC%9A%94%EC%95%BD&quot; aria-label=&quot;기타 요약 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;기타 요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;각 테스트 케이스가 실패하는 모습을 적어도 한 번이상은 직접 확인해보라. 항상 성공만 하는 테스트는 별 의미없다.&lt;/li&gt;
&lt;li&gt;테스트를 쉽게 돌릴 수 있도록 도와주고, 실패한 테스트 케이스를 쉽고 빠르게 볼 수 있게 해주는 프레임워크가 좋은 테스트 프레임워크이다. 이는 자가 테스트 코드에 있어 필수적인 피드백이다.&lt;/li&gt;
&lt;li&gt;테스트를 자주 해라. 현재 작성 중인 코드는 수 분마다 테스트하고, 모든 테스트를 적어도 하루에 한 번 이상 돌려라.&lt;/li&gt;
&lt;li&gt;테스트는 현재, 혹은 미래에 발생할 버그를 찾기 위해 수행하는 것이다. 따라서 테스트는 위험 요인을 위주로, 즉 risk-driven 방식으로 수행해야 한다. 단순히 읽고 쓰기만 하는 (클래스의) 접근자 같은 것들은 단순하기 때문에 버그를 찾을 가능성이 낮고, 따라서 굳이 테스트할 필요가 없다.&lt;/li&gt;
&lt;li&gt;너무 많은 테스트 케이스를 작성하게 되면 정작 필요한 테스트를 놓치게될 수 있다. 나는 주로 잘못될까봐 걱정되는 영역 위주로 테스팅하는데, 이렇게 적은 수의 테스트 케이스 만으로도 테스트의 많은 이점을 누릴 수 있다.&lt;/li&gt;
&lt;li&gt;완벽한 테스트를 아예 하지 않는 것보단 불완전한 테스트를 하는 것이 차라리 낫다.&lt;/li&gt;
&lt;li&gt;무언가 잘못될 수 있는 경계 조건을 반드시, 그리고 집중적으로 검사하라.&lt;/li&gt;
&lt;li&gt;내가 코드의 적(enemy)이 되었다고 생각하고 테스트하라. 어떻게 하면 테스트를 실패시킬 수 있는지 생각하라.&lt;/li&gt;
&lt;li&gt;테스팅으로 모든 버그를 잡아낼 수 없다는 사실 때문에 테스트를 안 한다 는건 말도 안된다. 테스팅으로 모든 버그를 잡을 수 없는 건 사실이지만, 대부분의 버그는 충분히 잡아낼 수 있기에 걱정할 필요 없다.&lt;/li&gt;
&lt;li&gt;앞서 말했듯이 리스크가 큰 영역, 복잡한 영역 위주로 테스트하라. 모든 영역에 대해 일일이 테스트를 하다 보면 지쳐서 테스트를 포기하게 될 수도 있다.&lt;/li&gt;
&lt;li&gt;물론 테스트를 통해 모든 버그를 찾아낼 수는 없지만 리팩토링을 하면서 코드에 대해 더 많이 이해하게 되고, 그로 인해 점차 더 많은 버그를 찾아낼 수 있다.&lt;/li&gt;
&lt;li&gt;버그를 발견하게 되면, 즉시 해당 버그를 명확히 잡아내는 테스트를 작성하는 습관을 들여라. 나는 항상 버그를 고치기 전에 이러한 테스트 케이스부터 만든다. 또한, 이를 계기로 테스트 케이스에 또 다른 허점은 없는지 살펴본다.&lt;/li&gt;
&lt;li&gt;나는 항상 테스트를 마련한 다음 리팩토링을 진행하지만, 리팩토링하는 와중에도 계속해서 테스트를 추가한다.&lt;/li&gt;
&lt;li&gt;새로운 기능을 추가할 때, (당연하게도) 새로운 테스트도 추가하지만 기존 테스트도 다시 살펴보라. 테스트들이 명확한지, 무엇을 하는지 더욱 이해하기 쉽도록 리팩토링 해야 하는지, 올바른 테스트를 갖췄는지 등등을 살펴보라.&lt;/li&gt;
&lt;li&gt;“충분한 테스트”에 대한 좋은 측정 수단은 없다. 몇몇 사람들은 테스트 커버리지를 통해 측정해야 한다고 주장하지만, 테스트 커버리지는 테스트 되지 않은 영역을 식별해 내는 데엔 유용하지만 테스트의 퀄리티를 측정하지는 않는다.&lt;/li&gt;
&lt;li&gt;결국 “충분한 테스트”에 대한 기준은 주관적이다. “누군가 코드에 결함을 만들게 되었을 때 (테스트를 통해) 이를 캐치해낼 수 있는가?” 와 같은 것들이다. 자가 테스트 코드의 목적은 (코드에 대해) 자신감을 얻기 위함이다. 리팩토링했을 때 모든 테스트를 통과하게 되면, 리팩토링 과정에서 어떠한 버그도 만들지 않았다고 자신할 수 있고 테스트를 충분히 했다고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리팩토링 2판 요약 정리 Ch.3]]></title><description><![CDATA[리팩토링 2판을 번역/요약한 글입니다. 코드에서 나는 악취 (Bad Smells in Code…]]></description><link>https://jaehyeon48.github.io/architecture/refactoring_summary_3/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/refactoring_summary_3/</guid><pubDate>Sun, 12 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599&quot;&gt;리팩토링 2판&lt;/a&gt;을 번역/요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h1 id=&quot;코드에서-나는-악취-bad-smells-in-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EB%82%98%EB%8A%94-%EC%95%85%EC%B7%A8-bad-smells-in-code&quot; aria-label=&quot;코드에서 나는 악취 bad smells in code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드에서 나는 악취 (Bad Smells in Code)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;언제 리팩토링을 시작할 것인지(그리고 언제 멈출 것인지)를 아는 것은 리팩토링의 작동 원리를 아는 것 못지 않게 중요하다.&lt;/li&gt;
&lt;li&gt;인스턴스 변수를 제거하는 법이나 계층을 만드는 법을 설명하는 것은 쉽다. 하지만 이것들을 &lt;em&gt;언제&lt;/em&gt; 해야 하는지를 설명하는 것은 쉽지 않다.&lt;/li&gt;
&lt;li&gt;우리의 경험에 따르면, 어떠한 (정량적) 지표도 숙련된 사람의 직관보다 못했다. 이제 우리는 리팩토링으로 개선할 수 있는 문제들에 대한 암시를 주려고 한다.&lt;/li&gt;
&lt;li&gt;이제부터 당신은 인스턴스 변수가 몇 개 정도 되면 많은 것인지, 혹은 메서드의 코드가 몇 줄 이상이면 많은 것인지 판단할 수 있는 감각을 기르려고 노력 해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;미스테리한-이름-mysterious-name&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AF%B8%EC%8A%A4%ED%85%8C%EB%A6%AC%ED%95%9C-%EC%9D%B4%EB%A6%84-mysterious-name&quot; aria-label=&quot;미스테리한 이름 mysterious name permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;미스테리한 이름 (Mysterious Name)&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;컴퓨터 과학에서 어려운 점은 두 가지다: 캐시 무효화(invalidation)와 이름 짓기. - 필 칼튼&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;코드는 추리 소설이 아니다. 국제적으로 미스테리한 인물이 되는 것에 대한 환상을 가질 수 있겠으나, 우리의 코드는 평범하고 깔끔해야 한다.&lt;/li&gt;
&lt;li&gt;깔끔한 코드의 가장 중요한 부분 중 하나는 좋은 이름이다. 따라서 함수, 모듈, 변수, 클래스 등이 무엇을 하는지, 그리고 어떻게 쓰는지를 잘 나타내는 이름을 (많은 생각을 통해) 지어야 한다.&lt;/li&gt;
&lt;li&gt;아마 우리가 하는 리팩토링의 거의 대부분은 이름을 바꾸기가 될 것이다.&lt;/li&gt;
&lt;li&gt;흔히 사람들은 이름을 바꾸는 리팩토링을 할 필요 없다고 생각하는데, 좋은 이름은 추후에 코드를 이해하는 데 소요되는 시간을 아껴줄 것이다.&lt;/li&gt;
&lt;li&gt;좋은 이름이 떠오르지 않는다면, 무언가 설계에 문제가 있지는 않은지 검토해 볼 필요가 있다. 좋은 이름을 골똘히 생각하다 보면 (설계에 대해 생각해 봄으로써) 코드가 상당히 간결해지는 경우도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;중복된-코드-duplicated-code&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%BD%94%EB%93%9C-duplicated-code&quot; aria-label=&quot;중복된 코드 duplicated code permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;중복된 코드 (Duplicated Code)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;코드 구조가 두 번 이상 반복된다면 하나로 합치는 것을 권장한다. 중복된 코드가 있다면 코드를 읽을 때도 무언가 차이가 있는지 면밀히 살펴봐야 하고, 중복된 코드를 수정하려고 하면 중복된 코드들 모두를 같이 바꿔주어야 한다.&lt;/li&gt;
&lt;li&gt;중복된 코드의 가장 단순한 예로는, 한 클래스에 존재하는 두 메소드가 같은 문장을 사용하는 경우이다. 이 경우 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;를 써서 추출된 함수를 두 곳에서 호출하는 형태로 바꾸는 것이 좋다.&lt;/li&gt;
&lt;li&gt;만약 코드가 똑같진 않고 비슷하다면 &lt;a href=&quot;&quot;&gt;Slide Statements&lt;/a&gt;를 이용하여 비슷한 부분을 하나로 묶을 수 있는지 살펴보는 것을 권장한다.&lt;/li&gt;
&lt;li&gt;공통 부모 클래스의 자식 클래스 내부에 중복되는 부분이 존재하는 경우엔 &lt;a href=&quot;&quot;&gt;Pull Up Method&lt;/a&gt;를 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;긴-함수-long-function&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B8%B4-%ED%95%A8%EC%88%98-long-function&quot; aria-label=&quot;긴 함수 long function permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;긴 함수 (Long Function)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;우리의 경험상, 함수들이 작을 때 (함수 코드가 짧을 때) 프로그램이 오랫동안 잘 동작했었다. 이러한 프로그램을 처음 맞닥뜨리는 개발자는 (함수들이) 끊임없이 서로에게 위임을 하는 모습을 보고 실질적으로 어떠한 계산도 일어나지 않는 것처럼 보일 수도 있다.&lt;/li&gt;
&lt;li&gt;하지만 몇 년 동안 이러한 코드를 다뤄봤다면 함수들이 작은 것이 얼마나 중요한지 깨달았을 것이다.&lt;/li&gt;
&lt;li&gt;작은 함수를 사용해야 &lt;a href=&quot;https://en.wikipedia.org/wiki/Indirection&quot;&gt;indirection&lt;/a&gt;의 이점을 누릴 수 있다.&lt;/li&gt;
&lt;li&gt;초창기 프로그래밍 언어에선 서브루틴을 호출할 때의 오버헤드로 인해 사람들이 짧은 함수를 사용하는 것을 꺼려 했다. 그러나 현대의 언어들은 이러한 오버헤드를 대부분 제거했다. 하지만 함수가 무슨 일을 하는지 살펴보려면 코드 이리저리 왔다 갔다 해야 하기 때문에 코드를 읽는 사람에겐 여전히 오버헤드가 존재하긴 한다.&lt;/li&gt;
&lt;li&gt;개발 환경을 통해 이러한 오버헤드를 줄일 수 있긴 하지만(vscode에서처럼 동시에 두 코드를 읽는다든지..), 작은 함수를 이해하는 핵심은 결국 좋은 이름이다. 함수의 이름이 잘 지어져있다면 함수의 body를 보지 않고서도 그 함수가 무엇을 하는지 알아낼 수 있다.&lt;/li&gt;
&lt;li&gt;좋은 이름의 이러한 이점을 최대한 활용해서, 함수를 공격적으로 쪼개야 한다. 우리는 주석을 달고 싶을 때 주석 대신 함수를 작성하는데, 이렇게 하면 우리가 주석으로 달려고 했던 내용을 이름과 함께 실제 코드로 작성함으로써 우리의 의도를 더욱 명확히 드러낼 수 있게 된다.&lt;/li&gt;
&lt;li&gt;함수 호출부가 원래의 코드보다 길어진다고 하더라도 함수로 분리한다. 단, 반드시 함수의 동작을 잘 설명하는 이름을 지어야 한다.&lt;/li&gt;
&lt;li&gt;여기서 핵심은 함수의 길이가 아니라 함수가 하는 동작과 그것을 구현한 코드 간의 괴리이다. 즉, 어떤 코드가 자신이 무엇을 하는지 잘 설명하지 못할 수록 함수로 분리하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;큰 함수를 작은 함수로 분리할 땐 십중팔구 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt; 방법을 쓰면 된다. 함수 내에서 서로 연관된 부분들을 묶어 새로운 함수로 분리하라.&lt;/li&gt;
&lt;li&gt;매개 변수와 임시 변수가 많은 함수의 경우, 코드를 추출해서 새로운 함수로 만드는 것이 힘들 수 있다. &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt; 방법을 쓰게 되면 분리된 함수에 너무 많은 인자를 넘겨야 해서 결국 분리한 효과를 누릴 수 없게 될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Replace Temp with Query&lt;/a&gt;를 사용해서 임시 변수를 줄일 수 있고, &lt;a href=&quot;&quot;&gt;Introduce Parameter Object&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Preserve Whole Object&lt;/a&gt;기법을 사용해서 함수로 전달되는 매개 변수의 개수를 줄일 수 있다.&lt;/li&gt;
&lt;li&gt;만약 위 기법들을 사용했음에도 불구하고 여전히 매개 변수와 임시 변수가 많이 남아있는 경우, 최후의 수단으로 &lt;a href=&quot;&quot;&gt;Replace Function with Command&lt;/a&gt;를 적용해볼 수 있다.&lt;/li&gt;
&lt;li&gt;추출할 코드를 판단하는 좋은 기준 중 하나는 바로 주석이다. 주석이 달려있는 코드를 함수로 분리한 후, 주석을 기반으로 이름을 지으면 된다. 코드가 더 명확해질 수만 있다면 비록 한 줄짜리 함수가 되더라도 분리하는 것을 추천한다.&lt;/li&gt;
&lt;li&gt;조건문과 반복문 또한 좋은 기준이 될 수 있는데, &lt;a href=&quot;&quot;&gt;Decompose Conditional&lt;/a&gt;을 사용해서 조건문을 분리할 수 있다. 거대한 &lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt; 구문도 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 통해 한 줄짜리 함수 호출문으로 바꿀 수 있다. 만약 똑같은 조건에 의해 분기하는 &lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt; 구문이 여러 개 있다면 &lt;a href=&quot;&quot;&gt;Replace Conditional with Polymorphism&lt;/a&gt;을 적용할 수 있다.&lt;/li&gt;
&lt;li&gt;반복문의 경우 반복문 자체와 반복문 내부의 로직을 분리하여 함수로 만드는 것을 추천한다. 만약 이렇게 추출된 함수의 이름 짓는 것이 어렵다면 반복문이 너무 많은 일을 하고 있진 않은지 살펴보라. 만약 두 가지 이상의 일을 한다면 &lt;a href=&quot;&quot;&gt;Split Loop&lt;/a&gt;을 적용해 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;너무-많은-매개-변수-long-parameter-list&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%84%88%EB%AC%B4-%EB%A7%8E%EC%9D%80-%EB%A7%A4%EA%B0%9C-%EB%B3%80%EC%88%98-long-parameter-list&quot; aria-label=&quot;너무 많은 매개 변수 long parameter list permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;너무 많은 매개 변수 (Long Parameter List)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍을 처음에 배울 때, 우리는 함수가 필요로 하는 모든 것을 매개 변수로 넘기라고 배운다. 만약 이렇게 안 하면 글로벌 변수를 사용해야 하기 때문에 이는 꽤 합리적인 가르침이다. 하지만 매개 변수가 너무 많은 경우 그 자체로 혼란스러울 수 있다.&lt;/li&gt;
&lt;li&gt;만약 다른 매개 변수를 통해 값을 구할 수 있는 매개 변수가 있다면 &lt;a href=&quot;&quot;&gt;Replace Parameter with Query&lt;/a&gt;를 사용하여 해당 매개 변수를 제거할 수 있다. 또한, &lt;a href=&quot;&quot;&gt;Preserve Whole Object&lt;/a&gt;를 사용하여 기존에 존재하는 자료 구조에서 데이터를 추출하여 매개 변수로 넘기는 대신 원본 자료 구조 그 자체를 넘기도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;여러 개의 매개 변수들이 항상 세트로 묶여 사용된다면 &lt;a href=&quot;&quot;&gt;Introduce Parameter Object&lt;/a&gt;를 적용하여 하나의 객체로 묶을 수 있다.&lt;/li&gt;
&lt;li&gt;일종의 “flag”로 사용되는 매개 변수의 경우, &lt;a href=&quot;&quot;&gt;Remove Flag Argument&lt;/a&gt;기법을 적용해 볼 수 있다.&lt;/li&gt;
&lt;li&gt;클래스를 사용하여 매개 변수의 개수를 줄일 수도 있다. 특히, 여러 함수들이 동일한 매개 변숫값을 공유하는 경우 더욱 도움이 된다. 이 경우 &lt;a href=&quot;&quot;&gt;Combine Functions into Class&lt;/a&gt;를 사용하여 공유되어 사용되는 변수를 클래스 필드 변수로 바꿀 수 있다. 함수형 프로그래밍 관점에서 보자면 이는 부분 적용 함수들을 만드는 것과 흡사하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;전역-데이터-global-data&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%84%EC%97%AD-%EB%8D%B0%EC%9D%B4%ED%84%B0-global-data&quot; aria-label=&quot;전역 데이터 global data permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;전역 데이터 (Global Data)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로그래밍을 처음 배울 때부터, 우리는 전역 변수(데이터)의 위험성에 대해 교육을 받는다. 전역 변수는 어디서나 접근이 가능하기 때문에 어디서든 그 값을 변경할 수 있다. 하지만 전역 변수를 수정하고 있는 부분을 찾는 것은 쉽지 않다. 이로 인해 전역 변수와 관련된 버그가 발생해도 어디서 잘못되었는지를 찾기 쉽지 않다.&lt;/li&gt;
&lt;li&gt;가장 흔한 예로 “전역 변수”를 들었지만, 이러한 문제는 클래스 변수와 싱글톤에서도 나타나는 문제이다.&lt;/li&gt;
&lt;li&gt;이러한 문제를 방지할 수 있는 핵심적인 방법은 바로 &lt;a href=&quot;&quot;&gt;Encapsulate Variable&lt;/a&gt;이다. 일단 전역 변수를 함수로 감싸게 되면 적어도 어디서 해당 변수를 참조하고 있는지를 비교적 쉽게 파악할 수 있다. 그런 다음 변수의 스코프 범위를 최대한 축소하는 것이 바람직하다.&lt;/li&gt;
&lt;li&gt;전역 변수가 가변(mutable)인 경우 상황은 더욱 끔찍하다. 일단 프로그램이 시작되면 값이 바뀌지 않는다는 보장이 있는 경우엔 그나마 안전하다고 할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Paracelsus&quot;&gt;파라켈수스&lt;/a&gt;가 “약과 독의 차이는 사용량이다”라고 한 것처럼, 전역 데이터가 적은 경우 어떻게든 잘 관리할 수 있지만, 전역 데이터가 많아지면 이를 관리하는 게 기하급수적으로 어려워진다.&lt;/li&gt;
&lt;li&gt;하지만 전역 데이터가 몇 개 없다고 해도, 추후 있을지도 모르는 변화에 대응하기 위해 이들을 캡슐화하는 것을 권장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;가변-데이터-mutable-data&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%80%EB%B3%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-mutable-data&quot; aria-label=&quot;가변 데이터 mutable data permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;가변 데이터 (Mutable Data)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 변경하는 경우, 예기치 못한 버그가 발생할 수 있다. 어떤 데이터에 대해, 그 데이터를 사용하는 곳에서 예상하는 것과는 다르게 변경을 해버리면 버그가 발생할 수 있고, 특히 이러한 일이 특별한 조건에서만 일어나는 일이라면 디버깅하기 매우 어렵다.&lt;/li&gt;
&lt;li&gt;이러한 이유로 함수형 프로그래밍에선 아예 데이터를 수정할 땐 그 데이터를 직접 수정하는 것이 아니라, 그 데이터를 기반으로 한 새로운 버전(new copy)의 데이터를 새로 “생성” 하도록 하고 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Encapsulate Variable&lt;/a&gt; 기법을 활용하여 데이터 변경이 특정 함수 내에서 일어나게 함으로써 데이터의 변화를 모니터링하기 쉽게 할 수 있다.&lt;/li&gt;
&lt;li&gt;만약 어떤 변수가 기존의 것과 다른 것을 저장하도록 변경된다면, &lt;a href=&quot;&quot;&gt;Split Variable&lt;/a&gt;을 사용해서 두 값을 분리하여 관리하도록 하는 것을 권장한다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Slide Statements&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 활용하여 데이터를 업데이트 하는 부분을 최대한 따로 빼내어 함수를 순수 함수로 바꿀 수 있다.&lt;/li&gt;
&lt;li&gt;API에선 &lt;a href=&quot;&quot;&gt;Separate Query from Modifier&lt;/a&gt;를 사용하여, 정말 필요한 경우가 아니라면 side effect가 존재하는 코드를 호출자가 사용하지 못하도록 하는 것을 추천한다. 또한 최대한 빨리 &lt;a href=&quot;&quot;&gt;Remove Setting Method&lt;/a&gt;를 적용하라.&lt;/li&gt;
&lt;li&gt;여러 군데에서 계산할 수 있는 (따라서 변경 가능한) mutable 데이터에선 상당히 불쾌한 냄새가 난다. 이와 같은 Mutable 데이터는 버그와 혼란의 근원일 뿐만 아니라, 딱히 필요가 없는 존재이다. 이러한 Mutable 데이터엔 &lt;a href=&quot;&quot;&gt;Replace Derived Variable with Query&lt;/a&gt;를 사용하여 냄새를 제거할 수 있다.&lt;/li&gt;
&lt;li&gt;물론, mutable 데이터의 스코프 범위가 몇 줄 안되는 경우엔 딱히 문제 될 게 없을 수 있으나, 스코프가 커짐에 따라 리스크도 커지게 된다. &lt;a href=&quot;&quot;&gt;Combine Functions into Class&lt;/a&gt; 혹은 &lt;a href=&quot;&quot;&gt;Combine Functions into Transform&lt;/a&gt;과 같은 방법을 사용하여 변수를 업데이트하는데 필요한 코드의 수를 제한하라.&lt;/li&gt;
&lt;li&gt;만약 (mutable) 변수가 어떤 내부적인 구조를 가지고 있다면 일반적으로 그 자리에서 변경하기보단 구조 전체를 갈아치우는 게 더 좋을 수 있다. 이 경우 &lt;a href=&quot;&quot;&gt;Change Reference to Value&lt;/a&gt;를 사용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;산발적인-수정-divergent-change&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%82%B0%EB%B0%9C%EC%A0%81%EC%9D%B8-%EC%88%98%EC%A0%95-divergent-change&quot; aria-label=&quot;산발적인 수정 divergent change permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;산발적인 수정 (Divergent Change)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어는 변경에 유연해야, 즉 “소프트”해야 소프트웨어답다.&lt;/li&gt;
&lt;li&gt;흔히 어떤 모듈이 서로 다른 이유로 인해 각기 다른 방식으로 변경이 일어날 때 산발적으로 수정이 일어난다고 한다.&lt;/li&gt;
&lt;li&gt;예를 들면 “새로운 DB가 추가되면 여기 3개의 함수를 바꿔야지”, “새로운 금융 상품이 추가되면 저기 4개의 함수를 바꿔야지”와 같은 것들이 (어떤 한 모듈 내에서) 산발적 수정이 존재함을 알리는 신호이다.&lt;/li&gt;
&lt;li&gt;DB와 관련된 작업과 금융과 관련된 로직은 서로 다른 context 이므로 이들을 별개의 모듈로 분리하는 것이 정신건강에 좋다. 이렇게 하면, 특정 context과 관련된 변경 사항이 생겼을 때, 다른 context는 신경 쓸 필요 없이 해당 context만 이해하면 된다.&lt;/li&gt;
&lt;li&gt;물론 개발 초기에 이러한 context들의 경계가 불분명하고, 시스템이 커짐에 따라 변경되기도 한다.&lt;/li&gt;
&lt;li&gt;DB로부터 데이터를 가져와서 금융과 관련된 로직을 수행하는 것이 자연스럽다면, &lt;a href=&quot;&quot;&gt;Split Phase&lt;/a&gt;를 적용하여 이 둘을 분리한 다음 명확한 자료구조를 이용하여 둘 사이에 데이터를 전달하는 방법을 사용할 수 있다. 만약 앞뒤로 더 많은 함수 호출들이 존재한다면 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 이용하여 적절한 모듈로 분리할 수 있다. 만약 분리할 함수 내에 여러 종류의 로직이 섞여있다면 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 활용하여 이들을 추출해낼 수 있다. 만약 모듈이 클래스라면 &lt;a href=&quot;&quot;&gt;Extract Class&lt;/a&gt;가 도움이 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;샷건-수술-shotgun-surgery&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%B7%EA%B1%B4-%EC%88%98%EC%88%A0-shotgun-surgery&quot; aria-label=&quot;샷건 수술 shotgun surgery permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;샷건 수술 (Shotgun Surgery)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;샷건 수술은 산발적 수정과 흡사하지만 정반대의 경우이다. 코드를 변경할 때마다 여러 군데를 자잘하게 고쳐야 하는 경우 이러한 냄새를 맡을 수 있는데, 이렇게 되면 변경해야 할 부분들이 군데군데 흩어져있기 때문에 찾기도 어렵고 (변경하는 것을) 까먹기도 쉽다.&lt;/li&gt;
&lt;li&gt;이 경우 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;과 &lt;a href=&quot;&quot;&gt;Move Field&lt;/a&gt;를 이용하여 변경해야 할 부분들을 하나의 모듈로 모을 수 있다.&lt;/li&gt;
&lt;li&gt;비슷한 데이터를 사용하는 함수들은 &lt;a href=&quot;&quot;&gt;Combine Functions into Class&lt;/a&gt;를 사용하여 묶을 수 있고, 어떤 자료 구조를 변환하거나 보강하는 함수들은 &lt;a href=&quot;&quot;&gt;Combine Functions into Transform&lt;/a&gt;을 사용할 수 있다. 이렇게 묶인 공통 함수들의 출력을 묶어서 다음 로직의 입력으로 전달할 수 있다면 &lt;a href=&quot;&quot;&gt;Split Phase&lt;/a&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Inline Function&lt;/a&gt; 또는 &lt;a href=&quot;&quot;&gt;Inline Class&lt;/a&gt;를 사용하여 어설프게 분리된 로직들을 리팩토링하는 것도 좋은 전략이 될 수 있다. 이렇게 하면 큰 함수(혹은 클래스)가 생길 수 있으나, 이후 적절한 단위로 분할하면 되므로 딱히 상관없다.&lt;/li&gt;
&lt;li&gt;비록 우리(저자)는 작은 함수(와 클래스)에 과도할 정도로 집착하긴 하지만, 코드의 구조를 잡아가는 과정에 있어 중간 단계에서 생기는 큰 함수들은 괜찮다고 생각한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;기능에-대한-욕심-feature-envy&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B8%B0%EB%8A%A5%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9A%95%EC%8B%AC-feature-envy&quot; aria-label=&quot;기능에 대한 욕심 feature envy permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;기능에 대한 욕심 (Feature Envy)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;모듈화를 하는 경우, 우리는 모듈 내부의 코드끼리는 더욱 강하게 결합되도록, 그리고 모듈 간에는 약하게 결합되도록 하려고 한다.&lt;/li&gt;
&lt;li&gt;“기능에 대한 욕심”의 가장 대표적인 케이스는 한 모듈 내의 어떤 함수가 같은 모듈에 있는 함수들(혹은 데이터) 보다 다른 모듈과 더욱 많이 소통하는 경우이다.&lt;/li&gt;
&lt;li&gt;이 경우, &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 이용하여 해당 함수가 많이 사용(소통) 하는 데이터 근처로 함수를 옮기면 된다. 때로는 함수의 일부분만 욕심을 부리므는 경우가 있는데 이 땐 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 사용하여 그 부분을 추출한 다음 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 이용하여 옮겨주면 된다.&lt;/li&gt;
&lt;li&gt;물론 어떤 함수가 여러 모듈의 기능을 사용하는 경우 좀 더 까다롭다. 이럴 때 우린 함수를 데이터가 가장 많이 있는 모듈로 옮겼다. 이때 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 적용하면 각각의 함수 조각을 적절한 모듈들로 옮기는 게 더 수월할 수 있다.&lt;/li&gt;
&lt;li&gt;결국 핵심은 같이 변하는 것들을 한곳에 모으는 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;데이터-뭉치-data-clumps&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AD%89%EC%B9%98-data-clumps&quot; aria-label=&quot;데이터 뭉치 data clumps permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;데이터 뭉치 (Data Clumps)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;데이터는 마치 아이들처럼 서로 뭉쳐다니는 것을 좋아한다. 이렇게 같이 어울려다니는 데이터들은 하나로 묶는 것이 좋다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Extract Class&lt;/a&gt;를 사용하여 클래스 필드 데이터 뭉치들을 하나의 객체로 묶을 수 있다. 또, &lt;a href=&quot;&quot;&gt;Introduce Parameter Object&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Preserve Whole Object&lt;/a&gt;를 사용하여 매개 변수 뭉치들을 하나로 묶을 수 있다.&lt;/li&gt;
&lt;li&gt;이렇게 묶인 객체의 일부만을 사용하는 데이터 뭉치에 대해선 걱정할 필요가 없다. 두 개 이상의 데이터를 하나의 객체로 묶는 한, 결국에는 이득을 보게 될 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;원시-타입에-대한-집착-primitive-obsession&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9B%90%EC%8B%9C-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A7%91%EC%B0%A9-primitive-obsession&quot; aria-label=&quot;원시 타입에 대한 집착 primitive obsession permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;원시 타입에 대한 집착 (Primitive Obsession)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;많은 개발자들이 화폐, 좌표, 범위와 같이 자신들만의 데이터 타입을 만들기 꺼려 하는 것 같다. 이 때문에 종종 돈 계산을 (화폐 단위를 생략한 채) 평범한 숫자 타입으로 한다든지, (단위를 무시한 채) 물리적인 수량을 계산한다든지, 혹은 &lt;code class=&quot;language-text&quot;&gt;if (a &amp;lt; upper &amp;amp;&amp;amp; a &gt; lower)&lt;/code&gt; 와 같은 코드를 볼 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Replace Primitive with Object&lt;/a&gt;를 이용하여 원시 타입을 의미있는 타입으로 변경할 수 있다. 만약 원시 타입이 분기문을 제어하는 역할을 한다면 &lt;a href=&quot;&quot;&gt;Replace Type Code with Subclasses&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Replace Conditional with Polymorphism&lt;/a&gt;을 이용할 수 있다.&lt;/li&gt;
&lt;li&gt;같이 어울려 다니는 원시 타입들엔 &lt;a href=&quot;&quot;&gt;Extract Class&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Introduce Parameter Object&lt;/a&gt;를 적용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;반복된-switch-문-repeated-switches&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B0%98%EB%B3%B5%EB%90%9C-switch-%EB%AC%B8-repeated-switches&quot; aria-label=&quot;반복된 switch 문 repeated switches permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;반복된 Switch 문 (Repeated Switches)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt; 문을 중복해서 사용하는 경우, 하나의 케이스가 추가될 때 (중복된) 모든 &lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt; 문을 찾아 바꿔줘야 한다.&lt;/li&gt;
&lt;li&gt;이렇게 중복이 발생하고 있다면 &lt;a href=&quot;&quot;&gt;Replace Conditional with Polymorphism&lt;/a&gt;을 이용하여 조건부 로직을 다형성 로직으로 바꿔보자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;루프문-loops&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A3%A8%ED%94%84%EB%AC%B8-loops&quot; aria-label=&quot;루프문 loops permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;루프문 (Loops)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Replace Loop with Pipeline&lt;/a&gt; 기법을 통해 루프문을 일급 함수로 변환하는 것을 추천한다. 우리의 경험으로 보자면 &lt;code class=&quot;language-text&quot;&gt;filter&lt;/code&gt; 나 &lt;code class=&quot;language-text&quot;&gt;map&lt;/code&gt; 같은 파이프라인 함수들을 통해 코드의 흐름을 더욱 쉽고 빠르게 파악할 수 있었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;성의없는-요소-lazy-element&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%B1%EC%9D%98%EC%97%86%EB%8A%94-%EC%9A%94%EC%86%8C-lazy-element&quot; aria-label=&quot;성의없는 요소 lazy element permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;성의없는 요소 (Lazy Element)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;굳이 함수로 분리하지 않아도 이해할 수 있는 코드, 하나의 단순한 함수와 별 다를 것이 없는 클래스와 같이 굳이 별도의 구조를 형성하지 않아도 될만한 부분들이 존재할 수 있다.&lt;/li&gt;
&lt;li&gt;이 경우 &lt;a href=&quot;&quot;&gt;Inline Function&lt;/a&gt; 혹은 &lt;a href=&quot;&quot;&gt;Inline Class&lt;/a&gt;를 통해 이러한 구조를 제거하는 것을 권장한다. 상속을 사용하는 경우 &lt;a href=&quot;&quot;&gt;Collapse Hierarchy&lt;/a&gt;를 사용할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;추측성-일반화-speculative-generality&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B6%94%EC%B8%A1%EC%84%B1-%EC%9D%BC%EB%B0%98%ED%99%94-speculative-generality&quot; aria-label=&quot;추측성 일반화 speculative generality permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;추측성 일반화 (Speculative Generality)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;미래에 어떤 기능이 필요할 것이라는 이유로 존재하는, 현재로썬 쓸모없는 코드가 풍기는 악취이다. 보통 이러한 코드가 존재하면 전체적인 코드의 가독성이 떨어지고 유지 보수도 힘들어진다. 만약 정말로 미래에 이 기능이 사용된다면 그나마 낫지만, 그렇지 않은 경우 오히려 장애물이 되기 때문에 이것들을 제거하는 것이 낫다.&lt;/li&gt;
&lt;li&gt;그렇게 많은 일을 하지 않는 추상 클래스의 경우엔 &lt;a href=&quot;&quot;&gt;Collapse Hierarchy&lt;/a&gt;를 사용하라. 불필요한 위임은 &lt;a href=&quot;&quot;&gt;Inline Function&lt;/a&gt;과 &lt;a href=&quot;&quot;&gt;Inline Class&lt;/a&gt;로 제거할 수 있다.&lt;/li&gt;
&lt;li&gt;사용하지 않는 (불필요한) 매개 변수들은 &lt;a href=&quot;&quot;&gt;Change Function Declaration&lt;/a&gt;을 적용하여 제거할 수 있다.&lt;/li&gt;
&lt;li&gt;어떤 함수, 혹은 클래스의 유일한 사용처가 테스트 케이스인 경우 코드에 추측성 일반화가 존재함을 알 수 있다. 이와 같은 상황에선 테스트 케이스를 제거하고 &lt;a href=&quot;&quot;&gt;Remove Dead Code&lt;/a&gt;를 적용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;임시-필드-temporary-field&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%84%EC%8B%9C-%ED%95%84%EB%93%9C-temporary-field&quot; aria-label=&quot;임시 필드 temporary field permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;임시 필드 (Temporary Field)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;특정한 상황일때만 필드 변수에 값이 세팅되는 클래스의 경우, 언뜻 보기엔 사용되지 않는 필드인것 처럼 보여질 수 있다. 이 때문에 코드의 가독성이 저하될 수 있으므로 &lt;a href=&quot;&quot;&gt;Extract Class&lt;/a&gt;를 이용해서 따로 분리하는 것을 권장한다.&lt;/li&gt;
&lt;li&gt;해당 필드를 참조하는 함수는 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 이용하여 분리된 클래스로 옮기는 것이 좋다.&lt;/li&gt;
&lt;li&gt;또, &lt;a href=&quot;&quot;&gt;Introduce Special Case&lt;/a&gt;를 이용하여 해당 필드와 관련된 조건문 로직을 제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;메시지-체인-message-chains&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%B2%B4%EC%9D%B8-message-chains&quot; aria-label=&quot;메시지 체인 message chains permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;메시지 체인 (Message Chains)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클라이언트가 어떤 객체를 얻기 위해 다른 객체에 물어보고, 그 다른 객체는 또 다른 객체에 물어보고, 또 다른 객체는 또 또 다른 객체에 물어보는것과 같이, 객체를 연속적으로 요청하여 발생하는 문제이다.&lt;/li&gt;
&lt;li&gt;이 경우 클라이언트가 객체의 navigation 구조에 종속됨으로 인해, 객체 사이의 관계가 변경되면 클라이언트 또한 변경되어야 하는 문제가 발생한다.&lt;/li&gt;
&lt;li&gt;이 경우 &lt;a href=&quot;&quot;&gt;Hide Delegate&lt;/a&gt;를 사용할 수 있다. navigation 체인의 어느 지점에나 이를 적용할 수 있지만, 체인의 중간에 존재하는 객체가 “중개자(middle man)“이 되어버릴 가능성이 있다.&lt;/li&gt;
&lt;li&gt;따라서 이 보다 좀 더 나은 해결책으로는, 최종 객체가 어떤 용도로 사용되는지를 파악하는 것이다. &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 통해 최종 객체를 사용하는 코드를 분리할 수 있는지 살펴보고, &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 통해 체인 안으로 밀어 넣을 수 있는지 살펴보라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;중개자-middle-man&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A4%91%EA%B0%9C%EC%9E%90-middle-man&quot; aria-label=&quot;중개자 middle man permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;중개자 (Middle Man)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;캡슐화는 객체의 주요 특징 중 하나로, 바깥세상으로 부터 세부적인 내용들을 감춘다. 캡슐화를 통해 어떤 작업을 다른 객체에 위임하고 그 세부적인 구현은 몰라도 된다.&lt;/li&gt;
&lt;li&gt;예를 들어 팀장에게 미팅을 요청하면 팀장은 자신의 일정을 확인한 뒤 답을 줄 것이다. 팀장이 일정을 확인할 때 종이로 된 다이어리를 쓰든, 스마트폰을 이용하든, 비서를 통해 확인하든 우리가 신경 쓸 일은 아니다.&lt;/li&gt;
&lt;li&gt;하지만 이것도 너무 지나치면 문제가 되는데, 클래스 내의 메서드 중 절반 이 다른 클래스에 위임을 하고 있는 경우 &lt;a href=&quot;&quot;&gt;Remove Middle Man&lt;/a&gt;을 사용하여 중개자를 제거하고 실제로 동작을 수행하고 있는 객체와 직접 소통하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;외부에 위임하는 메서드를 제거하고 남아있는 로직이 얼마 없다면 &lt;a href=&quot;&quot;&gt;Inline Function&lt;/a&gt;을 적용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;내부자-거래-insider-trading&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%B4%EB%B6%80%EC%9E%90-%EA%B1%B0%EB%9E%98-insider-trading&quot; aria-label=&quot;내부자 거래 insider trading permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;내부자 거래 (Insider Trading)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;개발자들은 모듈 사이에 두꺼운 벽을 세우는 것을 좋아하며, 모듈끼리 데이터를 너무 많이 주고받으면 결합도가 증가한다고 투덜댄다.&lt;/li&gt;
&lt;li&gt;물론 모듈 간의 상호작용을 아예 제거해버리는 것은 불가능하겠지만, 그 양을 최소한으로 줄이고 투명하게 처리해야 한다.&lt;/li&gt;
&lt;li&gt;은밀하게 데이터를 주고받는 모듈이 있다면 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;과 &lt;a href=&quot;&quot;&gt;Move Field&lt;/a&gt;를 통해 둘을 분리하는 것이 좋다. 만약 모듈들 간에 공통되는 부분이 있다면 그 부분을 따로 떼어내어 정식으로 처리하게 하거나, &lt;a href=&quot;&quot;&gt;Hide Delegate&lt;/a&gt;를 이용하여 다른 모듈을 만들어 중개자 역할을 하도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;상속 구조의 경우, 자식 클래스는 부모 클래스가 공개하는 범위를 넘어서 더 알려고 하는 경향이 있다. 부모의 품을 떠나 독립을 해야 할 때라면 &lt;a href=&quot;&quot;&gt;Replace Subclass with Delegate&lt;/a&gt; 혹은 &lt;a href=&quot;&quot;&gt;Replace Superclass with Delegate&lt;/a&gt;를 사용하자.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;큰-클래스-large-class&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-large-class&quot; aria-label=&quot;큰 클래스 large class permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;큰 클래스 (Large Class)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;한 클래스에서 너무 많은 일을 하려고 하면 그에 따라 필드도 너무 많이 생기게 되고, 그에 따라 중복된 코드가 생기기 쉽다.&lt;/li&gt;
&lt;li&gt;이럴 땐 &lt;a href=&quot;&quot;&gt;Extract Class&lt;/a&gt;를 사용하여 같은 컴포넌트에 모아두면 좋을 것 같은 변수들을 묶을 수 있다. 일반적으로, 클래스 내에서 동일한 접두·접미사를 사용하는 변수들을 같이 묶기 좋다.&lt;/li&gt;
&lt;li&gt;이렇게 분리한 클래스를 원래의 클래스와 상속 관계로 만드는 것이 좋을 것 같은 경우, &lt;a href=&quot;&quot;&gt;Extract Superclass&lt;/a&gt; 혹은 &lt;a href=&quot;&quot;&gt;Replace Type Code with Subclasses&lt;/a&gt;를 사용해 보라.&lt;/li&gt;
&lt;li&gt;클래스의 코드가 너무 많으면 중복이 생길 가능성이 높아진다. 결국, 클래스 내에서 자체적으로 중복을 없애는 것이 핵심이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;서로-다른-인터페이스의-대안-클래스들-alternative-classes-with-different-interfaces&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%9D%98-%EB%8C%80%EC%95%88-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%93%A4-alternative-classes-with-different-interfaces&quot; aria-label=&quot;서로 다른 인터페이스의 대안 클래스들 alternative classes with different interfaces permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;클래스의 커다란 장점 중 하나는 필요에 따라 언제는 다른 클래스로 교체할 수 있다는 점이다. 하지만 이는 클래스들 간의 인터페이스가 동일한 경우에만 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;Change Function Declaration&lt;/a&gt;을 사용하여 함수의 모양을 일치시킬 수 있다.&lt;/li&gt;
&lt;li&gt;이것만으로 부족한 경우, 인터페이스가 같아질 때까지 &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 사용하여 동작들을 클래스 내부로 집어넣어라.&lt;/li&gt;
&lt;li&gt;만약 이렇게 해서 중복이 생긴다면 &lt;a href=&quot;&quot;&gt;Extract Superclass&lt;/a&gt;를 사용하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;데이터-클래스-data-class&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-data-class&quot; aria-label=&quot;데이터 클래스 data class permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;데이터 클래스 (Data Class)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;필드와, getter, setter만 있는 클래스를 데이터 클래스라고 한다. 이러한 클래스들은 단순히 데이터 주머니 용도에 지나지 않으며, 다른 클래스가 너무 깊게 파고드는 경우가 많다.&lt;/li&gt;
&lt;li&gt;또한, 어떤 경우엔 public 필드를 가지고 있는 경우가 있는데, 이 경우 즉시 &lt;a href=&quot;&quot;&gt;Encapsulate Record&lt;/a&gt;를 통해 캡슐화를 해야 한다. 절대 변경되어선 안되는 필드의 경우 &lt;a href=&quot;&quot;&gt;Remove Setting Method&lt;/a&gt;를 이용하자.&lt;/li&gt;
&lt;li&gt;어떤 클래스에서 이 클래스의 getter, setter를 사용하는지 살펴보고, &lt;a href=&quot;&quot;&gt;Move Function&lt;/a&gt;을 이용하여 해당 메서드를 데이터 클래스 내부로 집어넣을 수 있는지 살펴보자. 메서드 전체를 옮길 수 없다면 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 사용해 보자.&lt;/li&gt;
&lt;li&gt;데이터 클래스는 필요한 동작이 엉뚱한 곳에 위치해 있다는 신호일 수 있다. 이 경우 클라이언트 코드를 데이터 클래스로 옮기기만 해도 코드를 대폭 개서할 수 있다.&lt;/li&gt;
&lt;li&gt;물론 예외도 있는데, 다른 함수를 호출하여 얻은 결과를 저장하는 레코드가 대표적인 예시이다. &lt;a href=&quot;&quot;&gt;Split Phase&lt;/a&gt;의 결과로 생긴 중간 데이터 구조가 이러한 레코드의 예시이다.&lt;/li&gt;
&lt;li&gt;이러한 레코드는 불변이므로 굳이 캡슐화할 필요가 없고, getter를 통하지 않고 필드 자체를 공개해도 딱히 상관없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;상속-거부-refused-bequest&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%81%EC%86%8D-%EA%B1%B0%EB%B6%80-refused-bequest&quot; aria-label=&quot;상속 거부 refused bequest permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;상속 거부 (Refused Bequest)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;자식 클래스는 부모 클래스로부터 메서드와 데이터를 상속받는다. 하지만 자식 클래스가 이러한 상속을 원하지 않는 경우는 어떨까?&lt;/li&gt;
&lt;li&gt;일반적으로, 이러한 경우는 부모와 자식 클래스 간의 계층 구조가 잘못되었다는 신호이다. 이 땐 새로운 (같은 부모로부터 상속받는) 형제 클래스를 만들고, &lt;a href=&quot;&quot;&gt;Push Down Method&lt;/a&gt;와 &lt;a href=&quot;&quot;&gt;Push Down Field&lt;/a&gt;를 사용하여 기존의 클래스에서 사용하지 않던 코드를 형제 클래스로 옮기는 것을 추천한다. 이렇게 하면 부모 클래스는 공통적인 것만 가지고 있게 된다.&lt;/li&gt;
&lt;li&gt;모든 부모 클래스는 추상 클래스이어야 한다는 조언을 들은 적이 있을 것이다. 하지만 항상 이 조언을 따르라고 권하고 싶지는 않다. 냄새가 나긴 나지만, 이 정도 냄새는 참을만하다.&lt;/li&gt;
&lt;li&gt;자식 클래스가 (부모로부터 받은) 동작을 재사용 하고 있지만 인터페이스는 따르고 싶어 하지 않는 경우 상속 거부의 악취가 훨씬 심해진다. 구현을 따르지 않는 것은 이해할 수 있지만, 인터페이스를 따르지 않는다는 것은 참을 수 없다.&lt;/li&gt;
&lt;li&gt;하지만 이 경우 클래스 간의 계층을 건드릴 필요는 없다. &lt;a href=&quot;&quot;&gt;Replace Subclass with Delegate&lt;/a&gt; 또는 &lt;a href=&quot;&quot;&gt;Replace Superclass with Delegate&lt;/a&gt;를 통해 이를 제거할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;주석-comments&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A3%BC%EC%84%9D-comments&quot; aria-label=&quot;주석 comments permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;주석 (Comments)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;물론, 걱정 마시라. 주석을 달면 안 된다고 하는 것이 아니다. 사실 주석은 악취가 아니라 향긋한 냄새이다. 좋은 냄새임에도 불구하고 여기에서 언급하는 이유는, 주석이 데오도란트의 용도로 사용되는 경우가 많기 때문이다.&lt;/li&gt;
&lt;li&gt;주석을 달 필요가 없는 코드를 작성하는 것이 우선이다. 리팩토링을 통해 냄새를 제거하고 나면, 주석은 더 이상 필요 없는 경우가 많다.&lt;/li&gt;
&lt;li&gt;정 주석을 통해 코드의 역할을 설명해야겠다고 한다면 &lt;a href=&quot;&quot;&gt;Extract Function&lt;/a&gt;을 시도해 보라. 추출했음에도 불구하고 주석이 필요하다면 &lt;a href=&quot;&quot;&gt;Change Function Declaration&lt;/a&gt;을 통해 이름을 바꿔보라. 시스템이 필요로 하는 특정 상태를 적어놔야 하는 경우 &lt;a href=&quot;&quot;&gt;Introduce Assertion&lt;/a&gt;을 사용해 보라.&lt;/li&gt;
&lt;li&gt;주석을 남겨야겠다는 생각이 들면 우선 주석이 필요 없는 코드로 리팩토링을 해보는 것을 추천한다.&lt;/li&gt;
&lt;li&gt;무엇을 해야 할지 모를 때 주석을 달면 좋다. 어떤 일이 일어나고 있는지를 설명하는 것과 더불어, 왜 그러한 코드를 짰는지 설명할 수 있다. 이러한 정보는 추후에 코드를 수정할 때 도움이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[이벤트 버블링과 캡처링]]></title><description><![CDATA[버블링과 캡처링 이벤트 버블링과 캡처링은 중첩된 HTML…]]></description><link>https://jaehyeon48.github.io/javascript/event-bubbling-and-capturing/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/event-bubbling-and-capturing/</guid><pubDate>Sat, 11 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;버블링과-캡처링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B2%84%EB%B8%94%EB%A7%81%EA%B3%BC-%EC%BA%A1%EC%B2%98%EB%A7%81&quot; aria-label=&quot;버블링과 캡처링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;버블링과 캡처링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 버블링과 캡처링은 중첩된 HTML 요소에서 이벤트가 발생했을 때 처리되는 단계들을 설명하는 용어이다.&lt;/li&gt;
&lt;li&gt;모든 자바스크립트 이벤트엔 버블링과 캡처링 단계가 존재한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;이벤트-버블링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81&quot; aria-label=&quot;이벤트 버블링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 버블링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 버블링이란, 어떤 요소에 대해 특정 이벤트가 발생했을 때 해당 이벤트가 상위 부모 요소들로 전달되는 특성을 의미한다. 즉, 우선 해당 요소의 (해당 이벤트에 대한) 이벤트 핸들러를 호출하고, 그다음으로 상위 요소(부모)의 이벤트 핸들러를 호출하고, 그다음 상위 요소의 이벤트를 호출하고, … 이런 식으로 동작하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/event-bubbling-and-capturing/event_bubbling.png&quot; alt=&quot;Event Bubbling&quot;&gt;
    &lt;figcaption&gt;출처: https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codepen.io/jaehyeon48/pen/WNOMQzj&quot;&gt;이벤트 버블링 예시&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;버블링-멈추기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B2%84%EB%B8%94%EB%A7%81-%EB%A9%88%EC%B6%94%EA%B8%B0&quot; aria-label=&quot;버블링 멈추기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;버블링 멈추기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 이벤트 버블링은 타겟 요소로 부터 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;html&gt;&lt;/code&gt; 요소를 거쳐 &lt;code class=&quot;language-text&quot;&gt;document&lt;/code&gt; 객체까지, 심지어 몇몇 이벤트들은 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt; 객체까지 전달된다.&lt;/li&gt;
&lt;li&gt;이 떄, 이벤트 핸들러는 &lt;code class=&quot;language-text&quot;&gt;event.stopPropagation()&lt;/code&gt;함수를 이용하여 버블링을 중단할 수 있다. &lt;a href=&quot;https://jsfiddle.net/jaehyeon48/xg5u1h9b/5/&quot;&gt;예제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;다만, &lt;code class=&quot;language-text&quot;&gt;event.stopPropagation()&lt;/code&gt;을 사용하더라도 특정 요소에 여러 개의 핸들러가 존재하는 경우, 해당 핸들러 들은 여전히 실행된다. 이것을 막기 위해선 &lt;code class=&quot;language-text&quot;&gt;event.stopImmediatePropagation()&lt;/code&gt;을 사용할 수 있다. &lt;a href=&quot;https://jsfiddle.net/jaehyeon48/8073fk5g/13/&quot;&gt;예제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;이벤트-캡처링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%BA%A1%EC%B2%98%EB%A7%81&quot; aria-label=&quot;이벤트 캡처링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 캡처링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 캡처링은 버블링과 반대 방향으로 일어나는 전파 방식으로, 실제 코드에서 잘 쓰이지는 않지만 때때로 유용하게 사용될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/event-bubbling-and-capturing/event_capturing.png&quot; alt=&quot;Event Capturing&quot;&gt;
    &lt;figcaption&gt;출처: https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;표준-dom-이벤트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%91%9C%EC%A4%80-dom-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot; aria-label=&quot;표준 dom 이벤트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;표준 DOM 이벤트&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/&quot;&gt;표준 DOM 이벤트 스펙&lt;/a&gt;에선 이벤트 흐름을 다음 3 단계로 정의하고 있다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;캡처링 단계&lt;/strong&gt;: 이벤트가 하위 요소로 전파되는 단계.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;타겟 단계&lt;/strong&gt;: 이벤트가 타겟 요소에 도달한 단계.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;버블링 단계&lt;/strong&gt;: 이벤트가 상위 요소로 버블링 되는 단계.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;아래 그림을 통해 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;table&gt;&lt;/code&gt; 안에 있는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;td&gt;&lt;/code&gt; 를 클릭하게 되면 어떤 일이 일어나는지 살펴보자:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/event-bubbling-and-capturing/event_dispatch.png&quot; alt=&quot;Event Dispatch&quot;&gt;
    &lt;figcaption&gt;출처: https://www.w3.org/TR/DOM-Level-3-Events/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;우선, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;td&gt;&lt;/code&gt; 를 클릭하게 되면 이벤트가 최상위 조상 요소부터 시작하여 아래로 전파되고(⟶ 캡처링 단계), 타겟 요소에 도달하여 발생시킨 후(⟶ 타겟 단계), 다시 위로 올라가면서(⟶ 버블링 단계) 각 요소들의 핸들러를 호출한다.&lt;/li&gt;
&lt;li&gt;이벤트 캡처링 단계를 포착하기 위해선 다음과 같이 리스너를 등록할 때 &lt;code class=&quot;language-text&quot;&gt;capture&lt;/code&gt; 인자를 추가적으로 전달해야 한다:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; listener&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; capture&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 혹은&lt;/span&gt;
element&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; listener&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;capture&lt;/code&gt; 옵션이 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt;인 경우, 핸들러는 버블링 단계에서 동작한다. 이 값이 default 이다 (즉, 기본적으로 핸들러는 버블링 단계에서 동작한다).&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;capture&lt;/code&gt; 옵션이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;인 경우, 핸들러는 캡처링 단계에서도 동작한다.&lt;/li&gt;
&lt;li&gt;공식적으로는 이벤트 흐름에 총 3단계가 있지만 2번째 단계인 타겟 단계는 따로 처리되지 않는다. 캡처링과 버블링 단계의 이벤트 핸들러가 trigger 되는 시점은 타겟 단계이다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jsfiddle.net/oz16g4mb/6/&quot;&gt;예시&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;target과-currenttarget&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#target%EA%B3%BC-currenttarget&quot; aria-label=&quot;target과 currenttarget permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;target과 currentTarget&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;이벤트 핸들러의 첫 번째 매개 변수인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;Event&lt;/a&gt; 객체의 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;currentTarget&lt;/code&gt; 속성을 통해, 부모 요소는 이벤트가 실제로 발생한 요소가 어디인지에 대한 정보를 얻을 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Event.target&lt;/code&gt;은 이벤트가 &lt;strong&gt;실제로 발생한&lt;/strong&gt; 요소를 가리킨다. 이벤트 버블링이 일어나더라도 &lt;code class=&quot;language-text&quot;&gt;Event.target&lt;/code&gt;이 가리키는 요소는 바뀌지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Event.currentTarget&lt;/code&gt;은 &lt;strong&gt;현재 실행중인 이벤트 핸들러가 처리하고 있는&lt;/strong&gt; 요소를 가리킨다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codepen.io/jaehyeon48/pen/rNwJLNG&quot;&gt;예제&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;이벤트-위임&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9C%84%EC%9E%84&quot; aria-label=&quot;이벤트 위임 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 위임&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;이벤트 위임을 한 문장으로 요약해보면 “하위 요소에 각각 이벤트를 붙이지 않고 상위 요소에서 하위 요소의 이벤트들을 제어하는 방식”입니다. - 캡틴 판교&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codepen.io/jaehyeon48/pen/OJxbwNa?editors=1010&quot;&gt;예제&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;위 예제에선 특정 &lt;code class=&quot;language-text&quot;&gt;tile&lt;/code&gt; 요소를 클릭하면 해당 요소의 바탕색을 변경하는 예시입니다. 이 때, 반복문을 활용하여 각각의 &lt;code class=&quot;language-text&quot;&gt;tile&lt;/code&gt; 요소마다 이벤트 핸들러를 등록하는 대신 이벤트 위임 기법을 활용하여 상위 요소인 &lt;code class=&quot;language-text&quot;&gt;container&lt;/code&gt; 요소에 이벤트 핸들러를 등록하고, 이벤트 핸들러 내에서 &lt;code class=&quot;language-text&quot;&gt;target&lt;/code&gt; 속성을 활용하여 바탕색을 변경하는 방식을 사용하고 있습니다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;이렇듯 이벤트 위임 패턴을 사용하면 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;동적인 엘리먼트에 대한 이벤트 처리가 수월하고,&lt;/li&gt;
&lt;li&gt;상위 엘리먼트에서만 이벤트 리스너를 관리하기 때문에 하위 엘리먼트는 자유롭게 추가 삭제할 수 있고,&lt;/li&gt;
&lt;li&gt;동일한 이벤트에 대해 한 곳에서 관리하기 때문에 각각의 엘리먼트를 여러 곳에 등록하여 관리하는 것보다 관리가 수월하고,&lt;/li&gt;
&lt;li&gt;많은 핸들러를 할당하지 않아도 되기 때문에 메모리 사용량이 줄어들고,&lt;/li&gt;
&lt;li&gt;등록 핸들러 자체가 줄어들기 때문에 메모리 누수 가능성도 줄어들게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://javascript.info/bubbling-and-capturing&quot;&gt;https://javascript.info/bubbling-and-capturing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&quot;&gt;https://joshua1988.github.io/web-development/javascript/event-propagation-delegation/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling_and_capture&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building&lt;em&gt;blocks/Events#event&lt;/em&gt;bubbling&lt;em&gt;and&lt;/em&gt;capture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ui.toast.com/weekly-pick/ko_20160826&quot;&gt;https://ui.toast.com/weekly-pick/ko_20160826&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리팩토링 2판 요약 정리 Ch.2]]></title><description><![CDATA[리팩토링 2판을 번역/요약한 글입니다. 리팩토링 정의하기 리팩토링 (명사): 소프트웨어의 겉보기 동작(observable behavior…]]></description><link>https://jaehyeon48.github.io/architecture/refactoring_summary_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/refactoring_summary_2/</guid><pubDate>Fri, 10 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599&quot;&gt;리팩토링 2판&lt;/a&gt;을 번역/요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;리팩토링-정의하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EC%A0%95%EC%9D%98%ED%95%98%EA%B8%B0&quot; aria-label=&quot;리팩토링 정의하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링 정의하기&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;리팩토링 (명사): 소프트웨어의 겉보기 동작(observable behavior)은 그대로 둔 채, 좀 더 이해하기 쉽고 변경에 유연하도록 하기 위해 소프트웨어의 내부 구조에 가해진 변화.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;리팩토링 (동사): 소프트웨어의 겉보기 동작은 그대로 둔 채, 리팩토링을 여러 번 적용하여 소프트웨어의 구조를 바꾸는 행위.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;오랜 시간 동안 현업 개발자들은 코드를 깔끔하게 정리하는 작업을 단순히 “리팩토링”이라고 불러왔지만, 위의 정의들은 코드를 깔끔하게 정리하는 &lt;em&gt;특정 방식&lt;/em&gt;에 초점을 맞추고 있다.&lt;/li&gt;
&lt;li&gt;리팩토링은 겉으로 보이는 동작은 유지한 채 내부 구조를 바꾸는 작은 단계들을 적용하고, 이러한 단계들을 연결하여 큰 변화를 만들어 내는 것에 관한 것이다.&lt;/li&gt;
&lt;li&gt;각각의 리팩토링은 그 자체로 꽤 작거나, 작은 단계들로 구성되어 있기 때문에 리팩토링이 (완전히) 완료되지 않았음에도 불구하고 언제든 중단할 수 있다.&lt;/li&gt;
&lt;li&gt;만약 누군가 “리팩토링 때문에 며칠 동안 코드가 망가진(broken) 상태였어요” 라고 한다면 당신은 그 사람이 하던 건 리팩토링이 아니었다고 확신할 수 있을 것이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;작은 단계&lt;/strong&gt;들은 서로 잘 결합되기 때문에 더 빨리 진행할 수 있게 해주고, 디버깅하는 데 시간을 쏟지 않게 해준다.&lt;/li&gt;
&lt;li&gt;내가 내린 정의에서 “겉보기 동작(observable behavior)“라는 말을 썼는데, 이 말은 리팩토링을 시작하기 전과 후에 (전반적으로) 코드가 하는 일이 동일해야 한다는 뜻이다. 물론, 코드의 성능 특성, 모듈의 인터페이스 같은 부분이 바뀔 수도 있으나 사용자가 신경 쓰는 부분은 바뀌어서는 안 된다.&lt;/li&gt;
&lt;li&gt;전반적인 동작은 그대로 둔 채 코드를 변경한다는 측면에서 리팩토링과 성능 개선은 매우 흡사하다. 이들의 차이라면, 리팩토링은 코드를 &lt;em&gt;이해하기 쉽고 변경에 유연&lt;/em&gt;하도록 바꾼다는 것이고 성능 개선은 오직 &lt;em&gt;성능&lt;/em&gt;에만 초점을 맞춘다는 점이다. 리팩토링을 하고 나면 성능이 좋아질 수도, 나빠질 수도 있다. 반대로, 성능 개선을 하고 나면 코드를 다루기 더 까다로워질 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;kent-beck의-the-two-hats-비유-&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#kent-beck%EC%9D%98-the-two-hats-%EB%B9%84%EC%9C%A0-&quot; aria-label=&quot;kent beck의 the two hats 비유  permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Kent Beck의 The Two Hats 비유 🎩🎩&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;🎩 기능을 추가할 때는 기존에 존재하는 코드를 (최대한) 수정하지 않고, 기능과 그에 맞는 테스트 케이스만 추가하여 테스트한다.&lt;/li&gt;
&lt;li&gt;🎩 리팩토링할 때는 기능과 테스트를 추가하지 않고 코드만 수정한다 (물론 이전에 실수로 빠뜨린 테스트 케이스가 있으면 추가하고, 리팩토링으로 인해 인터페이스 구조가 바뀌면 테스트 케이스를 수정한다).&lt;/li&gt;
&lt;li&gt;내가 개발할 땐 이 두 개의 모자를 자주 바꿔쓴다. 기능 추가용 모자를 쓰고 개발을 하다가, 코드를 🐶떡같이 썼다는 사실을 깨닫곤 리팩토링용 모자로 바꿔 쓴 다음 구조를 개선해나간다. 구조가 어느 정도 깔끔해졌다고 생각되면 다시 기능 추가용 모자로 바꿔 쓰고 기능 추가를 이어나간다.&lt;/li&gt;
&lt;li&gt;따라서, 내가 현재 어떤 모자를 쓰고 개발을 하고 있는지 자각할 필요가 있으며, 각 모자의 용도에 맞게 개발을 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;왜-리팩토링을-해야-하는가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;왜 리팩토링을 해야 하는가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;왜 리팩토링을 해야 하는가?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링은 만병통치약이 아니다. 하지만 좋은 도구임은 틀림없기에, 다음과 같은 이유로 인해 (웬만하면) 리팩토링을 하는 것이 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;리팩토링은-소프트웨어의-디자인을-개선한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%80-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4%EC%9D%98-%EB%94%94%EC%9E%90%EC%9D%B8%EC%9D%84-%EA%B0%9C%EC%84%A0%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;리팩토링은 소프트웨어의 디자인을 개선한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링은 소프트웨어의 디자인을 개선한다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링을 하지 않는다면 소프트웨어의 내부 설계, 즉 아키텍처가 부식(decay)된다. 단기적인 목표를 위해 아키텍처를 완전히 이해하지 않은 채 코드를 변경한다면 코드의 구조가 망가진다. 이렇게 코드의 구조가 망가지면 코드를 읽어서 그 구조를 파악하는 것이 더 어려워진다.&lt;/li&gt;
&lt;li&gt;코드의 구조를 파악하는 것이 어려워지면 그 코드를 유지 보수하는 것이 더 힘들어지고, 그로 인해 코드가 더 빨리 부식된다. 하지만 주기적인 리팩토링을 통해 이러한 일을 방지할 수 있다.&lt;/li&gt;
&lt;li&gt;잘못 설계된 코드는 군데군데 중복이 존재하기 때문에 같은 동작을 하더라도 더 많은 양의 코드로 구성된다. 따라서 코드 설계를 개선하는 중요한 측면 중 하나는 바로 중복을 제거하는 것이다.&lt;/li&gt;
&lt;li&gt;중복을 제거한다고 해서 코드가 더 빨라지거나 그러지는 않는다. 하지만 중복을 줄이게 되면 코드를 수정할 때 (훨씬) 쉽게 수정할 수 있게 된다. 코드가 많다는 것은 이해해야 할 코드가 더 많이 있다는 뜻이고, 그로 인해 코드를 제대로 수정하기 힘들어진다.&lt;/li&gt;
&lt;li&gt;코드에 중복이 있는 경우, 코드를 수정할 때 실수로 중복된 코드들 중 하나를 바꾸지 못하게 되면 버그가 발생하게 될 것이다. 중복을 제거하게 되면 수정할 때 (한 곳에서) 한 번만 바꾸면 된다. 중복이 없는 것, 이것이 좋은 설계의 본질이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;리팩토링은-코드를-더-이해하기-쉬운-형태로-만든다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%80-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8D%94-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%ED%98%95%ED%83%9C%EB%A1%9C-%EB%A7%8C%EB%93%A0%EB%8B%A4&quot; aria-label=&quot;리팩토링은 코드를 더 이해하기 쉬운 형태로 만든다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링은 코드를 더 이해하기 쉬운 형태로 만든다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(비록 우리가 종종 까먹곤 하지만) 컴퓨터 보다, 코드를 읽는 사람이 훨씬 중요하다. 코드를 컴파일할 때 몇 번의 사이클을 더 돌게 된다고 해서 누가 신경 쓰겠는가? 하지만 내가 짠 코드를 제대로 이해했다면 한 시간이면 걸릴 일을 일주일 동안 하게 된다면 이건 매우 큰 문제다.&lt;/li&gt;
&lt;li&gt;미래에 내 코드를 읽을 개발자를 위해서라도 리팩토링을 해서 코드를 더 읽기 쉽게 만들어야 한다. 미래의 개발자가 나 자신이 될 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;리팩토링은-버그를-발견하기-쉽게-해준다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%80-%EB%B2%84%EA%B7%B8%EB%A5%BC-%EB%B0%9C%EA%B2%AC%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%ED%95%B4%EC%A4%80%EB%8B%A4&quot; aria-label=&quot;리팩토링은 버그를 발견하기 쉽게 해준다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링은 버그를 발견하기 쉽게 해준다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(리팩토링을 통해) 코드를 이해하기 쉬워진다는 말은 버그를 찾기 쉬워진다는 말과 똑같다.&lt;/li&gt;
&lt;li&gt;리팩토링은 개발자로 하여금 탄탄한 코드를 더욱 효과적으로 작성할 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;리팩토링은-프로그램을-더욱-빨리-개발할-수-있게-해준다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%80-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%84-%EB%8D%94%EC%9A%B1-%EB%B9%A8%EB%A6%AC-%EA%B0%9C%EB%B0%9C%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B2%8C-%ED%95%B4%EC%A4%80%EB%8B%A4&quot; aria-label=&quot;리팩토링은 프로그램을 더욱 빨리 개발할 수 있게 해준다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링은 프로그램을 더욱 빨리 개발할 수 있게 해준다&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;결국 앞서 살펴본 사항들은 다음으로 귀결된다: “리팩토링은 더 빠르게 개발할 수 있도록 도와준다”&lt;/li&gt;
&lt;li&gt;리팩토링이 프로그램을 더욱 빨리 개발할 수 있게 한다는 말이 비직관적일 수 있다. 경력이 있는 개발자들과 이야기를 해보면, “처음에는 빠르게 개발할 수 있었지만 가면 갈수록 새로운 기능을 추가하는데 더 오랜 시간이 걸려요”와 같은 말을 종종 듣곤 한다. 새로운 기능을 어디에 어떻게 추가해야 할지 이해하는데 점점 더 많은 시간이 걸리고, 기능이 추가됐을 때 버그가 발생해서 디버깅하는 시간에 더 많은 시간을 쏟아붓는다고 한다. 때때로는 “차라리 갈아엎고 처음부터 만드는 게 나을 것 같아요”라는 말을 하곤 한다.&lt;/li&gt;
&lt;li&gt;반대로, 코드 퀄리티가 좋으면 새로운 기능을 어디에 어떻게 추가해야 하는지 쉽게 찾을 수 있게 해주고, 모듈화가 잘되어있으면 변경하기 위해 이해해야 할 (기존의) 코드의 양을 줄여준다. 코드가 명확하면 버그를 만들어낼 가능성이 작아지고, 버그를 만들어낸다고 해도 디버깅을 더욱더 쉽게 할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/refactoring/time_vs_cumulative_functionality_graph.png&quot; alt=&quot;시간에 따른 기능의 수 차이 그래프&quot;&gt;
    &lt;figcaption&gt;시간에 따라 기능의 수를 나타낸 그래프. 나쁜 설계의 경우 시간이 지남에 따라 점점 더 기능을 추가하기 어려워진다.&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;20여 년 전에 받아들여지던 정설은, 좋은 설계는 코딩하기 전에 완성되어야 한다는 것이었다. 하지만 리팩토링을 통해 시간이 지남에 따라 설계를 더 개선해나갈 수 있다. 사전에 좋은 설계를 한다는 것은 매우 어려운 일이므로, 리팩토링은 필수적인 요소가 되었다고 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;언제-리팩토링-해야-하는가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%96%B8%EC%A0%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;언제 리팩토링 해야 하는가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;언제 리팩토링 해야 하는가?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;무언가 비슷한 일을 3번 이상 하고 있다면, 리팩토링할 시간이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;예비-리팩토링-기능을-추가하기-쉽게-만들자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%98%88%EB%B9%84-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0-%EC%89%BD%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%9E%90&quot; aria-label=&quot;예비 리팩토링 기능을 추가하기 쉽게 만들자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;예비 리팩토링: 기능을 추가하기 쉽게 만들자&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링하기 가장 알맞을 때는 새로운 기능을 추가하기 직전이다. 기능을 추가하기 직전에, 기존 코드를 한번 살펴보고 구조를 살짝 바꾸면 작업하기 더 수월해진다.&lt;/li&gt;
&lt;li&gt;비유를 하자면, 동쪽으로 100km를 가야 할 때 곧장 동쪽으로 산을 타고 가는 것보다 20km 북쪽으로 간 다음 (차를 타고) 고속도로로 가는 것이 훨씬 빠르다. 사람들이 “그냥 바로 가!”라고 할 때, “잠깐만, 우선 지도를 보고 가장 빠른 길을 알아봐야겠어”라고 할 줄 알아야 한다. 예비 리팩토링도 이와 같은 이치이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;이해를-위한-리팩토링-더-이해하기-쉬운-코드로-만들자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%ED%95%B4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EB%8D%94-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-%EC%89%AC%EC%9A%B4-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%9E%90&quot; aria-label=&quot;이해를 위한 리팩토링 더 이해하기 쉬운 코드로 만들자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이해를 위한 리팩토링: 더 이해하기 쉬운 코드로 만들자&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드를 수정하기 전에, 우선 그 코드가 무엇을 하는지부터 이해해야 한다.&lt;/li&gt;
&lt;li&gt;리팩토링함으로써 내가 머릿속에서 이해한 것을 코드에 그대로 반영할 수 있다. 머릿속으로 이해한 것을 코드에 반영하게 되면 그 내용을 더욱더 오래 보존할 수 있고, 팀원들에게도 공유할 수 있다.&lt;/li&gt;
&lt;li&gt;코드를 분석할 때, 리팩토링은 나로 하여금 더 높은 차원의 이해를 가능케 한다.&lt;/li&gt;
&lt;li&gt;이해를 위해 리팩토링하는 것을 쓸모없는 것으로 치부하는 사람들은 자신들이 혼란 속에 숨겨진 기회를 보지 못한다는 것을 결코 깨닫지 못한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;쓰레기엉망인-코드-수거를-위한-리팩토링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%93%B0%EB%A0%88%EA%B8%B0%EC%97%89%EB%A7%9D%EC%9D%B8-%EC%BD%94%EB%93%9C-%EC%88%98%EA%B1%B0%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81&quot; aria-label=&quot;쓰레기엉망인 코드 수거를 위한 리팩토링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;쓰레기(엉망인 코드) 수거를 위한 리팩토링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드가 어떤 기능을 하는지 이해는 했지만, 로직이 쓸데없이 난해하다거나, 중복된 코드가 존재하는 등 코드가 그 기능을 잘 못할때(doing it badly) 리팩토링한다. 만약 현재 급하게 처리해야 할 일이 있는 경우 일단 메모해놓고 나중에 와서 리팩토링하고, 고치기 쉬운 일이라면 즉시 리팩토링한다.&lt;/li&gt;
&lt;li&gt;리팩토링의 좋은 점은, 리팩토링의 각 작은 단계마다 코드가 고장 나지 않는다는 점이다. 비록 이 때문에 리팩토링을 완료하는 데까지 몇 달이 걸릴 수도 있지만, 부분적으로 리팩토링을 한다고 해서 코드가 절대 고장 나지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;계획적이고-기회적인-리팩토링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B3%84%ED%9A%8D%EC%A0%81%EC%9D%B4%EA%B3%A0-%EA%B8%B0%ED%9A%8C%EC%A0%81%EC%9D%B8-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81&quot; aria-label=&quot;계획적이고 기회적인 리팩토링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;계획적이고 기회적인 리팩토링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;예비 리팩토링, 이해를 위한 리팩토링, 쓰레기 수거를 위한 리팩토링은 모두 기회가 될 때마다 하는 리팩토링이다. 즉, 따로 시간을 내어 이러한 리팩토링들을 하는 것이 아니란 소리다. 이러한 리팩토링들은 프로그래밍 흐름의 일부분이다.&lt;/li&gt;
&lt;li&gt;새 기능을 추가하거나 디버깅할 때, 리팩토링은 내가 현재 해야 할 일을 도와줄 뿐만 아니라 미래의 일을 더 쉽게 할 수 있도록 만들어준다.&lt;/li&gt;
&lt;li&gt;리팩토링은 프로그래밍과 별개의 활동이 아니다. 하지만 많은 사람들이 이 점을 놓치고 있다.&lt;/li&gt;
&lt;li&gt;리팩토링을 과거의 실수를 고치거나, 혹은 이상한 코드를 깔끔하게 하는 작업이라고 보는 잘못된 시각이 존재한다. 물론 이상한 코드를 보았을 때 리팩토링 해야 하는 건 맞지만, 훌륭한 코드도 꽤 많은 리팩토링을 해야 한다.&lt;/li&gt;
&lt;li&gt;좋은 개발자들은 때때로 새로운 기능을 가장 빠르게 추가하는 방법이 우선 추가하기 용이하도록 코드를 변경한 다음 기능을 추가하는 것임을 알고 있다.&lt;/li&gt;
&lt;li&gt;소프트웨어 개발을 “끝냈다”라고 생각해서는 안 된다. 새로운 요구사항이 추가되면 그에 맞춰 소프트웨어를 변경해야 하기 때문이다. 간혹 새로운 코드의 양보다 기존 코드에서 변경되는 양이 더 많을 수도 있다.&lt;/li&gt;
&lt;li&gt;계획적인 리팩토링이 항상 잘못된 것은 아니다. 하지만 그 빈도가 드물어야 한다. 리팩토링에 들이는 노력은 대부분 눈에 띄지 않고, 그때그때 하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;리팩토링 작업물과 새 기능 추가 작업물을 서로 다른 커밋으로 분리하라는 조언을 들은 적이 있다. 이렇게 했을 때의 가장 큰 이점은 리팩토링 커밋과 새 기능 추가 커밋을 따로 리뷰할 수 있기 때문이라고 한다.&lt;/li&gt;
&lt;li&gt;하지만 나는 이 의견에 별로 공감하지 않는다. 리팩토링과 새 기능 추가 작업은 서로 얽혀있는 경우가 대부분이기 때문이다. 리팩토링과 새 기능 추가 작업을 서로 분리하게 되면 리팩토링 작업을 정당화하기 힘들어질 수도 있다.&lt;/li&gt;
&lt;li&gt;이와 관련해서는 각자 팀 사정에 맞게 이를 적용하는 것이 바람직하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;변경을 하기 전에, 우선 변경이 쉽도록 만들어라 (주의: 어려울 수 있다!). 그리고 나서 쉽게 변경하라. - 켄트 백&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;장기적인-리팩토링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%A5%EA%B8%B0%EC%A0%81%EC%9D%B8-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81&quot; aria-label=&quot;장기적인 리팩토링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;장기적인 리팩토링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 리팩토링은 기껏해야 몇 시간 내로 끝낼 수 있다. 하지만 때때로 몇 주 혹은 그 이상 리팩토링을 해야 하는 경우가 있을 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 이러한 경우에 팀 전체가 몇 주 동안 리팩토링에만 매달려 있는 것은 좋지 않다고 생각한다. 그보단 점진적으로 조금씩 해결해나가는 것이 효과적일 때가 많다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;코드-리뷰에서의-리팩토링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C-%EB%A6%AC%EB%B7%B0%EC%97%90%EC%84%9C%EC%9D%98-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81&quot; aria-label=&quot;코드 리뷰에서의 리팩토링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드 리뷰에서의 리팩토링&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;코드 리뷰는 지식이 개발팀 전반에 퍼지도록 도와준다. 또한 시니어 개발자들의 지식을 주니어 개발자들에게 전수하도록 도와준다.&lt;/li&gt;
&lt;li&gt;코드리뷰는 깨끗한 코드를 작성하는 측면에서도 굉장히 중요하다. 내가 짠 코드가 나한텐 잘 읽힐지라도 다른 사람에겐 잘 읽힐지 아닐지 모르기 때문이다.&lt;/li&gt;
&lt;li&gt;또한 코드리뷰는 더 많은 사람들이 유용한 아이디어를 제시하도록 도와준다. 나 스스로는 기껏해야 일주일에 몇 개 정도의 유용한 아이디어를 떠올릴 수 있겠으나, 코드 리뷰를 통해 다른 사람이 (내 코드에 대한) 유용한 아이디어를 제시하도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 할 때 리팩토링을 활용하게 되면 제안을 제안으로 끝내지 않고 실체화 할 수 있다. 따라서 제안이 반영되었을 때의 코드를 상상하는 걸 넘어서, 리팩토링을 통해 실제로 제안을 반영해볼 수 있다.&lt;/li&gt;
&lt;li&gt;일반적으로 많이 하는 PR을 통한 코드 리뷰 방식엔 리팩토링이 잘 맞지 않는다고 생각한다. 왜냐면 (대부분) 리뷰어가 코드 작성자 없이 코드를 검토하기 때문이다.&lt;/li&gt;
&lt;li&gt;코드 리뷰를 할 땐 코드 작성자와 리뷰어가 함께 리뷰를 해야 작성자가 리뷰어에게 코드의 문맥을 설명해줄 수도 있고, 또한 리뷰어의 의도를 작성자에게 잘 전달할 수 있다 (일종의 페어 프로그래밍 방식과 흡사하다).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;매니저에게-말해야-하나&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%A4%EB%8B%88%EC%A0%80%EC%97%90%EA%B2%8C-%EB%A7%90%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98&quot; aria-label=&quot;매니저에게 말해야 하나 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;매니저에게 말해야 하나?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링을 단순히 디버깅 등으로 취급하고, 딱히 가치가 없는 일이라고 여기는 매니저가 있을 수 있다. 물론, 매니저들 (그리고 사용자들) 에게는 코드의 상태가 생산성에 어떠한 영향을 미치는지 모르는 경우가 많다.&lt;/li&gt;
&lt;li&gt;매니저가 리팩토링에 딱히 관심이 없는 경우, 매니저에게 &lt;strong&gt;말하지 마라!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;나는 이것이 반기를 드는 행위라고 생각하지 않는다. 개발자들은 &lt;strong&gt;프로&lt;/strong&gt;다. &lt;strong&gt;개발자들의 일은 효과적인 소프트웨어를 최대한 빨리 개발하는 것&lt;/strong&gt;이다. 그리고 내 경험에 의하면, 리팩토링을 통해 더욱 빠르게 개발을 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;언제-리팩토링을-하지-말아야-하는가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%96%B8%EC%A0%9C-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%84-%ED%95%98%EC%A7%80-%EB%A7%90%EC%95%84%EC%95%BC-%ED%95%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;언제 리팩토링을 하지 말아야 하는가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;언제 리팩토링을 하지 말아야 하는가?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;(코드가 엉망일지라도) 수정할 필요가 없는 코드의 경우, 굳이 리팩토링할 필요가 없다. 또한 아예 처음부터 다시 만들어야 하는 경우도 있을 수 있다. 물론 리팩토링을 하는 게 나은지, 아예 처음부터 다시 짜는 게 나은지 결정하는 게 쉽지는 않지만.&lt;/li&gt;
&lt;li&gt;직접 리팩토링해보기 전엔 (어떤 코드를 리팩토링하는 것이) 쉬운지 어려운지 판단하기 힘든 경우가 많다. 이는 뛰어난 판단력과 많은 경험이 뒷받침되어야 가능한 일이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;리팩토링과-관련된-문제들&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EA%B3%BC-%EA%B4%80%EB%A0%A8%EB%90%9C-%EB%AC%B8%EC%A0%9C%EB%93%A4&quot; aria-label=&quot;리팩토링과 관련된 문제들 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링과 관련된 문제들&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;세상에 무조건 좋기만 한 것들은 거의 찾아보기 힘들다. 리팩토링은 물론 훌륭한 도구이지만, 몇 가지 문제들이 존재하기 때문에, 이러한 문제들에 어떻게 대응할 수 있는지 이해하는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;새로운-기능-개발-속도-저하&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C-%EC%86%8D%EB%8F%84-%EC%A0%80%ED%95%98&quot; aria-label=&quot;새로운 기능 개발 속도 저하 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;새로운 기능 개발 속도 저하&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많은 사람들이 리팩토링에 들이는 시간으로 인해 개발 속도가 지연된다고 하지만, 리팩토링의 궁극적 목표는 개발 속도를 향상하는 것, 더 적은 노력으로 더 많은 가치를 만들어내는 것이다.&lt;/li&gt;
&lt;li&gt;여전히 현업에선 리팩토링을 많이 하지 않는다고 한다. 바꿔 말하자면, 개발자들은 리팩토링을 더 자주 할 필요가 있다.&lt;/li&gt;
&lt;li&gt;건강한 코드를 경험해 보지 않고서는 코드가 건강할 때와 아플 때의 생산성 차이를 말하기 힘들다. 코드가 건강하면 기존의 코드를 새로운 코드와 결합하여 복잡한 새로운 기능을 빨리 추가할 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;내가 생각하기에 사람들이 흔히 걸려드는 함정 중 가장 위험한 것은, 리팩토링을 “클린 코드”, “좋은 엔지니어링 습관” 등으로 정당화한다는 점이다. 리팩토링의 요점은 코드가 얼마나 빛이 나는지 보여주는 것이 아니다!&lt;/li&gt;
&lt;li&gt;리팩토링을 하는 이유는 순전히 경제적인 이유에서다. 기능을 더 빠르게 추가할 수 있고, 버그를 더 빠르게 잡아낼 수 있기 때문에 하는 것이다. 반드시 경제적인 이득이 리팩토링을 하는 주된 이유가 되어야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;코드-소유권&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C-%EC%86%8C%EC%9C%A0%EA%B6%8C&quot; aria-label=&quot;코드 소유권 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드 소유권&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링의 대부분은 단순히 내부 구조만 변경하는 것이 아니라, 다른 시스템과의 관계도 변경하는 경우가 많다.&lt;/li&gt;
&lt;li&gt;예를 들어 함수 이름을 변경하는 경우, 함수를 호출하는 부분을 전부 찾을 수 있으면 쉽게 리팩토링할 수 있지만 만약 호출하는 부분이 다른 팀의 코드에 있고 내가 그 팀의 저장소에 접근 권한이 없을 수도 있다.&lt;/li&gt;
&lt;li&gt;혹은, 그 함수가 API로 정의되어 고객들이 사용하고 있는 경우라면 그 함수가 누구에 의해서 얼마나 사용되는지조차 알 수 없다. 이렇게 인터페이스를 정의한 사람과 독립적인 고객에 의해 사용되는 인터페이스를 &lt;strong&gt;외부 공개 인터페이스(published interface)&lt;/strong&gt; 라고 한다.&lt;/li&gt;
&lt;li&gt;코드 소유권이 나뉘어 있으면 리팩토링에 방해가 된다. 물론 이러한 상황에서도 리팩토링을 할 수 있지만, 제약이 따른다.&lt;/li&gt;
&lt;li&gt;나는 코드 소유권을 작은 단위로 나눠 관리하는 것에 대해 반대하는 입장이다. 대신, 소유권을 “팀”에 두어 팀원 누구나 팀의 코드를 변경할 수 있는 권한을 두는 것을 선호한다.&lt;/li&gt;
&lt;li&gt;개발자마다 책임지는 영역이 있을 수 있지만, 이 말은 자신이 맡은 영역을 책임지고 관리해야 한다는 뜻이지 영역에 접근하는 것 자체를 막아선 안된다.&lt;/li&gt;
&lt;li&gt;이렇게 소유권을 느슨하게 정하는 방식은 여러 팀들 간에도 적용될 수 있다. 어떤 팀은 다른 팀의 개발자가 자기 팀의 브랜치에 있는 코드를 수정하고 커밋 요청을 날릴 수 있는 오픈 소스 비스무리한 방식을 사용하기도 한다.&lt;/li&gt;
&lt;li&gt;이러한 방식은 (접근을 최대한 차단하는) 강력한 소유권 방식과 완전히 풀어서 변경을 통제하기 힘든 방식의 절충안이 될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;브랜치&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%8C%EB%9E%9C%EC%B9%98&quot; aria-label=&quot;브랜치 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;브랜치&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;일반적으로 많은 팀들이 VCS를 이용하여 각 팀원마다 브랜치를 하나씩 파서 작업을 하다가, 작업을 끝내면 메인 브랜치에 결과물을 합쳐서 팀원과 공유하는 방식을 사용한다. 주로 프로덕션 버전으로 배포할 때 메인 브랜치에 합치는 편이다.&lt;/li&gt;
&lt;li&gt;이 방식을 선호하는 사람들은 이렇게 하면 메인 브랜치와 기능 추가 이력을 깔끔하게 관리할 수 있다는 점, 그리고 무언가 잘못되었을 때 이전으로 되돌아가기 수월하다는 주장을 한다.&lt;/li&gt;
&lt;li&gt;하지만 개별 브랜치에서 너무 (오랫동안) 많은 작업을 하다 보면 나중에 메인 브랜치에 합치는 것이 힘들어질 수 있다. 따라서 대부분의 사람들은 메인 브랜치에 자주 합치거나, 개별 브랜치를 메인 브랜치에 대해 자주 리베이스 하는 방법을 사용한다. 하지만 많은 사람들이 각자의 브랜치에서 작업하는 경우 이 방식은 궁극적인 해결책이 되지 못한다.&lt;/li&gt;
&lt;li&gt;나는 merge와 통합(integrate)을 구분하는 편이다. 개별 브랜치를 마스터 브랜치도 “merge” 하는 것은 단방향 작업이다. 개별 브랜치만 바뀌고 마스터 브랜치는 그대로다. 반면, “통합”은 메인 브랜치의 변화를 개별 브랜치로 가져온 다음 다시 메인 브랜치에 올리는 양방향 작업이다.&lt;/li&gt;
&lt;li&gt;누군가 개별 브랜치에서 작업한 내용은 메인 브랜치에 통합하기 전엔 다른 사람이 알 수 없다. 그리고 메인 브랜치에 통합하고 나면 그 결과를 내 브랜치에 merge 해야 하는데 이는 상당한 노력이 들 수 있다.&lt;/li&gt;
&lt;li&gt;특히 어려운 부분은 코드의 의미적인(semantic) 변화를 다루는 것이다. 현대 VCS들은 텍스트 변화를 merge 하는 데엔 탁월하지만 코드의 의미를 알지는 못한다.&lt;/li&gt;
&lt;li&gt;(크고 방대한) 복잡한 브랜치를 merge 하는 것은 상당히 까다롭기 때문에, 많은 사람들은 최대한 브랜치를 작게 유지하는 것을 선호한다. 예를 들면 이틀에 한 번씩 메인 브랜치에 합치는 것과 같이 말이다. 하지만 나와 같이 또 다른 몇몇 개발자들은 그보다 더 작게 유지하는 것을 선호한다.&lt;/li&gt;
&lt;li&gt;이를 CI(Continuous Integration) 혹은 Trunk-Based Development라고 부른다. CI 방법을 사용하면 각 팀원들은 적어도 하루에 한 번씩 메인 브랜치에 합친다. 이렇게 하면 각 브랜치들이 서로 너무 갈라지는(diverge) 경향을 방지할 수 있어서 merge를 좀 더 쉽게 할 수 있도록 한다.&lt;/li&gt;
&lt;li&gt;CI를 적용하기 위해선 메인 브랜치를 건강하게 관리하고, 큰 기능을 세분화하고, 개발 중인 작업을 토글 할 수 있는 스위치(혹은 feature flag)와 같은 것을 이용하여 코드가 망가지지 않도록 하는 방법을 연습해야 한다.&lt;/li&gt;
&lt;li&gt;CI는 리팩토링과 잘 어울린다. 리팩토링은 종종 코드에 많은 (작은) 변화들을 유발하는데, 이 때문에 (널리 사용되는 함수 이름을 변경하는 등의 이유로) 특히 (semantic한) merge conflict에 취약하다. 이와 같은 문제로 인해 feature branch 전략을 사용하는 팀들이 리팩토링을 중단하는 경우를 심심찮게 볼 수 있다.&lt;/li&gt;
&lt;li&gt;물론 feature branch 전략을 사용하지 말라는 소리는 아니다. 오픈소스 프로젝트의 경우 이 전략이 잘 맞을 수 있다. 하지만 (회사의) 개발팀에선 방대해진 각각의 feature branch로 인해 리팩토링이 힘들어질 수 있다. 이 때문에 가능한 한 최대한 자주 (main 브랜치 등으로) 각 브랜치들을 통합하는 것을 권장한다.&lt;/li&gt;
&lt;li&gt;완전한 CI 방법을 사용하지 않더라도, 최대한 자주 통합하는 것을 권장한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;테스팅&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%85%8C%EC%8A%A4%ED%8C%85&quot; aria-label=&quot;테스팅 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;테스팅&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링의 주요 특성 중 하나는 겉보기 동작을 바꾸지 않는다는 점이다. 리팩토링을 “잘”한다면 어떠한 것도 고장 나지 않아야 한다.&lt;/li&gt;
&lt;li&gt;사람이기에 실수할 수 있는 법이다. 하지만 실수를 빠르게 캐치한다면 걱정할 것 없다. 각 리팩토링 단계에서 일어나는 변화들은 작기 때문에 잘못된 부분을 빠르게 찾아낼 수 있고, 혹여 찾아내지 못한다고 해도 VCS를 통해 이전 버전으로 되돌릴 수 있다.&lt;/li&gt;
&lt;li&gt;여기서 핵심은 에러를 빨리 찾아내는 것이다. 이렇게 하기 위해선 코드에 대한 종합적인 테스트 코드를 가지고 있어야 하며, 이것들을 빠르게 돌릴 수 있어야 한다. 다시 말해, 리팩토링을 할 때 자가 테스트 코드가 있어야 한다는 말이다.&lt;/li&gt;
&lt;li&gt;자가 테스트 코드는 버그를 빠르게 찾아내서 제거할 수 있기 때문에 리팩토링뿐만 아니라 새 기능을 추가하는 데에도 큰 도움이 된다.&lt;/li&gt;
&lt;li&gt;자가 테스트 코드는 CI와도 연관되어 있으며, XP의 구성요소 중 일부로서 CD의 핵심 부분 중 하나이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;레거시-코드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A0%88%EA%B1%B0%EC%8B%9C-%EC%BD%94%EB%93%9C&quot; aria-label=&quot;레거시 코드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;레거시 코드&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링은 레거시 시스템을 이해하는데 큰 도움을 준다. 올바르지 않은 함수 이름을 고치고, 어설픈 구문을 매끄럽게 다듬어 원석같던 프로그램을 보석으로 바꿀 수 있다.&lt;/li&gt;
&lt;li&gt;하지만 테스트 없이는 거대한 레거시 시스템을 “안전하게” 리팩토링할 수 없다. 이에 대한 해답은 (당연하게도) 테스트를 추가하는 것이다.&lt;/li&gt;
&lt;li&gt;물론 말로는 간단해 보이지만 실제로는 까다롭다. 일반적으로, 테스트를 염두에 두고 설계한 시스템일 경우에만 테스트하기 쉽다. 보통 이 경우 테스트 코드가 있기 마련이라서, 따로 신경 쓸 건 없다.&lt;/li&gt;
&lt;li&gt;쉽게 해결할 수 있는법은 없다. 그나마 해줄 수 있는 조언은&lt;a href=&quot;https://www.amazon.com/Working-Effectively-Legacy-Code-EFFECT-ebook/dp/B005OYHF0A&quot;&gt; Working Effectively with Legacy Code&lt;/a&gt;에 나온 지침을 따르라는 것이다. 이 책을 대강 요약해보자면, 테스트를 추가할 수 있는 틈새를 찾아서 테스트를 해보라는 것이다.&lt;/li&gt;
&lt;li&gt;(테스트가 없는) 레거시를 리팩토링하는 작업은 힘들고 어려운 작업이다. 이 문제를 쉽게 해결할 수 있는 방법은 아쉽게도 없다. 이것이 자가 테스트 코드를 시작부터 추가해야 한다고 내가 그토록 강조하는 이유이다.&lt;/li&gt;
&lt;li&gt;만약 레거시 코드를 테스트할 수 있다고 해도 한꺼번에 고치려고 하지 않는 걸 추천한다. 서로 연관된 부분들을 찾아 조금씩 공략해 나가는 것을 추천한다. 레거시 시스템의 크기가 크다면 자주 보는 코드를 더 많이 리팩토링하라.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;리팩토링-아키텍처-그리고-yagni&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-yagni&quot; aria-label=&quot;리팩토링 아키텍처 그리고 yagni permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링, 아키텍처, 그리고 YAGNI&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링은 사람들의 소프트웨어 아키텍처에 관한 인식을 크게 바꿔놓았다.&lt;/li&gt;
&lt;li&gt;커리어 초반에 나는 코딩을 하기 전에 설계를 (거의) 끝마쳐야 한다고 배웠다. 코드를 작성하기 시작하면 아키텍처는 확정된 채 개발자들의 부주의함으로 인해 부식되어갈 뿐이었다. 리팩토링은 이러한 관점을 바꿔주었다. 몇 년 동안 서비스되던 프로그램의 아키텍처를 상당히 바꾸는 것도 가능하게 해주었다.&lt;/li&gt;
&lt;li&gt;리팩토링은 변화하는 요구에 빠르게 대응할 수 있는 아키텍처를 설계하는 데에 큰 영향을 미친다.&lt;/li&gt;
&lt;li&gt;코딩 전에 아키텍처를 확정하는 게 왜 문제가 되냐면, 이러한 방법은 사용자의 요구사항을 초기에 (잘) 알 수 있다고 가정하기 때문이다. 하지만 경험에 의하면 이는 일반적으로 (사실상) 불가능하다. 사용자는 실제로 소프트웨어를 사용해 보고, 업무에 미치는 영향을 직접 확인하고 나서야 정말 그들이 원하는 바를 알게 되는 경우가 허다하다.&lt;/li&gt;
&lt;li&gt;미래의 변화에 대응하는 방법 중 하나는, 소프트웨어에 유연한 메커니즘을 적용하는 것이다. 예를 들어 함수를 만들 때 범용적으로 사용할 수 있겠다고 생각할 수 있다. 그래서 추후 일어날 수도 있는 다양한 상황에 대비한 매개변수들을 구성한다. 이러한 매개변수들이 유연한 메커니즘이다.&lt;/li&gt;
&lt;li&gt;하지만 대부분의 메커니즘들이 그렇듯이, 항상 좋기만 한 것은 없다. 이러한 매개변수들을 당장 적용하게 되면 현재 함수의 역할에 비해 구조가 너무 복잡해진다.&lt;/li&gt;
&lt;li&gt;변화가 내가 예상했던 것과는 다른 방향으로 발생할 수도 있고, 메커니즘 설계가 잘못될 수도 있다. 여러 가지를 종합적으로 고려해 보았을 때, 대부분의 경우 유연한 메커니즘으로 인해 오히려 변화에 제대로 대응하지 못하게 되는 경우가 많다.&lt;/li&gt;
&lt;li&gt;리팩토링과 함께라면 다른 전략을 사용할 수 있다. 미래에 일어날 일을 추측하기 보다, 우선 현재까지 이해한 요구사항만을 해결하는 소프트웨어를 구성하고 그 요구사항을 잘 해결하도록 설계한다.&lt;/li&gt;
&lt;li&gt;이후 사용자의 요구사항을 더 잘 알게 되면 리팩토링을 활용하여 아키텍처를 그에 맞게 변경하면 된다. 이 과정에서 함수의 이름같이 소프트웨어의 복잡도를 증가시키지 않는 메커니즘은 얼마든지 추가할 수 있지만, 복잡도를 증가시킬 수 있는 메커니즘은 반드시 추가하기 전에 검증을 거쳐야 한다.&lt;/li&gt;
&lt;li&gt;이러한 접근법을 흔히 단순 설계법, 점진적 설계법, 혹은 YAGNI(You Aren’t Gonna Need It)라고 부른다.&lt;/li&gt;
&lt;li&gt;YAGNI 방법을 적용한다고 해서 사전에 아키텍처를 생각하지 말라는 뜻이 아니다. 여전히 리팩토링을 적용하기 어려운 부분이 있을 수 있고, 사전에 생각을 해놓는 것이 시간을 절약하는 경우도 있다.&lt;/li&gt;
&lt;li&gt;다만 이 둘(미리 생각하느냐, 그때 가서 생각하느냐) 사이의 균형이 많이 바뀌었다. 나는 개인적으로 나중에 문제를 더 깊이 이해할 수 있게 되었을 때 처리하는 쪽을 선호한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;리팩토링과-소프트웨어-개발-프로세스&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EA%B3%BC-%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B0%9C%EB%B0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4&quot; aria-label=&quot;리팩토링과 소프트웨어 개발 프로세스 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링과 소프트웨어 개발 프로세스&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리팩토링의 효과는 팀이 사용하고 있는 개발 방법에 따라 달라질 수 있다.&lt;/li&gt;
&lt;li&gt;리팩토링이 사용되기 시작한 것도, CI·자가 테스트 코드·리팩토링과 같이 상대적으로 개성이 강하고 상호의존적인 방법들로 구성된 XP가 도입되면서부터이다.&lt;/li&gt;
&lt;li&gt;애자일 방법론을 쓰는 프로젝트들 대부분은 단순히 “애자일” 이라는 이름만 가져다 쓴다. 실제로 애자일한 방식으로 개발하기 위해선 리팩토링에 대한 팀 구성원 모두의 역량과 의지가 뒷받침되어야 하고, 그러기 위해선 개발 프로세스에 리팩토링이 스며들어야 한다.&lt;/li&gt;
&lt;li&gt;팀에서 개발하면서 리팩토링하려면 다른 팀원들을 방해하지 않으면서 언제든지 리팩토링할 수 있어야 한다. 이것이 내가 CI를 강조하는 이유이다. CI를 하게 되면 각 팀원의 리팩토링 결과를 다른 팀원과 빠르게 공유할 수 있다.&lt;/li&gt;
&lt;li&gt;자가 테스트 코드도 CI의 중요한 요소 중 하나이다. 따라서 CI·자가 테스트 코드·리팩토링 사이에는 강력한 시너지가 존재한다.&lt;/li&gt;
&lt;li&gt;이러한 세 방법을 적용한다면 YAGNI 설계를 적용할 수 있다. 미래의 (사용될지 안될지도 모르는) 기능을 대비해 작성한 코드보다 간단한 시스템을 수정하는게 더 쉽다.&lt;/li&gt;
&lt;li&gt;또, 이러한 핵심 방법들을 적용하면 애자일 방법론이 주는 또 다른 이점을 누릴 수 있다. CD는 소프트웨어를 항상 릴리즈할 수 있는 상태를 유지해준다. 기술적인 강점이 있는 회사의 경우 아이디어를 production 코드로 변환하는 데 걸리는 시간을 획기적으로 단축시켜 고객에게 더 나은 UX를 제공할 수 있다.&lt;/li&gt;
&lt;li&gt;물론 말로는 쉬운 것 같지만 실제론 어렵다. 소프트웨어 개발은 사람과 컴퓨터간의 복잡한 상호작용이 수반된 까다로운 일이기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;리팩토링과-성능&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EA%B3%BC-%EC%84%B1%EB%8A%A5&quot; aria-label=&quot;리팩토링과 성능 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리팩토링과 성능&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;흔히 리팩토링이 성능에 영향을 끼칠까 걱정을 하곤 한다. 나는 개인적으로 소프트웨어의 가독성을 증대하기 위해 프로그램이 더 느려질 수도 있는 방법들을 사용하곤 한다.&lt;/li&gt;
&lt;li&gt;분명 리팩토링으로 인해 프로그램의 성능이 더 안 좋아질 수도 있다. 하지만 그와 동시에 성능 개선에 용이하도록 구조를 변경한다. 리얼타임 시스템을 제외하고, 소프트웨어를 빠르게 만드는 비법은 우선 튜닝 가능한 소프트웨어를 만든 다음 충분한 속도가 나올 때까지 소프트웨어를 튜닝하는 것이다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;내가 경험한 빠른 소프트웨어를 작성하는 세 가지 방법은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;시간 분배 방법&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;가장 엄격한 방법으로, 흔히 리얼 타임 시스템에 사용된다.&lt;/li&gt;
&lt;li&gt;설계를 여러 컴포넌트로 분할하여 각 컴포넌트마다 자원을 할당하고, 할당된 자원을 초과하지 못하도록 한다. 자원을 주고받는 메커니즘은 허용될 수 있다.&lt;/li&gt;
&lt;li&gt;시간 엄수에 초점을 맞추며, 인공 심장 박동기(heart pacemaker)와 같은 시스템을 만들 때 사용된다.&lt;/li&gt;
&lt;li&gt;기업 정보 시스템등에는 어울리지 않는 방식이다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;끊임없이 주의를 기울이는 방법&lt;/strong&gt;:&lt;/li&gt;
&lt;li&gt;성능을 높이 끌어올릴 수 있다면 무엇이는 한다.&lt;/li&gt;
&lt;li&gt;직관적이어서 흔히 사용되지만 잘 안된다.&lt;/li&gt;
&lt;li&gt;성능 개선을 위해 코드를 변경하게 되면 대부분 이해하기 어려운 코드가 된다. 이로 인해 전체적인 개발 속도가 더뎌진다.&lt;/li&gt;
&lt;li&gt;프로그램 동작 방식에 대한 편협한 시각과 컴파일러, 하드웨어 등의 동작원리에 대한 잘못된 이해가 곁들여진 성능을 개선하기 위한 방법들이 프로그램 여기저기에 존재하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;프로그램의 성능에 관한 흥미로운 사실은, 극히 일부 코드에서 대부분의 시간이 소비된다는 점이다. 만약 모든 코드를 균등하게 최적화 하였다면 그 중 90%는 사실상 효과가 없기에 시간낭비한 것이나 다름없다.&lt;/li&gt;
&lt;li&gt;마지막 세 번째 방법은 바로 이 90% 통계에 기반한 것이다. 이 방법은 성능은 추후에 따로 짬을 내어 개선할 때까지 신경쓰지 않으면서 잘 정돈된(well-factored) 코드를 개발하는 방식이다. 이후 성능 개선작업을 할 때 특정 절차를 따라 프로그램을 튜닝한다.&lt;/li&gt;
&lt;li&gt;성능 개선작업을 할 땐, 우선 프로파일러를 통해 어디서 병목이 걸리는지 살펴보고 이후 병목이 발생하는 부분을 집중적으로 개선한다.&lt;/li&gt;
&lt;li&gt;이 방식을 프로그램의 전체적인 성능이 사용자가 만족할 만한 수준으로 나올 때까지 수행한다. 이렇게 하면 효율적으로 성능 개선을 할 수 있다.&lt;/li&gt;
&lt;li&gt;리팩토링을 통해 더 빠르게 개발할 수 있음을 확인했다. 짧게 보자면 리팩토링으로 인해 시간이 다소 소모되겠지만, 결국에 전체로 보면 더욱 빠르게 개발할 수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;(성능 개선을 할 때) 만약 전반적인 시스템을 아주 잘 알고 있다고 하더라도 성능을 ⭐측정⭐하라. 절대 추측하지 마라. 열에 아홉은 틀릴것이다. - 론 제프리스&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;나만의-세줄-요약&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%98%EB%A7%8C%EC%9D%98-%EC%84%B8%EC%A4%84-%EC%9A%94%EC%95%BD&quot; aria-label=&quot;나만의 세줄 요약 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나만의 세줄 요약&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;처음부터 클린한 코드를 짜는 것은 결코 쉽지 않다. 리팩토링을 적극 활용하자.&lt;/li&gt;
&lt;li&gt;(다시 한번 강조) 테스트는 선택이 아닌 필수!&lt;/li&gt;
&lt;li&gt;리팩토링은 기능을 추가하기 쉽게 해주고, 버그를 빨리 찾아낼 수 있게 해주며, 성능을 더 쉽게 개선할 수 있도록 해준다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[프로그래밍 초식 요약 - 나누기]]></title><description><![CDATA[…]]></description><link>https://jaehyeon48.github.io/architecture/programming101-2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/programming101-2/</guid><pubDate>Wed, 08 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://www.youtube.com/watch?v=kRdML08R2Yo&amp;#x26;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&quot;&gt;최범균님의 프로그래밍 초식 시리즈&lt;/a&gt;을 요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;초짜에서-중수가-되려면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B4%88%EC%A7%9C%EC%97%90%EC%84%9C-%EC%A4%91%EC%88%98%EA%B0%80-%EB%90%98%EB%A0%A4%EB%A9%B4&quot; aria-label=&quot;초짜에서 중수가 되려면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;초짜에서 중수가 되려면..?&lt;/h2&gt;
&lt;p&gt;소프트웨어를 만들려면 언어, 프레임워크, 라이브러리 등 구현 기술, 도구를 (당연히) 익혀야 한다. 하지만 구현 기술 조금 익혔다고 해서 중수 혹은 고수가 되는 것은 아니다. 구현 기술은 단지 여러 기본기 중 하나에 불과하다.&lt;/p&gt;
&lt;p&gt;실제로 중수 혹은 고수가 되기 위해선 많은 것을 익혀야 하는데, 여기서는 그중 하나인 “나누기”에 대해서 살펴보자.&lt;/p&gt;
&lt;h2 id=&quot;초짜-특&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B4%88%EC%A7%9C-%ED%8A%B9&quot; aria-label=&quot;초짜 특 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;초짜 특&lt;/h2&gt;
&lt;p&gt;프로그래밍 초보들이 만드는 코드의 특징 중 하나는 시간이 지날수록 함수/메서드/클래스 등이 점점 비대해진다는 점이다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/programming101/newbie.png&quot; alt=&quot;프로그래밍 뉴비 특징&quot;&gt;
    &lt;figcaption&gt;https://www.youtube.com/watch?v=NaeXpswLvxk&amp;amp;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&amp;amp;index=2&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;하지만 이런식으로 함수/메서드/클래스가 너무 커지게 되면 프로그램 분석이 어려워지기 시작한다. 즉, 추후에 코드를 수정하고 리팩토링하기 힘들어진다는 뜻이다. 흔한 예로는 다음이 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 내에서 &lt;code class=&quot;language-text&quot;&gt;if-else&lt;/code&gt;문 혹은 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문의 중첩이 (복잡하게) 많아진다.&lt;/li&gt;
&lt;li&gt;변수의 의미가 중간에 바뀐다.&lt;/li&gt;
&lt;li&gt;한 함수 내에서 중복이 발생하는 경우가 생긴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;필요한-기술-나누기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%84%EC%9A%94%ED%95%9C-%EA%B8%B0%EC%88%A0-%EB%82%98%EB%88%84%EA%B8%B0&quot; aria-label=&quot;필요한 기술 나누기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;필요한 기술: 나누기&lt;/h2&gt;
&lt;p&gt;최소한 프로그래밍 중급자 이상으로 가기 위해 필요한 기술 중 하나가 바로 코드를 의미가 있는 단위로 나누는 기술이다.&lt;/p&gt;
&lt;p&gt;나눈다는 것은 곧 기능을 분해하고, 분리한다는 의미이다. 일반적으로, 어떤 하나의 기능은 여러개의 더 작은 하위 기능으로 구성된다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/programming101/divide_logic.png&quot; alt=&quot;기능 나누기&quot;&gt;
    &lt;figcaption&gt;기능 나누기&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이렇게 나눠진 기능들은 별도의 메서드나 클래스로 분리되어 각각 알맞게 흩어지게 된다.&lt;/p&gt;
&lt;p&gt;로직을 나눈다는 것은 결국 역할 혹은 책임을 도출하는 것이다. 함수 혹은 클래스 등을 분리한다는 것은 역할 혹은 책임에 따라 구성요소를 도출하는 과정에 가깝다.&lt;/p&gt;
&lt;h2 id=&quot;그럼-어떻게-나눌까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%9F%BC-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%82%98%EB%88%8C%EA%B9%8C&quot; aria-label=&quot;그럼 어떻게 나눌까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그럼 어떻게 나눌까?&lt;/h2&gt;
&lt;p&gt;사실 &lt;strong&gt;“어떤 기준으로 나눠야 하나?”&lt;/strong&gt; 에 대한 정답은 없다 (참 어려운 문제다..!). 하지만 일반적으로, 기능에서 &lt;strong&gt;의미 있는 하위 기능 단위&lt;/strong&gt;로 나누는 시도를 했을 때 결과가 좋았던 것 같다.&lt;/p&gt;
&lt;h2 id=&quot;나누기-결과&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%98%EB%88%84%EA%B8%B0-%EA%B2%B0%EA%B3%BC&quot; aria-label=&quot;나누기 결과 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나누기 결과&lt;/h2&gt;
&lt;h3 id=&quot;나누기를-안하게-되면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%98%EB%88%84%EA%B8%B0%EB%A5%BC-%EC%95%88%ED%95%98%EA%B2%8C-%EB%90%98%EB%A9%B4&quot; aria-label=&quot;나누기를 안하게 되면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나누기를 안하게 되면&lt;/h3&gt;
&lt;p&gt;나누기를 안 하게 되면 (일반적으로) 하나의 함수 내에 봐야 할 코드가 존재하므로 코드의 순서대로 구현을 이해하는 것이 가능하다. 즉, 코드에 표시된 게 거의 실행 순서와 일치하므로 코드의 순서를 따라가면서 구현을 이해하는 것이 가능하다.&lt;/p&gt;
&lt;p&gt;하지만 코드의 양이 많아질수록 복잡해져서 점점 이해하기 어려워진다. 사람의 머리로 한 번에 이해할 수 있는 범위는 한정되어 있으니까…&lt;/p&gt;
&lt;p&gt;또한 내부적으로 복잡해지다 보니 코드를 변경하는 것도 어려워진다.&lt;/p&gt;
&lt;h3 id=&quot;너무-잘게-나누게-되면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%84%88%EB%AC%B4-%EC%9E%98%EA%B2%8C-%EB%82%98%EB%88%84%EA%B2%8C-%EB%90%98%EB%A9%B4&quot; aria-label=&quot;너무 잘게 나누게 되면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;너무 잘게 나누게 되면&lt;/h3&gt;
&lt;p&gt;반대로, 너무 잘게 나누게 되면 오히려 구조적으로 복잡해지기 때문에 실행 흐름을 이해하기 어려워질 수 있다. 또한, 코드를 수정할 때 수정할 대상이 많아져서 변경이 어려워지는 일이 발생할 수도 있다.&lt;/p&gt;
&lt;h3 id=&quot;적절하게-잘-나누게-되면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-%EC%9E%98-%EB%82%98%EB%88%84%EA%B2%8C-%EB%90%98%EB%A9%B4&quot; aria-label=&quot;적절하게 잘 나누게 되면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;적절하게 잘 나누게 되면&lt;/h3&gt;
&lt;p&gt;적절한 규모로 잘 나누게 되면 (구조적인 복잡도는 증가하지만) 상위 수준에서 코드의 전체적인 흐름을 이해하기 쉬워진다. 또한, 잘 나누게 되면 코드를 변경할 위치가 한 곳으로 집중될 가능성이 높아지므로 나누기 전보다 코드를 수정하기 쉬워질 가능성이 높아진다.&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;따라서 결론적으로 코드를 너무 적게 혹은 너무 많이도 말고, &lt;strong&gt;적절히, 잘&lt;/strong&gt; 나누는 것이 중요하다 (물론 말은 참 쉽다 ^^). 특히 초짜라면 평소에 코드 나누기 연습을 해야 몸에 체득이 되어 실전에서 저절로 나오게 된다.&lt;/p&gt;
&lt;p&gt;연차가 오래 쌓인 개발자들도 기본적인 나누기를 못하는 경우가 많다고 하니.. 나누는 것을 습관화할 필요가 있을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로그래밍 초식 요약 - What? How?]]></title><description><![CDATA[…]]></description><link>https://jaehyeon48.github.io/architecture/programming101-3/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/programming101-3/</guid><pubDate>Wed, 08 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://www.youtube.com/watch?v=kRdML08R2Yo&amp;#x26;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&quot;&gt;최범균님의 프로그래밍 초식 시리즈&lt;/a&gt;을 요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;개발자들의-구현-본능&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%93%A4%EC%9D%98-%EA%B5%AC%ED%98%84-%EB%B3%B8%EB%8A%A5&quot; aria-label=&quot;개발자들의 구현 본능 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개발자들의 구현 본능&lt;/h2&gt;
&lt;p&gt;아무래도 개발자들은 구현을 하는 입장이다 보니, 구현 사항을 들으면 어떻게 구현을 하면 좋을지 자연스럽게 떠올리는 경향이 있는 것 같다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/programming101/developer_instinct.png&quot; alt=&quot;구현 본능&quot;&gt;
    &lt;figcaption&gt;구현 본능&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이를 코드로 “직역”에 가깝게 구현하면 아마 다음과 비슷하게 구현할 수 있을 것같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; userDao&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;countUsersByReg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  pointRate &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  logDao&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;AR&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만, 시간이 흐르다 보면 처음 코드를 구현할 때의 요구 사항들이 점점 희미해져 간다. 이렇게 희미해진 내용은 구전으로 전해지거나, 혹은 운이 (정말) 좋으면 문서로 남아있거나 할텐데 어쨌거나 “코드가 왜 이렇게 구현되었는가?”에 대한 내용이 머릿속에서 사라져간다.&lt;/p&gt;
&lt;p&gt;그렇게 시간이 더 흘러 담당자, 개발자 등이 바뀌게 되고 (실제로 이런 일이 비일비재 하다고 한다!) 어느 순간 누군가 코드를 봤을 때 그 코드가 “왜 그렇게 짜여졌는지” 이해하기 어려운 시점이 찾아오게 된다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“여기 log 남길 때 왜 count가 0보다 클 때만 남기는지 아시나요? if문은 빼도 될 것 같은데…”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“제가 회사에 왔을 때부터 이랬어가지고 저도 잘… 무슨 이유가 있을테니 건들지 맙시다..”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;요구사항이-바뀐다면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD%EC%9D%B4-%EB%B0%94%EB%80%90%EB%8B%A4%EB%A9%B4&quot; aria-label=&quot;요구사항이 바뀐다면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;요구사항이 바뀐다면?&lt;/h3&gt;
&lt;p&gt;요구사항은 항상 변하기 마련이고, 소프트웨어 개발은 한 번 완료되었다고 해서 그것으로 끝나는 것이 아니다. 따라서 위에서 봤던 코드도 다음과 같이 변경될 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;count &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; 다른 조건 추가&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  pointRate &lt;span class=&quot;token operator&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;what과-how를-나눠서-생각해보자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#what%EA%B3%BC-how%EB%A5%BC-%EB%82%98%EB%88%A0%EC%84%9C-%EC%83%9D%EA%B0%81%ED%95%B4%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;what과 how를 나눠서 생각해보자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;WHAT과 HOW를 나눠서 생각해보자&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WHAT&lt;/strong&gt;: 구현한 코드가 하려는 것, 의미, 의도&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HOW&lt;/strong&gt;: WHAT을 실제로 구현한 것&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;WHAT&lt;/th&gt;
&lt;th&gt;HOW&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;가입한지 1년 미만&lt;/td&gt;
&lt;td&gt;User 테이블에서 reg 컬럼 값 기준으로 count&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;추가 지급 내역 남김&lt;/td&gt;
&lt;td&gt;log 테이블에 insert&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;코드를-우선-what으로-표현해보자-how는-그-다음에&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9A%B0%EC%84%A0-what%EC%9C%BC%EB%A1%9C-%ED%91%9C%ED%98%84%ED%95%B4%EB%B3%B4%EC%9E%90-how%EB%8A%94-%EA%B7%B8-%EB%8B%A4%EC%9D%8C%EC%97%90&quot; aria-label=&quot;코드를 우선 what으로 표현해보자 how는 그 다음에 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드를 우선 WHAT으로 표현해보자! HOW는 그 다음에…&lt;/h3&gt;
&lt;p&gt;우선 코드를 WHAT으로, 즉 실제 의미가 드러나도록 코딩을 해보자. 그리고 나서 실제로 구현(HOW)해보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; addPointRate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isUserRegisteredLessThanNYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; userId&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  addPointRate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;addPointRate &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;recordAddPointHistory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;userId&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; addPointRate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;what과-how의-분리-결과&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#what%EA%B3%BC-how%EC%9D%98-%EB%B6%84%EB%A6%AC-%EA%B2%B0%EA%B3%BC&quot; aria-label=&quot;what과 how의 분리 결과 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;WHAT과 HOW의 분리 결과&lt;/h2&gt;
&lt;p&gt;WHAT(코드의 의미, 의도)과 HOW(실제 구현)를 분리하게 되면, 구현을 잠시 잊고 실제로 코드가 하려고 하는 것이 무엇인지 생각해보게 된다. 그로 인해&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;실제로 수행하려고 하는 동작이 코드에 드러날 가능성이 높아지고,&lt;/li&gt;
&lt;li&gt;그로인해 코드의 가독성이 향상되고,&lt;/li&gt;
&lt;li&gt;유지보수성이 좋아진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;물론, 실제로 구현하다 보면 여러 이슈들로 인해 표현력이 떨어질 수도 있다. 하지만 이런식으로 WHAT과 HOW를 분리하려는 노력을 계속해서 한다면, 전반적으로 내가 작성하는 코드의 표현력이 좋아질 것이다.&lt;/p&gt;
&lt;p&gt;따라서 결론은, 의식의 흐름대로 (생각나는 대로) “막” 구현하면 안된다. &lt;strong&gt;항상 의미/의도가 드러나는 코드를 작성하려고 노력해야 한다&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;근데 이거 함수형 프로그래밍이랑 비슷한거 같다..? 🤔&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로그래밍 초식 요약 - Early return]]></title><description><![CDATA[이 글은 최범균님의 프로그래밍 초식 시리즈을 요약한 글입니다. If…]]></description><link>https://jaehyeon48.github.io/architecture/programming101-4/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/programming101-4/</guid><pubDate>Wed, 08 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://www.youtube.com/watch?v=kRdML08R2Yo&amp;#x26;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&quot;&gt;최범균님의 프로그래밍 초식 시리즈&lt;/a&gt;을 요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;if-조건-역으로-바꾸기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#if-%EC%A1%B0%EA%B1%B4-%EC%97%AD%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B8%B0&quot; aria-label=&quot;if 조건 역으로 바꾸기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;If 조건 역으로 바꾸기&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건이 많거나, 중첩된 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건이 많아지면 코드가 복잡해지고 분석하기 어려워진다. &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건을 덜 복잡하게 하는 여러 방법들 중 가장 쉬운(?) 방법을 살펴보자.&lt;/p&gt;
&lt;h3 id=&quot;흔한-요구사항&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%9D%94%ED%95%9C-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD&quot; aria-label=&quot;흔한 요구사항 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;흔한 요구사항&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt;인 경우에만 &lt;code class=&quot;language-text&quot;&gt;E&lt;/code&gt;를 실행한다:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// E 실행&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt;인 경우에, 그리고 &lt;code class=&quot;language-text&quot;&gt;B&lt;/code&gt;인 경우에는 &lt;code class=&quot;language-text&quot;&gt;E&lt;/code&gt;를 실행한다:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// B 조건을 구함&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// E 실행&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만, 다음 그림과 같이 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 블록이 길어지게 되면 모니터 한 화면에 안 들어오게 되고 스크롤을 해야 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 블록의 끝을 알 수 있다. 또한, 코드를 분석할 때 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 블록의 실행 조건을 머릿속에 기억하면서 코드를 분석해 나가야 한다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/architecture/programming101/too_long_if_block.png&quot; alt=&quot;너무 긴 if 블록&quot;&gt;
    &lt;figcaption&gt;출처: https://www.youtube.com/watch?v=z4qE_IfSrD4&amp;amp;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&amp;amp;index=7&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;코드-구조가-이렇다면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C-%EA%B5%AC%EC%A1%B0%EA%B0%80-%EC%9D%B4%EB%A0%87%EB%8B%A4%EB%A9%B4&quot; aria-label=&quot;코드 구조가 이렇다면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드 구조가 이렇다면?&lt;/h3&gt;
&lt;p&gt;아래 코드들과 같이 &lt;code class=&quot;language-text&quot;&gt;else&lt;/code&gt; 가 없거나, &lt;code class=&quot;language-text&quot;&gt;else&lt;/code&gt; 로직이 단순한 경우가 종종 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    logger&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;some message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// B 조건 구함&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// E 실행&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 코드들은 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건을 역으로 바꿈으로써 코드를 좀 더 단순화할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    logger&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;some message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;someCondition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    logger&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;some message&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 많은 코드&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// B 조건 구함&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// E 실행&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// B조건 구함&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// E 실행&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;if-조건을-역으로-바꾸게-되면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#if-%EC%A1%B0%EA%B1%B4%EC%9D%84-%EC%97%AD%EC%9C%BC%EB%A1%9C-%EB%B0%94%EA%BE%B8%EA%B2%8C-%EB%90%98%EB%A9%B4&quot; aria-label=&quot;if 조건을 역으로 바꾸게 되면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;If 조건을 역으로 바꾸게 되면…&lt;/h2&gt;
&lt;p&gt;위 사례들과 같이, &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건을 역으로 바꾸게 되면 &lt;code class=&quot;language-text&quot;&gt;else&lt;/code&gt; 가 없다는 사실을 빨리 파악할 수 있다. 또한, &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 조건을 기억해야 할 범위가 좁아져서 상대적으로 인지 부하가 감소되고, 인덴트의 깊이가 줄어들어 코드가 간결해진다. 따라서 그만큼 코드 분석에 좀 더 유리해진다고 할 수 있다.&lt;/p&gt;
&lt;p&gt;물론 &lt;code class=&quot;language-text&quot;&gt;if-else&lt;/code&gt; 문을 써야하는 경우도 있겠지만..(어디에나 예외는 있으니 말이다) 되도록이면 &lt;strong&gt;early return&lt;/strong&gt; 패턴을 적용해서 인덴트의 깊이를 줄이고, &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 블록의 길이를 줄여 코드를 더 깔끔하게 작성하는 편이 좋을 것 같다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[프로그래밍 초식 요약 - 변수 아끼기]]></title><description><![CDATA[…]]></description><link>https://jaehyeon48.github.io/architecture/programming101-1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/programming101-1/</guid><pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 &lt;a href=&quot;https://www.youtube.com/watch?v=kRdML08R2Yo&amp;#x26;list=PLwouWTPuIjUg0dmHoxgqNXyx3Acy7BNCz&quot;&gt;최범균님의 프로그래밍 초식 시리즈&lt;/a&gt;을 요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;인지-부하&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B8%EC%A7%80-%EB%B6%80%ED%95%98&quot; aria-label=&quot;인지 부하 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;인지 부하&lt;/h2&gt;
&lt;p&gt;종종 다음과 같은 형태의 코드를 만날 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* 변수를 미리 선언 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* 변수를 중간에 변경 */&lt;/span&gt;
age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFullYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBirthYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;/* 변수 사용 */&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;이름: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;나이: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;age&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* 변수의 용도와 의미를 바꿔 가면서 사용 */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someOp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someOp2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;someOp3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 예시들과 같이 변수를 (코드 기준으로) 긴 범위에서 사용한다든가, (어떤 메소드 내에) 변수의 개수가 많거나 계속 증가한다든가, 변수의 용도가 계속해서 변화하게 되면 개발자들이 코드를 보면서 변수들이 어떻게 변화해 나가는지 추적하기가 힘들어지고, 그로 인해 코드의 동작을 유추하기 힘들어진다.&lt;/p&gt;
&lt;p&gt;이로 인해 코드를 이해하는데 드는 노력, 비용등이 증가하게 되고 그 말인 즉 코드를 변경하기 어려워지게 된다.&lt;/p&gt;
&lt;h2 id=&quot;변수를-아껴쓰자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B3%80%EC%88%98%EB%A5%BC-%EC%95%84%EA%BB%B4%EC%93%B0%EC%9E%90&quot; aria-label=&quot;변수를 아껴쓰자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;변수를 아껴쓰자!&lt;/h2&gt;
&lt;p&gt;따라서, 변수를 아껴 쓰는것이 중요한데, 다음과 같이 선언한 이후 1~2번 정도밖에 참조하지 않는 변수는 필요 여부를 검토할 필요가 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; id &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Summary&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;id&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Summary&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;User1&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getId&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;물론, 변수를 아끼자는 말이 변수를 무조건 적게 사용하자는 말이 아니다. 다음과 같은 상황에서는 변수를 사용하는 것이 적합할 수 있다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;의미를 더해주는 변수 위주로 사용한다. 예를 들면, 식이 복잡하거나 길어지는 경우 변수 이름으로 설명한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFullYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; User&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBirthYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;같은 계산을 반복하는 경우, 변수로 재사용한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;가능한 한 선언과 할당을 한 번에 하는 것이 좋다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ... (age 변수 사용 안함)&lt;/span&gt;

age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFullYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; User&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBirthYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; age &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Date&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFullYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; User&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBirthYear&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;최대한절대로-변수의-용도나-의미를-변경하지-말자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EB%8C%80%ED%95%9C%EC%A0%88%EB%8C%80%EB%A1%9C-%EB%B3%80%EC%88%98%EC%9D%98-%EC%9A%A9%EB%8F%84%EB%82%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EB%B3%80%EA%B2%BD%ED%95%98%EC%A7%80-%EB%A7%90%EC%9E%90&quot; aria-label=&quot;최대한절대로 변수의 용도나 의미를 변경하지 말자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최대한(절대로…) 변수의 용도나 의미를 변경하지 말자&lt;/h2&gt;
&lt;p&gt;프로그래밍을 할 때, 변수의 용도나 의미를 변경해가면서 쓰면 안된다. 단순히 타입이 같다고 해서 같은 변수를 여기 저기서 이런 저런 용도로 쓰면 안된다는 것이다. 이렇게 하면 코드 분석뿐만 아니라 추후 코드 정리또한 힘들어지게 된다.&lt;/p&gt;
&lt;p&gt;따라서, 의미나 용도가 다르다면 다른 변수를 사용하는 것이 바람직하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;ts&quot;&gt;&lt;pre class=&quot;language-ts&quot;&gt;&lt;code class=&quot;language-ts&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* BAD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; res&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callApi1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

res &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callApi2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; api1Res&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callApi1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; api2Res&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;callApi2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;변수가-사용되는-범위를-최대한-좁히자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B3%80%EC%88%98%EA%B0%80-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EB%B2%94%EC%9C%84%EB%A5%BC-%EC%B5%9C%EB%8C%80%ED%95%9C-%EC%A2%81%ED%9E%88%EC%9E%90&quot; aria-label=&quot;변수가 사용되는 범위를 최대한 좁히자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;변수가 사용되는 범위를 (최대한) 좁히자&lt;/h2&gt;
&lt;p&gt;코드를 볼 때 변수가 어떤식으로 바뀌는지 그 상태를 추적해야 하는데, 변수가 사용되는 범위가 짧으면 짧을수록 추적에 따른 인지 부하가 줄어든다.&lt;/p&gt;
&lt;p&gt;따라서 변수는 최대한 짧은 범위에서 사용되는 것이 정신건강에 이롭다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;짧은 루프 블록 안으로 한정&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; msg&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Person &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; people&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; Person &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; people&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Person&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;짧은 &lt;code class=&quot;language-text&quot;&gt;if-else&lt;/code&gt; 블록 안으로 한정&lt;/li&gt;
&lt;li&gt;짧은 메서드로 한정&lt;/li&gt;
&lt;li&gt;사용되기 직전에 정의&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;/* NOT GOOD */&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blah blah&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//... (코드 10줄, msg 변경 없음)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;formatMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;


&lt;span class=&quot;token comment&quot;&gt;/* GOOD */&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// ... (코드 10줄)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;blah blah&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;formatMsg&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;초짜라면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B4%88%EC%A7%9C%EB%9D%BC%EB%A9%B4&quot; aria-label=&quot;초짜라면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;초짜라면..&lt;/h2&gt;
&lt;p&gt;멋진 설계, 화려한 기술 모두 좋고 잘해야 하는건 맞지만, 결국 기본인 &lt;strong&gt;코드&lt;/strong&gt;가 가장 중요하다. 코드가 없다면 모두 소용없지 않은가?&lt;/p&gt;
&lt;p&gt;따라서 이렇게 중요한 코드의 복잡도를 낮추고 가독성을 높이는 (쉬운?) 방법은 변수를 아끼는 것이다. &lt;/p&gt;</content:encoded></item><item><title><![CDATA[SameSite 속성]]></title><description><![CDATA[SameSite 속성 쿠키의 “SameSite” 속성은 쿠키의 범위(scope)를 제한하여 same-site 요청에 대해서만 해당 쿠키를 첨부할 수 있도록 한다. 이 속성을 통해 CSRF 공격을 어느정도 예방할 수 있다. SameSite…]]></description><link>https://jaehyeon48.github.io/web/samesite/</link><guid isPermaLink="false">https://jaehyeon48.github.io/web/samesite/</guid><pubDate>Tue, 07 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;samesite-속성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#samesite-%EC%86%8D%EC%84%B1&quot; aria-label=&quot;samesite 속성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SameSite 속성&lt;/h2&gt;
&lt;p&gt;쿠키의 “SameSite” 속성은 쿠키의 범위(scope)를 제한하여 same-site 요청에 대해서만 해당 쿠키를 첨부할 수 있도록 한다. 이 속성을 통해 CSRF 공격을 어느정도 예방할 수 있다.&lt;/p&gt;
&lt;p&gt;SameSite 속성값에는 &lt;code class=&quot;language-text&quot;&gt;None&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Lax&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Strict&lt;/code&gt; 세 가지가 있는데, 우선 same-site와 cross-site가 무엇인지 부터 간략히 살펴보고자 한다.&lt;/p&gt;
&lt;h2 id=&quot;same-site-요청과-cross-site-요청&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#same-site-%EC%9A%94%EC%B2%AD%EA%B3%BC-cross-site-%EC%9A%94%EC%B2%AD&quot; aria-label=&quot;same site 요청과 cross site 요청 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;“same-site” 요청과 “cross-site” 요청&lt;/h2&gt;
&lt;p&gt;다음의 경우, origin A와 B는 same-site로 취급된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;origin A와 B 둘 다 UUID인 경우 &lt;strong&gt;same-site&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;origin A와 B 둘 다 &lt;code class=&quot;language-text&quot;&gt;scheme/domain(혹은 host)/port&lt;/code&gt; 구조로 되어있을 때,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;(A의 domain) == (B의 domain)&lt;/code&gt; 이고, &lt;code class=&quot;language-text&quot;&gt;(A의 registrable domain) == null&lt;/code&gt;인 경우 A와 B는 &lt;strong&gt;same-site&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;(A의 registrable domain) == (B의 registrable domain)&lt;/code&gt; 이고, &lt;code class=&quot;language-text&quot;&gt;(A의 registrable domain) != null&lt;/code&gt;인 경우 A와 B는 &lt;strong&gt;same-site&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;이외의 경우 A와 B는 &lt;strong&gt;cross-site&lt;/strong&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;registrable-domain&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#registrable-domain&quot; aria-label=&quot;registrable domain permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Registrable domain&lt;/h3&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;language-text&quot;&gt;registrable domain&lt;/code&gt;는 무엇인가? &lt;strong&gt;Registrable domain&lt;/strong&gt;는 &lt;code class=&quot;language-text&quot;&gt;public suffix + public suffix 바로 왼쪽의 label&lt;/code&gt;로 정의된다. public suffix는 &lt;em&gt;effective top-level domain, eTLD&lt;/em&gt; 라고도 하는데, &lt;a href=&quot;https://publicsuffix.org/&quot;&gt;public suffix list&lt;/a&gt;에 항목들이 등재되어 있다.&lt;/p&gt;
&lt;p&gt;예를 들어, &lt;code class=&quot;language-text&quot;&gt;example.com&lt;/code&gt;의 경우 public suffix인 &lt;code class=&quot;language-text&quot;&gt;.com&lt;/code&gt;과 바로 왼쪽의 label &lt;code class=&quot;language-text&quot;&gt;example&lt;/code&gt;이 합쳐져서 &lt;code class=&quot;language-text&quot;&gt;example.com&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;registrable domain&lt;/code&gt;가 된다. &lt;code class=&quot;language-text&quot;&gt;api.example.com&lt;/code&gt;도 public suffix인 &lt;code class=&quot;language-text&quot;&gt;.com&lt;/code&gt;과 바로 왼쪽의 &lt;code class=&quot;language-text&quot;&gt;example&lt;/code&gt;이 합쳐져서 &lt;code class=&quot;language-text&quot;&gt;example.com&lt;/code&gt;이 &lt;code class=&quot;language-text&quot;&gt;api.example.com&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;registrable domain&lt;/code&gt;가 된다.&lt;/p&gt;
&lt;p&gt;또 다른 예로, &lt;code class=&quot;language-text&quot;&gt;github.io&lt;/code&gt;의 경우, &lt;code class=&quot;language-text&quot;&gt;github.io&lt;/code&gt; 자체가 public suffix 이기 때문에 &lt;code class=&quot;language-text&quot;&gt;user.github.io&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;other.github.io&lt;/code&gt;는 cross-site로 취급된다.&lt;/p&gt;
&lt;h3 id=&quot;schemeful-same-site&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#schemeful-same-site&quot; aria-label=&quot;schemeful same site permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Schemeful same-site&lt;/h3&gt;
&lt;p&gt;기존에는 registrable domain가 같고 scheme만 다른 경우 same-site로 취급하였는데, 크롬 89버전 부터는 scheme이 다른 경우 cross-site로 취급한다고 한다.&lt;/p&gt;
&lt;p&gt;즉, 기존에는 &lt;code class=&quot;language-text&quot;&gt;http://example.com&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;https://example.com&lt;/code&gt;은 same-site로 취급되었으나, 이제는 cross-site로 취급되게 된다.&lt;/p&gt;
&lt;p&gt;이미 기존의 웹사이트가 &lt;code class=&quot;language-text&quot;&gt;HTTPS&lt;/code&gt;를 사용하고 있다면 이와 같은 변경에 대해선 전혀 신경쓸 필요가 없다고 한다.&lt;/p&gt;
&lt;h2 id=&quot;samesite-속성값&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#samesite-%EC%86%8D%EC%84%B1%EA%B0%92&quot; aria-label=&quot;samesite 속성값 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SameSite 속성값&lt;/h2&gt;
&lt;h3 id=&quot;none&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#none&quot; aria-label=&quot;none permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;None&lt;/h3&gt;
&lt;p&gt;SameSite의 값이 &lt;code class=&quot;language-text&quot;&gt;None&lt;/code&gt;으로 설정된 쿠키는 same-site 요청뿐만 아니라 cross-site 요청시에도 쿠키가 전송된다. &lt;code class=&quot;language-text&quot;&gt;None&lt;/code&gt;값이 되기 위해선 반드시 쿠키의 &lt;code class=&quot;language-text&quot;&gt;Secure&lt;/code&gt; 속성값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 이어야만 한다.&lt;/p&gt;
&lt;h3 id=&quot;lax&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lax&quot; aria-label=&quot;lax permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lax&lt;/h3&gt;
&lt;p&gt;SameSite값이 명시되지 않은 경우 default로 적용되는 값이다. same-site 요청, 그리고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP&quot;&gt;안전한&lt;/a&gt; HTTP 메소드를 통한 cross-site top-level 네비게이션시에 쿠키가 전송된다.&lt;/p&gt;
&lt;p&gt;Top-level 네비게이션에는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;a&gt;&lt;/code&gt;를 클릭하거나 &lt;code class=&quot;language-text&quot;&gt;window.location.replace&lt;/code&gt; 등으로 인해 자동으로 발생하는 이동, &lt;code class=&quot;language-text&quot;&gt;302&lt;/code&gt; 리다이렉트로 인한 이동이 포함된다. &lt;code class=&quot;language-text&quot;&gt;&amp;lt;img&gt;&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;iframe&gt;&lt;/code&gt;등을 통한 HTTP 요청은 “네비게이션”이라 보기 어려우므로 쿠키가 전송되지 않는다.&lt;/p&gt;
&lt;p&gt;Top-level 네비게이션에 관한 예시는 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-8.8.2&quot;&gt;RFC6265bis section 8.8.2&lt;/a&gt;를 참고하길 바란다.&lt;/p&gt;
&lt;h3 id=&quot;strict&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#strict&quot; aria-label=&quot;strict permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Strict&lt;/h3&gt;
&lt;p&gt;same-site 요청시에만 쿠키가 전송된다.&lt;/p&gt;
&lt;h2 id=&quot;references&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#references&quot; aria-label=&quot;references permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis-07#section-5.2&quot;&gt;draft-ietf-httpbis-rfc6265bis-07&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://web.dev/schemeful-samesite/&quot;&gt;Schemeful Same-Site&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://web.dev/samesite-cookies-explained/&quot;&gt;SameSite cookies explained&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리팩토링 2판 요약 정리 Ch.1]]></title><description><![CDATA[리팩토링 2판을 번역/요약한 글입니다. 서문 읽기 쉬우면서도 변경에 용이한 코드를 유지하는 비결은 리팩토링이다. 리팩토링은 risky…]]></description><link>https://jaehyeon48.github.io/architecture/refactoring_summary_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/architecture/refactoring_summary_1/</guid><pubDate>Mon, 06 Dec 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599&quot;&gt;리팩토링 2판&lt;/a&gt;을 번역/요약한 글입니다.&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;서문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%AC%B8&quot; aria-label=&quot;서문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서문&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;읽기 쉬우면서도 변경에 용이한 코드를 유지하는 비결은 리팩토링이다.&lt;/li&gt;
&lt;li&gt;리팩토링은 risky한 작업이다. 현재 (잘) 작동하고 있는 코드를 변경함으로 인해 사소한 버그들이 발생할 수 있다. 리팩토링을 적절히, 체계적으로 하지 않으면 몇 일, 심지어는 몇 주전으로 퇴보할 수도 있다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;리팩토링이란 소프트웨어가 수행하는 동작(external behavior)은 변경하지 않으면서 내부 구조를 개선하는 작업이다.&lt;/strong&gt; 즉, 코드를 더 깔끔하게 만들어서 버그가 발생할 확률을 줄이는 행위이다.&lt;/li&gt;
&lt;li&gt;본질적으로 리팩토링을 한다는 것은 기존에 짜여진 코드의 설계를 개선해 나가는 작업이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;chapter-1&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#chapter-1&quot; aria-label=&quot;chapter 1 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Chapter 1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;잘못 설계된 시스템은 무엇을 변경해야 할지 알기 어렵다. 또한, 변경했을 때 내가 원하는 대로 동작하기 위해 기존의 코드와 어떻게 상호작용하는지 파악하기 힘들다. 결국 무엇을 변경해야 할지 알아내기 힘들다면 실수할 가능성이 높아지고, 버그가 발생할 확률이 올라간다.&lt;/li&gt;
&lt;li&gt;제대로 구조화되지 않은 프로그램에 기능을 추가해야 하는 상황이라면, 우선 리팩토링을 먼저 해서 해당 프로그램에 새로운 기능을 추가하기 쉽게끔 만든 다음 기능을 추가하는 편이 좋다.&lt;/li&gt;
&lt;li&gt;만약 코드가 잘 작동하고 앞으로도 코드를 &lt;em&gt;절대&lt;/em&gt; 바꿀 일이 없다면 굳이 리팩토링을 안 해도 된다. 물론 더 개선하면 좋겠지만 다른 사람이 이해할 필요가 없는 코드라면 그대로 두어도 딱히 문제 될 건 없다. 하지만 만약 누군가 그 코드가 어떻게 동작하는지 알아야만 하고, 또 그 코드의 동작을 파악하는 데 어려움을 겪는다면 무언가 조치를 취해야만 한다.&lt;/li&gt;
&lt;li&gt;리팩토링을 하기 전에, 반드시 해당 코드에 대한 확실한 테스트 셋을 마련해야 한다. 아무리 체계적으로 리팩토링을 한다고 해도 인간이기에 실수를 할 수 있기 때문이다.&lt;/li&gt;
&lt;li&gt;테스트는 자가 테스트(self-checking)인 것이 중요하다 (즉, 자동으로 테스트할 수 있어야 한다). 만약 그렇지 않다면 테스트 케이스와 일일이 손으로 체크해가면서 테스팅을 해야 하는데, 이렇게 하면 생산성이 저하된다. 대부분의 요즘 테스팅 프레임워크들은 자가 테스트를 작성하고 실행하는 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;테스트를 빌드하고 수행하는 데 시간이 들지라도, 결국에는 디버깅하는 시간을 줄임으로써 전체적으로 시간을 절약할 수 있게 된다.&lt;/li&gt;
&lt;li&gt;리팩토링을 통해 코드에 변화를 주고 나면, 즉시 컴파일하여 내가 잘못 건드린 부분이 있는지 테스트한다. 변경한 부분이 크든 작든 상관없이 리팩토링을 한 이후에는 반드시 테스트하는 습관을 들여야한다. &lt;strong&gt;“조금 변경하고 바로 테스팅 해보는 것”&lt;/strong&gt;,이것이 바로 리팩토링 과정의 정수이다.&lt;/li&gt;
&lt;li&gt;왜 코드를 변경할 때마다 테스트 하는 게 좋냐면, 작은 변화를 주고 나서 바로 테스트하는 것이 디버깅하는데 더 수월하기 때문이다. 나중에 한꺼번에 몰아서 테스트하려고 하면 디버깅 하는게 어려워지고 시간도 오래 걸리게 된다.&lt;/li&gt;
&lt;li&gt;테스트를 통과하고 나면 Git과 같은 VCS 시스템에 변경 사항을 기록한다. 나는 각각 리팩토링에 성공할 때마다 commit을 하는 편인데, 이렇게 하면 추후에 뭔가를 잘못했을 때 다시 되돌아가기 쉽다.&lt;/li&gt;
&lt;li&gt;좋은 코드는 그 코드가 무엇을 하는지 명확하게 전달할 수 있어야 하고, 변수(함수) 이름은 이러한 좋은 코드의 핵심이다. 이름을 바꿈으로써 코드의 명확성을 더욱 높일 수 있다면 이름을 바꾸는 것을 &lt;em&gt;절대&lt;/em&gt; 주저하지 마라.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;컴퓨터가 이해하는 코드는 바보도 짤 수 있다. 그러나 사람이 이해하는 코드는 오직 좋은 프로그래머만이 짤 수 있다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;이름 짓는 것은 중요하면서도 까다롭다. 큰 함수를 작은 함수로 분리하는 작업도 결국 함수들의 이름을 제대로 지었을 때만 그 가치가 있다.&lt;/li&gt;
&lt;li&gt;이름을 잘 지어놓으면 함수의 body 부분을 보지 않고서도 그 함수가 무엇을 하는지 알아낼 수 있다. 하지만 처음부터 이름을 제대로 짓는 것은 어렵다. 나는 우선 그 당시 생각해낼 수 있는 이름 중 제일 좋은 이름을 지어놓고, 나중에 더 좋은 이름이 생각나면 가차 없이 바꾼다. 때로는 코드를 두 번 이상 훑어보아야 진정으로 좋은 이름이 무엇인지 알게 되는 경우도 있다.&lt;/li&gt;
&lt;li&gt;대부분의 프로그래머들, 심지어는 경력이 쌓인 시니어들까지도 코드의 실제 퍼포먼스를 잘 예측하지 못한다. 코드 성능에 관한 우리의 직관은 우수한 컴파일러, 현대의 캐싱 기법과 같은 기술들에 의해 보기 좋게 빗나간다. 프로그램의 성능은 대게 코드의 일부분에만 영향을 받으며, 그 외 나머지 부분이 변경된다고 해서 큰 차이를 만들지는 않는다.&lt;/li&gt;
&lt;li&gt;때때로 리팩토링으로 인해 눈에 띌만한 성능 저하가 발생하기도 한다. 하지만 잘 짜인 코드의 성능을 개선하는 것이 (그렇지 않은 코드보다) 훨씬 쉽기 때문에, 리팩토링으로 인해 성능 저하가 발생한다고 하더라도 나는 리팩토링을 진행하는 편이다.&lt;/li&gt;
&lt;li&gt;만약 리팩토링으로 인해 성능 이슈가 발생하면 리팩토링 이후에 성능 개선 작업을 수행한다. 이에 따라 이전에 리팩토링한 코드를 되돌리는 경우가 발생할 수도 있다. 하지만 대부분의 경우, 리팩토링함으로써 더 효과적인 성능 개선 작업을 수행할 수 있다. 궁극적으로 깨끗하고(clearer) 더 빠른 코드가 탄생하게 되는 것이다.&lt;/li&gt;
&lt;li&gt;나는 최대한 데이터들을 불변(immutable)으로 다루는 것을 선호한다. 가변(mutable) 상태들은 쉽게 상하기(rotten) 때문이다.&lt;/li&gt;
&lt;li&gt;간결함은 지혜의 본질이지만, 명확성은 발전하는 소프트웨어의 본질이다.&lt;/li&gt;
&lt;li&gt;코드는 명확해야 한다. 코드를 수정하려고 할 때, 어느 부분을 수정해야 하는지 쉽게 찾을 수 있어야 하며, 에러를 발생시키지 않으면서 빠르게 수정할 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;작은 단계들을 밟아 나갈 때 더욱 빨리 진행할 수 있으면서 코드가 절대 망가지지 않고, 이러한 작은 단계들을 합쳐 거대한 변화로 만들 수 있다는 점을 인지하는 것이 효과적인 리팩토링의 핵심이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;나만의-세-줄-요약&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%98%EB%A7%8C%EC%9D%98-%EC%84%B8-%EC%A4%84-%EC%9A%94%EC%95%BD&quot; aria-label=&quot;나만의 세 줄 요약 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;나만의 세 줄 요약&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;컴퓨터가 아니라 &lt;strong&gt;사람&lt;/strong&gt;이 이해하기 쉬운 코드를 짜려고 노력하자.&lt;/li&gt;
&lt;li&gt;리팩토링을 할 땐 &lt;strong&gt;반드시&lt;/strong&gt; 테스트를 하자.&lt;/li&gt;
&lt;li&gt;리팩토링을 할 땐 (아주) 작은 단계들로 나눠서 진행하자.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[브라우저 환경에서의 이벤트 루프]]></title><description><![CDATA[…]]></description><link>https://jaehyeon48.github.io/javascript/browser_event_loop/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/browser_event_loop/</guid><pubDate>Sat, 03 Oct 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h2 id=&quot;브라우저의-이벤트-루프&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84&quot; aria-label=&quot;브라우저의 이벤트 루프 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;브라우저의 이벤트 루프&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;자바스크립트는 싱글 스레드 기반의 언어이고, 자바스크립트 엔진은 오직 하나의 호출 스택을 사용한다. 즉, 요청이 동기적으로 처리되어 한 번에 한 가지 일만 처리할 수 있음을 의미한다.&lt;/li&gt;
&lt;li&gt;이 때, 네트워크 요청과 같이 오버헤드가 큰 요청의 경우 동기적으로 처리된다면 다른 일을 처리할 수 없거나, 렌더링을 block하는 등 여러 문제가 발생할 수 있다. 따라서 자바스크립트의 주요 실행 환경(runtime)인 브라우저나 Node.js에서는 비동기 작업을 수행할 수 있도록 다양한 기능을 제공한다.&lt;/li&gt;
&lt;li&gt;이를 위해, 자바스크립트의 실행 환경인 브라우저나 Node.js 에서는 (자바스크립트가 싱글 스레드인 것과는 달리) 여러 개의 스레드가 사용된다. 이렇게 여러 스레드를 사용하는 실행 환경과 자바스크립트 엔진을 연동하기 위해 사용되는 장치가 &lt;strong&gt;이벤트 루프&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;이벤트 루프가 “루프”라고 불리는 이유는, 이벤트 루프의 동작 방식이 계속해서 task들을 실행하는 무한루프와 같기 때문이다. 수도 코드로 이벤트 루프를 아주 간단히 나타내면 다음과 같다:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;waitForTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;참고로, Chrome/Chromium은 이벤트 루프의 구현 라이브러리로 &lt;code class=&quot;language-text&quot;&gt;libevent&lt;/code&gt; 를, Node.js는 &lt;code class=&quot;language-text&quot;&gt;libuv&lt;/code&gt; 를 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;매크로-태스크-큐&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90&quot; aria-label=&quot;매크로 태스크 큐 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;(매크로) 태스크 큐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;앞서 말했듯이, 이벤트 루프는 task가 들어오기를 기다렸다가, task가 들어오면 해당 task를 실행하고, 처리할 task가 없는 경우에는 task가 들어오기를 기다리는 무한 루프라고 할 수 있다.&lt;/li&gt;
&lt;li&gt;이 때 &lt;code class=&quot;language-text&quot;&gt;task&lt;/code&gt;란, 최초에 (&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt; 태그로 로드한) 스크립트를 실행하거나, 이벤트가 발생했을 때 해당 이벤트를 처리하는 핸들러(콜백)을 실행하거나, &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt; 등에 의해 설정된 interval, timeout 등이 발생했을 때 콜백을 실행하는 등 (추후에) 실행되도록 스케쥴되는 자바스크립트 코드이다. 잠시 후에 살펴볼 microtask와 구분짓기 위해 macrotask라고도 한다.&lt;/li&gt;
&lt;li&gt;이러한 task들은 &lt;strong&gt;task queue&lt;/strong&gt;라는 곳에 저장된다. &lt;a href=&quot;https://html.spec.whatwg.org/multipage/webappapis.html#event-loops&quot;&gt;HTML스펙&lt;/a&gt;에 따르면, task queue는 “queue” 자료형이 아니라 “set” 자료형이라고 한다. 그 이유는, 이벤트 루프가 단순히 task queue의 첫 번째(가장 오래된) task를 가져오는 것이 아니라, 실행 가능한(runnable) task 중에서 첫 번째 task를 가져오는 것이기 때문에 task가 runnable인지 아닌지를 구분해야 하기 때문이다. 만약 task queue가 queue 자료형으로 되어 있다면 runnable이 아닌 task를 가져오는 경우가 생길 수도 있을 것이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/Execution_timing_event_loop_with_tasks.png&quot; alt=&quot;Execution timing: event loop with tasks&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;사실, task queue는 하나가 아니라 여러 개가 존재할 수 있다. 이 때, 동일한 task source로 부터 생성된 task는 반드시 같은 task queue에 들어가야 하며, 앞서 언급한 것과 같이 먼저온 순서대로 처리해야 한다.&lt;/li&gt;
&lt;li&gt;예를 들면, &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 으로 생성된 task들이 저장되는 task queue와, &lt;code class=&quot;language-text&quot;&gt;click&lt;/code&gt; 이벤트에 의해 생성된 task들이 저장되는 task queue 등이 따로 존재할 수 있다.&lt;/li&gt;
&lt;li&gt;여러 개의 task queue중 어떤 task queue를 선택할 것인가는 구현하기 나름이다. (macro)task는 이벤트 루프의 각 iteration 마다 (task queue의 종류에 관계없이) 오직 하나만 처리된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;waitForTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; taskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;selectTaskQueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/Execution_timing_event_loop_with_task_queues.png&quot; alt=&quot;Execution timing: event loop with task queues&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;마이크로-태스크-큐&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90&quot; aria-label=&quot;마이크로 태스크 큐 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마이크로 태스크 큐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;queueMicrotask&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;MutationObserver&lt;/code&gt; 등에 의해 생성된 task들을 &lt;code class=&quot;language-text&quot;&gt;microtask&lt;/code&gt; 라고 부른다. microtask들은 별도의 microtask queue에 저장된다.&lt;/li&gt;
&lt;li&gt;microtask는 이벤트 루프의 각 iteration 마다 하나의 (macro)task를 처리한 이후 microtask queue가 빌 때까지 모든 microtask를 처리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;waitForTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; taskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;selectTaskQueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; microtaskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;microTaskQueue
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;microtaskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNextMicrotask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    microtaskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextMicrotask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/Execution_timing_event_loop_with_microtask_queue.png&quot; alt=&quot;Execution timing: event loop with microtask queues&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;또한, (macro)task와는 다르게 microtask는 이벤트 루프의 iteration이 시작된 이후에 추가되었다고 하더라도 다음 iteration이 실행되기 전에 처리될 수 있다. 따라서 조심해야할 것이, 자칫 잘못하면 이벤트 루프가 microtask만 끊임없이 처리하게 될 수도 있다. 특히 브라우저의 경우, 이러한 일이 발생하면 유저와의 인터렉션, DOM 렌더링 등이 동작하지 않으므로 주의가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/taskqueue.gif&quot; alt=&quot;Behavior of the task queue animation&quot;&gt;
    &lt;figcaption&gt;출처: https://www.youtube.com/watch?v=cCOL7MC4Pl0&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/microtaskqueue.gif&quot; alt=&quot;Behavior of the microtask queue animation&quot;&gt;
    &lt;figcaption&gt;출처: https://www.youtube.com/watch?v=cCOL7MC4Pl0&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;렌더링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A0%8C%EB%8D%94%EB%A7%81&quot; aria-label=&quot;렌더링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;렌더링&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;마지막으로, UI 렌더링도 이벤트 루프에 의해 처리된다.&lt;/li&gt;
&lt;li&gt;엔진이 어떤 task를 처리하는 동안에는 렌더링이 발생하지 않는다. 실행중인 task를 완료한 이후에야 DOM에 발생한 변화를 반영하여 화면에 렌더링할 수 있다.&lt;/li&gt;
&lt;li&gt;UI 렌더링은 이벤트 루프의 매 iteration의 마지막 (즉 macrotask를 처리하고, microtask도 처리한 이후)에 “수행될 수도 있다”.&lt;/li&gt;
&lt;li&gt;수행될 수도 있다라고 한 이유는, 브라우저가 렌더링을 하지 않고 task만 처리하는 경우도 있기 때문이다. 즉, 렌더링을 할지 말지는 브라우저가 자유롭게 결정할 수 있기 때문에 이벤트 루프의 매 iteration 마지막에 렌더링 작업이 수행될 수도, 그렇지 않을 수도 있는 것이다.&lt;/li&gt;
&lt;li&gt;또한, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;requestAnimationFrame()&lt;/a&gt; 이라는 메소드를 통해 렌더링 직전에 특정 작업을 수행하도록 요청할 수도 있다. &lt;code class=&quot;language-text&quot;&gt;requestAnimationFrame()&lt;/code&gt; 에 전달되는 콜백들은 &lt;strong&gt;animationFrames&lt;/strong&gt; 라는 큐에 저장되어 브라우저가 렌더링을 하는 경우, 렌더링을 하기 직전에 해당 큐에 있는 콜백들을 수행한다.&lt;/li&gt;
&lt;li&gt;이 때 이벤트 루프의 iteration이 시작되는 시점에 존재하던 콜백들은 모두 실행되지만, 도중에 추가된 콜백들은 현재 iteration에서는 실행되지 않고, 이후의 iteration에서 렌더링을 할 때 실행된다:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/animationframes.gif&quot; alt=&quot;Behavior of the animation frames animation&quot;&gt;
    &lt;figcaption&gt;출처: https://www.youtube.com/watch?v=cCOL7MC4Pl0&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;waitForTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; taskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;selectTaskQueue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    taskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; microtaskQueue &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; eventLoop&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;microTaskQueue
  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;microtaskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasNextMicrotask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    microtaskQueue&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;processNextMicrotask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;shouldRender&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    animationTasks &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; animationFrames&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;animationTask &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; animationTask&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;animationTask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/Execution_timing_event_loop_with_rendering.png&quot; alt=&quot;Execution timing: event loop with rendering&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;최종적으로 이벤트 루프의 흐름을 간단한 그림으로 나타내면 다음과 같다:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/event_loop_flow.png&quot; alt=&quot;Event loop flow&quot;&gt;
    &lt;figcaption&gt;출처: https://javascript.info/event-loop&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;또한, 브라우저 런타임을 간단한 그림으로 나타내면 다음과 같다:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/browser_event_loop/browser_runtime_in_a_nutshell.png&quot; alt=&quot;browser runtime in a nutshell&quot;&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;references&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#references&quot; aria-label=&quot;references permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;REFERENCES&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&quot;&gt;https://blog.risingstack.com/writing-a-javascript-framework-execution-timing-beyond-settimeout/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://javascript.info/event-loop&quot;&gt;https://javascript.info/event-loop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/25750884/are-there-significant-differences-between-the-chrome-browser-event-loop-versus-t&quot;&gt;https://stackoverflow.com/questions/25750884/are-there-significant-differences-between-the-chrome-browser-event-loop-versus-t&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://velog.io/@yejineee/%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EC%99%80-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90-%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%A7%A4%ED%81%AC%EB%A1%9C-%ED%83%9C%EC%8A%A4%ED%81%AC-g6f0joxx&quot;&gt;https://velog.io/@yejineee/이벤트-루프와-태스크-큐-마이크로-태스크-매크로-태스크-g6f0joxx&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[브라우저는 어떻게 동작하는가? Part1]]></title><description><![CDATA[2편 브라우저의 주요 구성 요소 유저 인터페이스: 주소창, 북마크바, 앞/뒤로 가기 버튼 등 사이트 화면이 나오는 곳을 제외한 부분. 브라우저 엔진: UI와 렌더링 엔진을 제어. 렌더링 엔진: 요청한 내용(content…]]></description><link>https://jaehyeon48.github.io/web/how_browsers_work_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/web/how_browsers_work_1/</guid><pubDate>Sat, 29 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../how_browsers_work_2&quot;&gt;2편&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;브라우저의-주요-구성-요소&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%A3%BC%EC%9A%94-%EA%B5%AC%EC%84%B1-%EC%9A%94%EC%86%8C&quot; aria-label=&quot;브라우저의 주요 구성 요소 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;브라우저의 주요 구성 요소&lt;/h2&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/browser_components.png&quot; alt=&quot;Browser components&quot;&gt;
    &lt;figcaption&gt;https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;유저 인터페이스&lt;/strong&gt;: 주소창, 북마크바, 앞/뒤로 가기 버튼 등 사이트 화면이 나오는 곳을 제외한 부분.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;브라우저 엔진&lt;/strong&gt;: UI와 렌더링 엔진을 제어.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;렌더링 엔진&lt;/strong&gt;: 요청한 내용(content)을 보여주는 역할을 함. 예를 들어, 요청한 내용이 HTML이라면 HTML(과 CSS)를 파싱하여 화면에 렌더링함.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;네트워크&lt;/strong&gt;: HTTP 통신과 같은 네트워크 요청을 처리.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI 백엔드&lt;/strong&gt;: 드랍다운 메뉴와 같이 기본적인 위젯을 그림.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;자바스크립트 엔진&lt;/strong&gt;: 자바스크립트를 분석하고 실행하는데 사용.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;데이터 저장소&lt;/strong&gt;: 쿠키, localStorage, IndexedDB와 같은 데이터를 저장.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;브라우저의-여정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98-%EC%97%AC%EC%A0%95&quot; aria-label=&quot;브라우저의 여정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;브라우저의 여정&lt;/h2&gt;
&lt;p&gt;브라우저 주소창에 &lt;a href=&quot;https://www.google.com&quot;&gt;www.google.com&lt;/a&gt;을 치면 어떤 일이 일어나는지를 살펴보자.&lt;/p&gt;
&lt;h3 id=&quot;네비게이션&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%84%A4%EB%B9%84%EA%B2%8C%EC%9D%B4%EC%85%98&quot; aria-label=&quot;네비게이션 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;네비게이션&lt;/h3&gt;
&lt;p&gt;우선 첫 번째로 일어나는 일은, 올바른 장소를 찾아가는(navigate) 것이다. 특정 웹 페이지를 찾아간다는 말은 해당 페이지에 대한 데이터(asset)가 어디에 있는지를 찾아낸다는 의미이다.&lt;/p&gt;
&lt;h4 id=&quot;dns-lookup&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#dns-lookup&quot; aria-label=&quot;dns lookup permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;DNS LOOKUP&lt;/h4&gt;
&lt;p&gt;사람한테 웹 페이지란 google.com과 같은 &lt;strong&gt;도메인 이름&lt;/strong&gt;이지만, 컴퓨터는 오직 0과 1밖에 모르기 때문에 도메인 이름 “문자열”을 IP 주소로 변환한다. 이렇게 도메인 이름을 IP주소로 변환하는 과정을 &lt;strong&gt;DNS lookup&lt;/strong&gt; 이라고 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;www.google.com&lt;/code&gt; 도메인에 대한 DNS 과정을 간략하게 나타내면 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;우선 해당 도메인의 IP주소에 대한 캐시가 있는지 살펴본다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;제일 먼저 브라우저 캐시부터 살펴본다.&lt;/li&gt;
&lt;li&gt;브라우저 캐시가 없으면 (시스템 콜을 통해) OS캐시를 살펴본다.&lt;/li&gt;
&lt;li&gt;OS캐시도 없으면 라우터와 통신하여 라우터 캐시를 살펴본다.&lt;/li&gt;
&lt;li&gt;만약 라우터 캐시도 없으면 ISP의 DNS 서버에 있는 ISP 캐시를 살펴본다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;만약 캐시를 발견하지 못했다면 DNS resolver에게 요청하여 도메인(URL)에 대한 IP 주소를 얻는다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;우선 resolver가 DNS root 네임서버 (.) 에게 요청한다.&lt;/li&gt;
&lt;li&gt;root nameserver는 .com, .net과 같은 TLD DNS 네임서버의 주소를 반환한다. www.google.com을 검색하는 경우, .com TLD DNS 네임서버 주소를 반환하게 될 것이다.&lt;/li&gt;
&lt;li&gt;resolver는 이제 TLD 네임서버에게 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;TLD 네임서버는 authoritative 네임서버(도메인 네임서버)의 주소를 반환한다. www.google.com의 경우, google.com 네임서버의 주소를 반환하게 될 것이다.&lt;/li&gt;
&lt;li&gt;resolver는 마지막으로 authoritative 네임서버에게 요청을 보낸다.&lt;/li&gt;
&lt;li&gt;authoritative 네임서버는 요청받은 URL의 IP주소를 반환한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;실제로 각 레이어마다 캐시를 사용하기 때문에 이 과정은 매우 빠르게 일어난다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/dns_lookup.png&quot; alt=&quot;dns_lookup&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://www.cloudflare.com/learning/dns/what-is-dns/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id=&quot;tcp-handshake&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tcp-handshake&quot; aria-label=&quot;tcp handshake permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TCP HANDSHAKE&lt;/h4&gt;
&lt;p&gt;이제 IP 주소를 알아냈으니, 브라우저는 IP 주소에 해당하는 서버와 통신할 준비를 한다. 이 때 서버와 연결을 하기위해 사용되는 프로토콜에는 여러 종류가 있지만, HTTP 요청에는 주로 TCP가 사용된다.&lt;/p&gt;
&lt;p&gt;브라우저는 TCP 3-way handshake를 통해 IP 주소에 해당하는 서버와 연결을 한다. 대략적인 과정은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트(브라우저)가 서버에게 새로운 연결을 요청하기 위해 SYN 패킷을 보낸다.&lt;/li&gt;
&lt;li&gt;서버가 새로운 연결을 할 수 있는 상태라면, SYN/ACK 패킷을 클라이언트로 보내 SYN 패킷에 대한 응답을 한다.&lt;/li&gt;
&lt;li&gt;마지막으로, 클라이언트는 SYN/ACK에 대한 응답으로 ACK 패킷을 서버로 보낸다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이제 브라우저와 서버끼리 데이터를 주고받을 준비를 마쳤다 (아마도?).&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/three_way_handshake.png&quot; alt=&quot;three_way_handshake&quot; width=&quot;600px&quot;&gt;
&lt;/figure&gt;
&lt;h4 id=&quot;tls-negotiation&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tls-negotiation&quot; aria-label=&quot;tls negotiation permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TLS NEGOTIATION&lt;/h4&gt;
&lt;p&gt;HTTPS 프로토콜을 사용하는 경우, 서버와 통신을 하기위해 한 가지 과정을 더 거쳐야 한다. HTTPS는 TLS(SSL)을 사용하여 일반적인 HTTP 요청/응답을 암화하 하는 프로토콜이다.&lt;/p&gt;
&lt;p&gt;HTTPS를 사용하여 안전한 통신을 하기 위해선 또 다른 handshake 과정을 수행해야만 한다. TLS handshake (TLS negotiation) 과정에선 다음의 일들이 발생한다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;어떤 TLS 버전(TLS 1.0, 1.2, 1.3, etc.)를 사용할 것인가를 결정&lt;/li&gt;
&lt;li&gt;어떤 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cipher_suite#:~:text=A%20cipher%20suite%20is%20a,help%20secure%20a%20network%20connection.&amp;#x26;text=The%20key%20exchange%20algorithm%20is,encrypt%20the%20data%20being%20sent.&quot;&gt;cipher suite&lt;/a&gt;를 사용할 것인가를 결정&lt;/li&gt;
&lt;li&gt;서버의 공개키(public key)와 SSL certificate의 전자 서명을 통해 서버의 신원을 인증&lt;/li&gt;
&lt;li&gt;handshake 이후 &lt;a href=&quot;https://www.cryptomathic.com/news-events/blog/symmetric-key-encryption-why-where-and-how-its-used-in-banking#:~:text=Symmetric%20encryption%20is%20a%20type,encrypt%20and%20decrypt%20electronic%20information.&amp;#x26;text=This%20encryption%20method%20differs%20from,to%20encrypt%20and%20decrypt%20messages.&quot;&gt;symmetric encryption&lt;/a&gt;를 사용하기 위해 세션키를 생성&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TLS handshake가 일어나는 과정은 추후에 따로 살펴보자.&lt;/p&gt;
&lt;h3 id=&quot;fetching&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#fetching&quot; aria-label=&quot;fetching permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Fetching&lt;/h3&gt;
&lt;p&gt;이제 TCP 연결도 마쳤고 (HTTPS의 경우) TLS 설정도 마쳤으니 브라우저는 HTTP 프로토콜을 이용하여 서버로부터 HTML 파일을 받는다.&lt;/p&gt;
&lt;h4 id=&quot;http-request&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#http-request&quot; aria-label=&quot;http request permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HTTP REQUEST&lt;/h4&gt;
&lt;p&gt;페이지를 가져오기 위해 &lt;a href=&quot;https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation&quot;&gt;idempotent&lt;/a&gt; (간단히 말하자면, 같은 입력에 대해선 항상 같은 출력이 나온다는 뜻)한 요청을 보낸다. 이 때 HTTP의 &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 메소드를 사용한다.&lt;/p&gt;
&lt;p&gt;HTTP &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt; 메소드를 간단히 말하자면, 주어진 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_Resource_Identifier&quot;&gt;URI&lt;/a&gt;가 가리키는 서버의 데이터를 요청하는 것이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;HTTP &lt;code class=&quot;language-text&quot;&gt;GET&lt;/code&gt;을 사용하면 다음과 같이 서버에게 &lt;code class=&quot;language-text&quot;&gt;HTTP REQUEST&lt;/code&gt;를 보낸다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;GET / HTTP/2
Host: www.google.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-GB,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Cache-Control: max-age=0
TE: Trailers&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 요청을 받은 서버는 요청과 관련된 헤더와 데이터를 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;HTTP RESPONSE&lt;/code&gt; 형식으로 응답한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;HTTP/2 200 OK
date: Sun, 18 Jul 2021 00:26:11 GMT
expires: -1
cache-control: private, max-age=0
content-type: text/html; charset=UTF-8
strict-transport-security: max-age=31536000
content-encoding: br
server: gws
content-length: 37418
x-xss-protection: 0
x-frame-options: SAMEORIGIN
domain=www.google.com
priority=high
X-Firefox-Spdy: h2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 때 HTML 문서의 소스코드는 response의 body에 포함되어 전달된다.&lt;/p&gt;
&lt;p&gt;더 많은 HTTP 메소드에 대해선 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc7231#section-8.1.3&quot;&gt;RFC7231 Section 8.1.3&lt;/a&gt;을 참고하길 바란다.&lt;/p&gt;
&lt;p&gt;&gt; 2부에 계속…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[브라우저는 어떻게 동작하는가? Part2]]></title><description><![CDATA[1편 Critical Rendering Path 브라우저가 HTML, CSS, JS 파일들을 분석하여 화면의 픽셀로 변환하는 과정을 Critical Rendering Path, CRP…]]></description><link>https://jaehyeon48.github.io/web/how_browsers_work_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/web/how_browsers_work_2/</guid><pubDate>Sat, 29 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../how_browsers_work_1&quot;&gt;1편&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;critical-rendering-path&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#critical-rendering-path&quot; aria-label=&quot;critical rendering path permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Critical Rendering Path&lt;/h2&gt;
&lt;p&gt;브라우저가 HTML, CSS, JS 파일들을 분석하여 화면의 픽셀로 변환하는 과정을 &lt;strong&gt;Critical Rendering Path, CRP&lt;/strong&gt;라고 한다. 이 포스트에서는 브라우저가 서버로 부터 응답을 받은 이후 CRP를 진행하는 과정을 살펴보자.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/crp.png&quot; alt=&quot;Critical Rendering Path&quot;&gt;
    &lt;figcaption&gt;Critical Rendering Path&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;파싱&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8C%8C%EC%8B%B1&quot; aria-label=&quot;파싱 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;파싱&lt;/h2&gt;
&lt;h3 id=&quot;dom&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#dom&quot; aria-label=&quot;dom permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;DOM&lt;/h3&gt;
&lt;p&gt;버로 부터 응답으로 HTML 데이터를 받으면 브라우저는 해당 HTML을 분석하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;으로 변환한다.&lt;/p&gt;
&lt;p&gt;여기서 DOM이란, HTML (혹은 XML) 문서를 트리 구조로 나타낸 것임과 동시에 프로그래밍 언어로 문서를 조작할 수 있도록 하는 API 이다. 이 때 트리의 각 노드는 문서의 각 요소들을 나타내는 객체이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dom.spec.whatwg.org/#ref-for-dom-node-nodetype%E2%91%A0&quot;&gt;DOM 스펙&lt;/a&gt;에 따르면, 노드의 종류는 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.ELEMENT_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.TEXT_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.CDATA_SECTION_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.PROCESSING_INSTRUCTION_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.COMMENT_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.DOCUMENT_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.DOCUMENT_TYPE_NODE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Node.DOCUMENT_FRAGMENT_NODE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;p&gt;서버로 부터 받은 HTML 데이터를 DOM으로 변환하는 과정을 간략히 살펴보면 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Conversion&lt;/strong&gt;: 서버로 부터 전송받은 HTML 2진 데이터를 파일에 명시된 인코딩 방법(UTF-8 등)을 통해 문자열로 변환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tokenizing&lt;/strong&gt;: 문자열로 변환된 HTML을 &lt;a href=&quot;https://html.spec.whatwg.org/#tokenization&quot;&gt;HTML 스펙&lt;/a&gt;에 따라 (&lt;code class=&quot;language-text&quot;&gt;&amp;lt;html&gt;&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt;와 같은) 토큰들로 분리한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Lexing&lt;/strong&gt;: 토큰들을 각각의 속성들과 규칙들을 갖는 객체로 변환한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DOM Construction&lt;/strong&gt;: Lexing을 통해 만들어낸 객체들을 이용하여 HTML 문서를 나타내는 트리 구조를 만들어 낸다. 트리 구조로 만드는 이유는, HTML이 기본적으로 서로 다른 태그간의 관계를 정의하고 있기 때문이다 (예를 들면 어떤 태그가 다른 태그 내부에 nested 되어 있는 것처럼).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이렇게 만들어진 DOM을 기반으로 브라우저는 렌더링을 해나간다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/dom_construction.png&quot; alt=&quot;A process of DOM construction&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;cssom&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cssom&quot; aria-label=&quot;cssom permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CSSOM&lt;/h3&gt;
&lt;p&gt;CSS 파일에 대해서도 HTML과 마찬가지로 파싱해서 트리 구조를 만든다. 이렇게 만들어진 CSS를 나타내는 트리 구조를 CSS Object Model, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Performance/Critical_rendering_path#css_object_model&quot;&gt;CSSOM&lt;/a&gt; 이라고 한다.&lt;/p&gt;
&lt;p&gt;CSSOM의 각 노드는 해당 노드가 타겟으로 삼고있는 DOM 요소의 스타일 정보를 갖는다. CSSOM도 트리 구조인 이유는, CSS의 “Cascading”한 특성 때문이다.&lt;/p&gt;
&lt;p&gt;페이지의 어떤 요소에 적용할 최종 스타일을 계산할 때, 브라우저는 우선 해당 노드에 적용가능한 가장 일반적인 규칙에서 시작하여 점점 specific한 규칙을 적용해 나간다. 예를 들면, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt; 요소 내부의 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;p&gt;&lt;/code&gt; 요소에 대해 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt; 요소의 규칙부터 적용하고 이후 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;p&gt;&lt;/code&gt; 요소의 규칙으로 덮어씌우는 방식이다.&lt;/p&gt;
&lt;p&gt;또한, 브라우저 마다 기본적으로 제공되는 &lt;strong&gt;user agent stylesheet&lt;/strong&gt;라는 것도 존재한다. 제일 처음에는 브라우저에서 제공하는 이 규칙을 적용하고, 개발자가 작성한 스타일을 적용해나가는 방식으로 진행된다. 만약 user agent stylesheet에도 없는 CSS 속성의 경우, &lt;a href=&quot;https://www.w3.org/Style/CSS/&quot;&gt;W3C CSS&lt;/a&gt; 스탠다드에 정의된 기본 속성값이 적용된다.&lt;/p&gt;
&lt;p&gt;여담으로, 더 간결한(less specific) CSS selector는 더 자세한(more specific) selector보다 빠르다. 예를 들어 &lt;code class=&quot;language-text&quot;&gt;.foo {}&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;.bar .foo {}&lt;/code&gt;보다 빠른데, 그 이유는 브라우저가 두 번째 경우의 &lt;code class=&quot;language-text&quot;&gt;.foo&lt;/code&gt;를 만나게 되면 DOM을 통해 부모 요소로 올라가서 &lt;code class=&quot;language-text&quot;&gt;.foo&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;.bar&lt;/code&gt;를 조상으로 갖는지 살펴봐야 하기 때문이다. 이렇듯 selector가 자세할 수록, 즉 CSS specificity가 높을 수록 브라우저가 할 일이 많아지지만, 사실 차이가 그리 크지는 않기 때문에 딱히 최적화할 가치는 없다고 할 수 있다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/cssom.png&quot; alt=&quot;A CSSOM&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;render-tree&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#render-tree&quot; aria-label=&quot;render tree permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Render Tree&lt;/h3&gt;
&lt;p&gt;이제 DOM과 CSSOM을 만들었으니, 이 둘을 합쳐서 &lt;strong&gt;Render Tree&lt;/strong&gt;를 만든다. 브라우저는 이렇게 DOM과 CSSOM을 합쳐 render tree를 만든 다음, 이후에 이 render tree를 바탕으로 visible한 요소들을 배치하고 화면에 이 요소들의 픽셀을 그리게 된다.&lt;/p&gt;
&lt;p&gt;일반적으로 다음과 같은 과정을 거쳐 render tree를 구축한다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;DOM의 루트부터 시작하여 &lt;strong&gt;visible&lt;/strong&gt;한 각 요소를 탐색해 나간다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;head&gt;&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;script&gt;&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;&amp;lt;link&gt;&lt;/code&gt;와 같이 화면에 보이지 않는 요소들은 무시된다. 왜냐면 말그대로 화면에 보이지 않기 때문에 렌더링할 필요가 없기 때문이다.&lt;/li&gt;
&lt;li&gt;또한, &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt; 속성이 적용된 요소와 그 자식들도 화면상에서 아무런 공간을 차지하지 않기 때문이 무시된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;visibility: hidden&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;opacity: 0&lt;/code&gt; 속성이 적용된 요소의 경우는, 화면에 보이지는 않지만 공간을 차지하기 때문에 render tree에 포함된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;::before&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;::after&lt;/code&gt;와 같은 CSS pseudo 클래스의 경우, DOM에는 존재하지 않지만 화면에 나타나기 때문에 render tree에 추가된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;각 visible한 요소에 대해 적절한 CSSOM 규칙을 찾아 적용한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/render_tree.png&quot; alt=&quot;A Render Tree&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;layout-reflow&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#layout-reflow&quot; aria-label=&quot;layout reflow permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Layout (Reflow)&lt;/h3&gt;
&lt;p&gt;레이아웃 단계는 render tree를 기반으로 &lt;a href=&quot;https://web.dev/responsive-web-design-basics/#set-the-viewport&quot;&gt;viewport&lt;/a&gt; 내에서의 각 요소의 위치, 크기등을 계산하는 단계이다. 각 요소의 정확한 크기와 위치를 계산하기 위해, 브라우저는 render tree의 루트부터 시작해나간다. 다음 HTML을 예시로 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;html&quot;&gt;&lt;pre class=&quot;language-html&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&lt;span class=&quot;token doctype&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;!&lt;/span&gt;&lt;span class=&quot;token doctype-tag&quot;&gt;DOCTYPE&lt;/span&gt; &lt;span class=&quot;token name&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;meta&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;viewport&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;width=device-width,initial-scale=1&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;/&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;title&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Critial Path: Hello world!&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;title&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;head&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value css language-css&quot;&gt;&lt;span class=&quot;token property&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 50%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;div&lt;/span&gt; &lt;span class=&quot;token special-attr&quot;&gt;&lt;span class=&quot;token attr-name&quot;&gt;style&lt;/span&gt;&lt;span class=&quot;token attr-value&quot;&gt;&lt;span class=&quot;token punctuation attr-equals&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;token value css language-css&quot;&gt;&lt;span class=&quot;token property&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; 50%&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;Hello world!&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;div&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;body&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token tag&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;/&lt;/span&gt;html&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 HTML의 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;body&gt;&lt;/code&gt;에는 두 개의 중첩 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&gt;&lt;/code&gt;가 있다. 첫 번째(부모) &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&gt;&lt;/code&gt;는 viewport width의 50%가 적용되고, 두 번째(자식) &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&gt;&lt;/code&gt;의 width는 부모 (첫 번째 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&gt;&lt;/code&gt;) width의 50%가 적용된다. 즉, viewport width의 25%가 적용된다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/layout_example.png&quot; alt=&quot;Layout process example&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;레이아웃 과정의 결과는 viewport 내에서의 각 요소들의 정확한 위치와 크기를 적용한 &lt;strong&gt;박스 모델&lt;/strong&gt;이다. &lt;code class=&quot;language-text&quot;&gt;%&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;em&lt;/code&gt; 등과 같은 모든 상대 치수(measurement)는 절대 단위인 픽셀로 변환된다.&lt;/p&gt;
&lt;p&gt;웹 페이지의 레이아웃을 결정하는 것은 어려운 작업이다. 가장 단순하게 위에서 아래로 펼쳐지는 블록 영역 하나만 있는 웹 페이지의 레이아웃을 결정할 때에도 폰트의 크기가 얼마이고 줄 바꿈을 어디서 해야 하는지 고려해야 한다. 단락의 크기와 모양이 바뀔 수 있고, 다음 단락의 위치에 영향이 있기 때문이다.&lt;/p&gt;
&lt;p&gt;레이아웃 단계를 거치고 나면 &lt;strong&gt;레이아웃 트리&lt;/strong&gt;가 만들어진다. 이 트리에는 요소들의 x, y좌표, 박스 영역(bounding box)의 크기와 같은 정보를 가지고 있다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/layout_tree.png&quot; alt=&quot;A layout tree&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;Layout tree: https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h4 id=&quot;dirty-bit-system&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#dirty-bit-system&quot; aria-label=&quot;dirty bit system permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;DIRTY BIT SYSTEM&lt;/h4&gt;
&lt;p&gt;작은 변화에도 전체 요소의 레이아웃을 다시 계산하는 것은 너무 비효율적이므로, 브라우저들은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirty_bit&quot;&gt;dirty bit&lt;/a&gt;를 사용하여 변경사항이 있는 요소와 그 자식 요소들만 dirty bit로 체킹하여 dirty bit로 체킹된 요소들만 다시 계산한다.&lt;/p&gt;
&lt;p&gt;레이아웃 과정을 &lt;strong&gt;reflow&lt;/strong&gt;, 혹은 &lt;strong&gt;browser reflow&lt;/strong&gt;라고도 한다. 화면을 스크롤 하거나, 화면을 줄이거나 늘리는 등 크기를 바꾸거나, DOM을 조작하는 등의 행동을 할때 reflow 과정이 일어난다. &lt;a href=&quot;https://stackoverflow.com/questions/27637184/what-is-dom-reflow/27637245#27637245&quot;&gt;이 리스트&lt;/a&gt;에 레이아웃 과정을 발생시키는(trigger) 이벤트들이 나와있다.&lt;/p&gt;
&lt;h3 id=&quot;paint&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#paint&quot; aria-label=&quot;paint permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Paint&lt;/h3&gt;
&lt;p&gt;이제 DOM, 스타일, 레이아웃을 알고있지만 이것만으로는 여전히 페이지를 렌더링할 수 없다. 예를 들어, 어떤 그림을 따라 그리려 한다고 해보자. 그림의 크기, 모양, 각 요소의 위치를 알고있지만 &lt;strong&gt;어떤 순서&lt;/strong&gt;로 그림을 그려야할 지 판단해야 한다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/paint_example.png&quot; alt=&quot;Drawing Game&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;예를 들어, &lt;code class=&quot;language-text&quot;&gt;z-index&lt;/code&gt; 속성이 적용된 요소의 경우, HTML에 나타난 요소의 순서대로 렌더링하게되면 부정확한 결과가 나오게 될 것이다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/z_index_fail.png&quot; alt=&quot;z-index fail&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;위 그림에서는 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;h1&gt;&lt;/code&gt; 요소가 &lt;code class=&quot;language-text&quot;&gt;&amp;lt;div&gt;&lt;/code&gt; 요소보다 위에 와야 정확하게 렌더링한 것이다. 이러한 경우와 같이, DOM에 선언된 노드 순서와 페인트 순서는 다를 수 있다.&lt;/p&gt;
&lt;p&gt;페인트 단계에서 브라우저의 메인 스레드는 render tree를 순회하여 paint record를 생성한다. Paint record는 “배경을 먼저 그리고, 그 다음 텍스트, 그리고 나서 직사각형”과 같이 페인팅 과정을 기록한 일종의 노트이다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/paint_record.png&quot; alt=&quot;A paint record&quot;&gt;
    &lt;figcaption&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;합성compositioning&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%A9%EC%84%B1compositioning&quot; aria-label=&quot;합성compositioning permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;합성(Compositioning)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;💡&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;페인트(paint)는 페인트 단계에서 페인트 작업을 수행하는 것을 의미하고, 그리기(draw)는 페인트 작업을 기반으로 비트맵 혹은 텍스처를 만들어 내는 것을 의미한다. 좀 더 정확히 말하자면, &lt;strong&gt;합성 프레임(compositing frame)&lt;/strong&gt;을 만들어 내는 것을 의미한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;이제 브라우저는 문서의 구조, 각 요소의 스타일과 위치/크기 및 paint 순서를 알고있는 상태이다. 이제 이러한 정보들을 가지고 어떻게 페이지를 그릴까? 이러한 정보들을 화면의 픽셀로 변환하는 작업을 &lt;strong&gt;래스터화(rasterization)&lt;/strong&gt; 라고 한다.&lt;/p&gt;
&lt;p&gt;가장 단순한 rasterization은 (아마도) viewport 내의 부분들을 rasterize 하는 것이다. 사용자가 페이지를 스크롤하면 이미 rasterize한 프레임을 움직이고 나머지 빈 부분을 추가로 rasterize한다. 이 방법은 크롬 브라우저가 초창기에 수행했던 방법이다. 하지만 대부분의 요즘 브라우저들은 &lt;strong&gt;합성(compositioning)&lt;/strong&gt;이라는 좀 더 정교한 과정을 수행한다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/naive_raster.gif&quot; alt=&quot;A naive raster process&quot;&gt;
    &lt;figcaption&gt;Animation of naive rastering process: https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;br /&gt;
&lt;p&gt;&lt;strong&gt;합성(compositioning)&lt;/strong&gt;이란 웹 페이지의 각 부분들을 레이어(layer)로 분리하여, 각 레이어들을 따로 raster한 다음 compositor 쓰레드에서 이 레이어들을 하나의 페이지로 합성하는 기술이다. 페이지를 스크롤해도 이미 레이어가 rasterize 되어 있기 때문에 새로운 프레임을 합성하기만 하면 된다. (CSS의) 에니메이션 또한 레이어를 움직이고 새로운 프레임으로 합성하는 방식으로 만들 수 있다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/composit.gif&quot; alt=&quot;A compositioning process&quot;&gt;
    &lt;figcaption&gt;Animation of compositing process: https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;크롬 개발자 도구의 &lt;a href=&quot;https://blog.logrocket.com/eliminate-content-repaints-with-the-new-layers-panel-in-chrome-e2c306d4d752?gi=cd6271834cea&quot;&gt;레이어 패널&lt;/a&gt;을 이용하여 웹사이트가 어떤 레이어들로 나뉘어 졌는지를 확인할 수 있다.&lt;/p&gt;
&lt;h4 id=&quot;레이어로-나누기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A0%88%EC%9D%B4%EC%96%B4%EB%A1%9C-%EB%82%98%EB%88%84%EA%B8%B0&quot; aria-label=&quot;레이어로 나누기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;레이어로 나누기&lt;/h4&gt;
&lt;p&gt;어떤 요소가 어떤 레이어에 위치하는지를 결정하기 위해, 메인 쓰레드는 레이아웃 트리를 순회하며 &lt;strong&gt;레이어 트리(layer tree)&lt;/strong&gt;를 만든다. 모든 요소별로 레이어를 할당하면 좋겠지만, 수 많은 레이어를 합성하는 작업은 웹 페이지의 작은 부분들을 매 프레임마다 새로 raster하는 것보다 더 오래 걸릴 수 있다. 따라서 애플리케이션의 성능을 측정하는 것이 중요하다. 이와 관련해서는 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count&quot;&gt;이 글&lt;/a&gt;을 참조하라.&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;레이어 트리가 완성되고 페인트 순서가 결정되면 메인 쓰레드는 이러한 정보들을 compositor 쓰레드로 넘긴다(commit). 그러면 compositor 쓰레드는 각 레이어를 rasterize 한다. 어떤 레이어의 크기는 페이지의 전체 길이만큼 길 수 있기 때문에, compositor 쓰레드는 레이어를 타일(tile)로 쪼개어 각 타일들을 raster 쓰레드로 보낸다. Raster 쓰레드에서는 각 타일을 rasterize 하여 GPU 메모리에 저장한다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/raster_thread.png&quot; alt=&quot;raster&quot;&gt;
    &lt;figcaption&gt;Raster threads creating the bitmap of tiles and sending to GPU: https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;💡&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;rasterize 역시 GPU의 도움을 받기 좋은 단계이다. 이와 관련한 더 자세한 내용은 &lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/articles/software-vs-gpu-rasterization-in-chromium.html&quot;&gt;Software vs. GPU Rasterization in Chromium&lt;/a&gt;을 참고하라.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;💡&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;compositor 쓰레드 내부에도 레이어 트리가 여러개 있다. 메인 쓰레드가 넘긴(commit) 레이어 트리는 compositor 쓰레드의 &lt;strong&gt;pending tree&lt;/strong&gt;로 복사된다. Pending tree는 최신 프레임이지만 아직 화면에는 그려지지 않은 상태이다. 현재 화면에 그려지고 있는 이전 프레임은 &lt;strong&gt;active tree&lt;/strong&gt;로 그린 프레임이다. 최신 정보로 화면을 갱신할 때는 pending tree와 active tree를 스왑한다. 이와 관련한 더 자세한 내용은 &lt;a href=&quot;https://software.intel.com/content/www/us/en/develop/articles/native-one-copy-texture-uploads-for-chrome-os-on-intel-architecture-enabled-by-default.html&quot;&gt;Native One-copy Texture Uploads for Chrome OS…&lt;/a&gt;을 참고하라.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;compositor 쓰레드는 서로 다른 raster 쓰레드들간의 우선순위를 결정할 수 있다. 따라서 viewport 근처의 것들이 먼저 rasterize 될 수 있다. 또한, 레이어는 줌인, 줌아웃과 같은 동작을 처리하기 위해 해상도가 다른 여러 타일들을 가지고 있다.&lt;/p&gt;
&lt;p&gt;타일이 rasterize 되면 compositor 쓰레드는 &lt;strong&gt;합성 프레임(compositor frame)&lt;/strong&gt;을 만들기 위해 &lt;strong&gt;draw quads&lt;/strong&gt;이라고 하는, 타일의 정보들을 모은다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Draw quads&lt;/strong&gt;: 메모리 상에서의 타일의 위치, 페이지 합성을 고려하여 타일을 웹 페이지의 어디에 그릴 것인지와 같은 정보들을 담고있다.  해상도별 타일 세트에서 타일을 선택적으로 조합하기 때문에, draw quads가 조합에 필요한 정보를 기억해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Compositor frame&lt;/strong&gt;: 한 페이지의 프레임을 나타내는 draw quads의 모음이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이후 compositor frame은 IPC을 통해 브라우저 프로세스로 넘겨진다. 이 때 브라우저 UI의 변경 사항을 반영하려는 UI 쓰레드나 확장 앱을 위한 다른 renderer 프로세스에 의해 compositor frame이 추가될 수 있다.&lt;/p&gt;
&lt;p&gt;이렇게 브라우저 프로세스로 넘어온 프레임들은 화면에 출력하기 위해 GPU로 보내진다. 스크롤이 발생하면 compositor 쓰레드는 GPU로 보낼 또 다른 프레임을 만든다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;💡&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;(2019년 4월 기준) 앞으로는 compositor frame이 브라우저 프로세스를 거치지 않고 바로 GPU 프로세스로 보내지는 방식으로 변경될 예정이라고 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/web/how_browsers_work/composit.png&quot; alt=&quot;composit&quot;&gt;
    &lt;figcaption&gt;Compositor thread creating compositing frame. Frame is sent to the browser process then to GPU: https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;합성(compositioning)의 장점은 메인 쓰레드와 별개로 동작한다는 점이다. Compositor 쓰레드는 메인 쓰레드가 스타일(CSS) 계산, 혹은 자바스크립트 실행을 끝마칠 때까지 기다릴 필요가 없다. 이 때문에 &lt;a href=&quot;https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/&quot;&gt;합성만 하는 애니메이션&lt;/a&gt;이 성능상 가장 부드럽다고 한다. 레이아웃이나 페인트를 다시 계산해야하는 경우, 메인 쓰레드가 관여해야만 한다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.to/gitpaulo/journey-of-a-web-page-how-browsers-work-10co&quot;&gt;https://dev.to/gitpaulo/journey-of-a-web-page-how-browsers-work-10co&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path&quot;&gt;https://developers.google.com/web/fundamentals/performance/critical-rendering-path&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part1&quot;&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part2&quot;&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/updates/2018/09/inside-browser-part3&quot;&gt;https://developers.google.com/web/updates/2018/09/inside-browser-part3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969&quot;&gt;https://medium.com/jspoint/how-the-browser-renders-a-web-page-dom-cssom-and-rendering-df10531c9969&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/5237120&quot;&gt;https://d2.naver.com/helloworld/5237120&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a&quot;&gt;https://medium.com/@maneesha.wijesinghe1/what-happens-when-you-type-an-url-in-the-browser-and-press-enter-bb0aa2449c1a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/learning/dns/what-is-dns/&quot;&gt;https://www.cloudflare.com/learning/dns/what-is-dns/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&quot;&gt;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.html5rocks.com/en/tutorials/speed/layers/&quot;&gt;https://www.html5rocks.com/en/tutorials/speed/layers/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Git Pro 2nd Edition 요약 Part2]]></title><description><![CDATA[원문 1편 Git Repository 생성 일반적으로 Git repository를 생성하는 데에는 크게 두 가지 방법이 존재한다: 아직 VCS로 관리되고 있지 않은 로컬 디렉토리를 Git repository로 변경. 외부의 Git repository…]]></description><link>https://jaehyeon48.github.io/git/git_pro_summary_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/git/git_pro_summary_2/</guid><pubDate>Fri, 28 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;원문&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../git_pro_summary_1&quot;&gt;1편&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;git-repository-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#git-repository-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;git repository 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Git Repository 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;일반적으로 Git repository를 생성하는 데에는 크게 두 가지 방법이 존재한다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;아직 VCS로 관리되고 있지 않은 로컬 디렉토리를 Git repository로 변경.&lt;/li&gt;
&lt;li&gt;외부의 Git repository를 &lt;code class=&quot;language-text&quot;&gt;clone&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;기존에-존재하는-디렉토리를-git-repository로-초기화&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B8%B0%EC%A1%B4%EC%97%90-%EC%A1%B4%EC%9E%AC%ED%95%98%EB%8A%94-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-git-repository%EB%A1%9C-%EC%B4%88%EA%B8%B0%ED%99%94&quot; aria-label=&quot;기존에 존재하는 디렉토리를 git repository로 초기화 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;기존에 존재하는 디렉토리를 Git repository로 초기화&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;우선, CLI를 통해 Git repository로 초기화하고자 하는 디렉토리로 이동하여 다음 명령어를 입력:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sh&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;git init&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;위 명령을 입력하면 &lt;code class=&quot;language-text&quot;&gt;.git&lt;/code&gt; 이라는 하위 디렉토리를 생성. 이 하위 디렉토리에는 저장소에 필요한 모든 파일들이 저장됨.&lt;/li&gt;
&lt;li&gt;Git으로 하여금 파일을 관리하도록 하고 싶다면 우선 &lt;code class=&quot;language-text&quot;&gt;git add&lt;/code&gt; 명령어를 통해 파일을 tracking하고, &lt;code class=&quot;language-text&quot;&gt;git commit&lt;/code&gt; 명령어를 통해 파일을 커밋해야함.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;cloning-하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cloning-%ED%95%98%EA%B8%B0&quot; aria-label=&quot;cloning 하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Cloning 하기&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;오픈소스 저장소와 같이 기존에 존재하는 Git repository를 복사하고 싶다면 &lt;code class=&quot;language-text&quot;&gt;git clone&lt;/code&gt; 명령어를 이용.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;git clone&lt;/code&gt;을 사용하게 되면 해당 프로젝트의 히스토리를 “전부” 받아옴.&lt;/li&gt;
&lt;li&gt;저장소를 복제할 땐 &lt;code class=&quot;language-text&quot;&gt;git clone &amp;lt;url&gt;&lt;/code&gt;과 같은 방식으로 수행:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sh&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ git clone https://github.com/libgit2/libgit2&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;위 명령을 수행하면 &lt;code class=&quot;language-text&quot;&gt;libgit2&lt;/code&gt;라는 디렉토리를 만들어서, &lt;code class=&quot;language-text&quot;&gt;.git&lt;/code&gt; 하위 디렉토리를 생성하고 저장소의 모든 데이터를 &lt;code class=&quot;language-text&quot;&gt;.git&lt;/code&gt;에 저장한 후 최신 버전을 check out함.&lt;/li&gt;
&lt;li&gt;이 때, 생성되는 디렉토리의 이름을 &lt;code class=&quot;language-text&quot;&gt;libgit2&lt;/code&gt; 대신 다른 이름으로 하고 싶다면 다음과 같이 해야함:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;sh&quot;&gt;&lt;pre class=&quot;language-sh&quot;&gt;&lt;code class=&quot;language-sh&quot;&gt;$ git clone https://github.com/libgit2/libgit2 mylibgit&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;위 명령을 수행하면 다른 모든 과정은 동일하지만 새로 생성되는 디렉토리의 이름이 &lt;code class=&quot;language-text&quot;&gt;mylibgit&lt;/code&gt;이 됨.&lt;/li&gt;
&lt;li&gt;위 예시에서는 &lt;code class=&quot;language-text&quot;&gt;https://&lt;/code&gt; 프로토콜을 사용했지만 이외에도 &lt;code class=&quot;language-text&quot;&gt;git://&lt;/code&gt;과 같이 다양한 프로토콜을 사용할 수도 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;저장소에-변경사항-기록하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%80%EC%9E%A5%EC%86%8C%EC%97%90-%EB%B3%80%EA%B2%BD%EC%82%AC%ED%95%AD-%EA%B8%B0%EB%A1%9D%ED%95%98%EA%B8%B0&quot; aria-label=&quot;저장소에 변경사항 기록하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;저장소에 변경사항 기록하기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;현재 워킹 디렉토리에 있는 각 파일들은 &lt;code class=&quot;language-text&quot;&gt;tracked&lt;/code&gt;(관리대상) 상태이거나, 혹은 &lt;code class=&quot;language-text&quot;&gt;untracked&lt;/code&gt;(관리대상이 아님) 상태이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;tracked&lt;/code&gt; 파일은 이미 이전 스냅샷에 포함된 파일이며, &lt;code class=&quot;language-text&quot;&gt;unmodified&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;modified&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;staged&lt;/code&gt; 중 하나의 상태이다.&lt;/li&gt;
&lt;li&gt;이외의 파일은 모두 &lt;code class=&quot;language-text&quot;&gt;untracked&lt;/code&gt; 파일이다. 즉, 이전 스냅샷에도 없고 staging area에도 존재하지 않는 파일들은 &lt;code class=&quot;language-text&quot;&gt;untracked&lt;/code&gt; 상태이다.&lt;/li&gt;
&lt;li&gt;저장소를 처음 &lt;code class=&quot;language-text&quot;&gt;clone&lt;/code&gt;하고 나면 아직 수정한 파일이 없으므로 모든 파일이 &lt;code class=&quot;language-text&quot;&gt;unmodified&lt;/code&gt; 상태에 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/git/git_pro_summary_2/git_file_states.png&quot; alt=&quot;Git file states&quot;&gt;
    &lt;figcaption&gt;Git 파일 상태&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;마지막 커밋 이후 아직 아무런 수정도 하지 않은 상태에서 어떤 파일을 수정하게 되면 Git은 수정된 파일을 &lt;code class=&quot;language-text&quot;&gt;modified&lt;/code&gt;로 인식한다. 이 때 실제 커밋을 하기 위해선 이 수정한 파일을 staging area에 올려 &lt;code class=&quot;language-text&quot;&gt;staged&lt;/code&gt; 상태로 만들고, 커밋 명령을 통해 staging area에 있는 파일들을 커밋한다. Git을 사용하면 이러한 라이프 사이클을 계속해서 반복한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/lifecycle.png&quot; alt=&quot;The lifecycle of the status of your files&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control&lt;/figcaption&gt;
&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Git Pro 2nd Edition 요약 Part1]]></title><description><![CDATA[원문 2편 Chapter1. Getting Started…]]></description><link>https://jaehyeon48.github.io/git/git_pro_summary_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/git/git_pro_summary_1/</guid><pubDate>Thu, 27 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;원문&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../git_pro_summary_2&quot;&gt;2편&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h1 id=&quot;chapter1-getting-started&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#chapter1-getting-started&quot; aria-label=&quot;chapter1 getting started permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Chapter1. Getting Started&lt;/h1&gt;
&lt;h2 id=&quot;버전-컨트롤-이란&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B2%84%EC%A0%84-%EC%BB%A8%ED%8A%B8%EB%A1%A4-%EC%9D%B4%EB%9E%80&quot; aria-label=&quot;버전 컨트롤 이란 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;버전 컨트롤 이란?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;여러 파일들의 시간에 따른 변화들을 기록하여, 추후 해당 버전들로 돌아갈 수 있도록 관리하는 시스템. 이 때 버전 컨트롤 시스템으로 관리하는 파일들의 타입은 프로그래밍 파일뿐만이 아니라 어떠한 파일들도 될 수 있다.&lt;/li&gt;
&lt;li&gt;버전 컨트롤 시스템을 사용하여 파일들을 관리하면 특정 파일들만, 혹은 프로젝트 전체를 이전 버전(상태)으로 되돌아 갈 수 있고, 시간에 따른 변화를 비교할 수 있고, 여러 명이서 동시에 작업하는 경우 누가 어떤 이슈, 어떤 문제를 발생시켰는지 파악할 수 있음.&lt;/li&gt;
&lt;li&gt;즉, 프로젝트를 진행하다 무언가 잘못되면 (최소한의 비용으로) 이전 상태로 되돌아가 복구할 수 있음.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;local-vcs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#local-vcs&quot; aria-label=&quot;local vcs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Local VCS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;많은 사람들이 사용하는 흔한 방법으로, 파일들을 디렉토리에 나눠 버전을 관리하는 방법이 있는데 이 방법은 간편하긴 하지만 에러에 취약함.&lt;/li&gt;
&lt;li&gt;이러한 문제를 해결하기 위해, 프로그래머들은 오래전에 파일들의 모든 변경 사항을 저장하는 간단한 데이터베이스를 이용하여 로컬 VCS를 개발하였음.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/local.png&quot; alt=&quot;Local version control&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;centralized-vcs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#centralized-vcs&quot; aria-label=&quot;centralized vcs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Centralized VCS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;여러 개발자들끼리 협력해서 작업하기 위해 개발된 것이 중앙집중형 방식인 CVCS 이다.&lt;/li&gt;
&lt;li&gt;모든 버전 파일들이 하나의 중앙 서버에 저장되어 있고, 개발자들이 해당 서버에서 파일들을 가져오는 형식. 수년간 이 방식이 VCS의 표준이었음.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/centralized.png&quot; alt=&quot;Centralized version control&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;로컬 VCS보다 많은 장점을 가지고 있다. 예를 들면 프로젝트에 참여하는 모두가 다른 사람이 어느 작업을 하는지 알 수 있고, 관리자는 작업 분배를 수월하게 할 수 있음.&lt;/li&gt;
&lt;li&gt;하지만 단점도 존재하는데, 그 중 가장 심각한 단점은 중앙 집중형이다 보니 서버가 다운되면 아무도 작업을 진행할 수 없게됨. 만약 서버에 저장된 데이터가 날아가버린다면, 그리고 백업을 제대로 하지 않았다면 사람들이 로컬 컴퓨터에 가지고 있는 파일 이외의 데이터를 영영 복구할 수 없게됨.&lt;/li&gt;
&lt;li&gt;사실 이와 같은 문제는 로컬 VCS에서도 발생하는데, 프로젝트의 모든 데이터를 한 공간에 저장하면 모든것을 잃어버릴 수 있다는 리스크가 존재.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;distributed-vcs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#distributed-vcs&quot; aria-label=&quot;distributed vcs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Distributed VCS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CVCS의 단점을 보완하기 위해 개발된 방식. 단순히 서버로부터 파일의 스냅샷만 가져오는것이 아니라 히스토리 전체를 포함한 저장소를 통째로 로컬로 가져온다 (“미러링” 한다). 이렇게 가져온 데이터를 가지고 작업을 한 뒤 그 결과물을 다시 서버로 업로드 하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/distributed.png&quot; alt=&quot;Distributed version control&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-About-Version-Control&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;git이란-무엇인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#git%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;git이란 무엇인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Git이란 무엇인가?&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Git을 효율적으로 사용하기 위해선 Git의 동작 원리를 아는 것이 중요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;차이가-아니라-스냅샷&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%95%84%EB%8B%88%EB%9D%BC-%EC%8A%A4%EB%83%85%EC%83%B7&quot; aria-label=&quot;차이가 아니라 스냅샷 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;차이가 아니라 스냅샷&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Git 이외의 다른 시스템(CVS, Subversion, Perforce, Bazaar 등)들은 시간에 따른 파일의 “변화”를 기록. 이를 델타(Δ) 기반 버전 컨트롤 이라고도 함.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/deltas.png&quot; alt=&quot;Storing data as changes to a base version of each file&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;이와는 달리 Git은 특정 시점에서의 파일들의 “스냅샷”을 기록. 즉, 파일들의 변화된 부분만 기록하는 것이 아니라 변화된 파일 통째로 기록. 효율성을 위해 파일의 내용이 변경되지 않았다면 해당 파일을 새로 (중복되어) 저장하지 않고 이전에 이미 저장된 데이터를 가리키도록 링크를 생성.&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://git-scm.com/book/en/v2/images/snapshots.png&quot; alt=&quot;Storing data as changes to a base version of each file&quot; width=&quot;600px&quot;&gt;
    &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h3 id=&quot;거의-모든-동작이-로컬에서-일어난다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B1%B0%EC%9D%98-%EB%AA%A8%EB%93%A0-%EB%8F%99%EC%9E%91%EC%9D%B4-%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-%EC%9D%BC%EC%96%B4%EB%82%9C%EB%8B%A4&quot; aria-label=&quot;거의 모든 동작이 로컬에서 일어난다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;거의 모든 동작이 로컬에서 일어난다.&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Git을 사용하면 프로젝트 &lt;strong&gt;전체&lt;/strong&gt;의 히스토리가 로컬 컴퓨터에 저장되기 때문에 작업을 할 때 서버로부터, 혹은 다른 컴퓨터로부터 데이터를 받아올 필요가 없다.&lt;/li&gt;
&lt;li&gt;따라서 인터넷이 연결되지 않은 상황에서도 여전히 프로젝트에 대한 작업을 진행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;git의-무결성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#git%EC%9D%98-%EB%AC%B4%EA%B2%B0%EC%84%B1&quot; aria-label=&quot;git의 무결성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Git의 무결성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Git은 데이터를 저장하기 전 항상 체크섬을 구해서 이 체크섬으로 데이터를 관리한다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;체크섬을 만들때는 SHA-1 해시를 사용하여 파일의 내용 혹은 디렉토리의 구조를 바탕으로 만든다. 이렇게 만들어진 체크섬은 40자 길이의 16진수 문자열이다. SHA-1은 아래와 같이 생겼다:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;24b9da6552252987aa493b52f8696cd6d3b00373&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;Git이 데이터베이스에 데이터를 저장할 때 파일 이름이 아니라 해당 해시값으로 저장하므로, 사실상 거의 모든곳에서 위 해시값을 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;세-가지-상태&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%B8-%EA%B0%80%EC%A7%80-%EC%83%81%ED%83%9C&quot; aria-label=&quot;세 가지 상태 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;세 가지 상태&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;추후 Git을 원활하게 학습하기 위해서 이 부분을 잘 알아야 한다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;파일들이 존재할 수 있는 상태가 Git에는 크게 세 가지가 있다: &lt;code class=&quot;language-text&quot;&gt;modified&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;staged&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;committed&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Modified&lt;/code&gt; 상태는 파일을 변경하였지만 아직 데이터베이스에 커밋하지 않은 상태를 뜻한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Staged&lt;/code&gt;는 현재 변경된 파일들 중 곧 커밋할 것이라고 표시한 상태를 뜻한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Committed&lt;/code&gt;는 로컬 데이터베이스에 데이터가 안전하게 저장된 상태를 뜻한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;위 세 가지 상태는 Git 프로젝트의 세 단계 &lt;code class=&quot;language-text&quot;&gt;Git 디렉토리&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;워킹 트리&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Staging Area&lt;/code&gt;와 연관되어 있다:&lt;/p&gt;
&lt;figure&gt;
  &lt;img src=&quot;https://git-scm.com/book/en/v2/images/areas.png&quot; alt=&quot;Working tree, staging area, and Git directory&quot; width=&quot;600px&quot;&gt;
  &lt;figcaption&gt;https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;워킹 트리(워킹 디렉토리)는 Git 디렉토리로 부터 꺼내와서 디스크에 올려져 있는 파일들이다. 프로젝트의 특정 버전을 check out한 것이다.&lt;/li&gt;
&lt;li&gt;Staging area는 일반적으로 Git 디렉토리 내에 위치하는 파일로 “index”라고도 한다. 다음 커밋에 어떤 파일들이 포함될 것인가에 대한 정보를 저장한다.&lt;/li&gt;
&lt;li&gt;Git 디렉토리는 프로젝트의 데이터/메타데이터가 저장되는 곳이다. Git에서 가장 중요한 부분이라 할 수 있으며 다른 컴퓨터(흔히 remote)에 있는 저장소를 &lt;code class=&quot;language-text&quot;&gt;clone&lt;/code&gt;하면 생성된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;흔히 Git을 사용할 때의 작업 흐름은 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;워킹 트리에 있는 파일을 수정한다.&lt;/li&gt;
&lt;li&gt;다음 커밋에 포함시킬 파일들을 선택적으로 골라 staging area에 추가한다.&lt;/li&gt;
&lt;li&gt;커밋을 하여 staging area에 있는 파일들의 스냅샷을 Git 디렉토리에 (영구적으로) 보관한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;어떤 파일의 특정 버전이 Git 디렉토리에 존재하면 해당 파일은 &lt;code class=&quot;language-text&quot;&gt;committed&lt;/code&gt; 상태이다. 파일을 수정하고 staging area에 추가했다면 해당 파일은 &lt;code class=&quot;language-text&quot;&gt;staged&lt;/code&gt; 상태이다. 그리고 check out한 이후 수정을 했지만 staging area에 올리지 않은 상태라면 해당 파일은 &lt;code class=&quot;language-text&quot;&gt;modified&lt;/code&gt; 상태이다. 추후 이러한 상태들에 대해 더 자세히 살펴볼 것이다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 클로저 Part2]]></title><description><![CDATA[이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 1편 보러가기 3편 보러가기 클로저를 활용하는 사례: AJAX…]]></description><link>https://jaehyeon48.github.io/javascript/closure_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/closure_2/</guid><pubDate>Sat, 22 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 아래의 원문을 번역/요약한 글입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&quot;&gt;You Don’t Know JS Yet/Chapter 7: Using Closures&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_1&quot;&gt;1편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_3&quot;&gt;3편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;클로저를-활용하는-사례-ajax와-이벤트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%8A%94-%EC%82%AC%EB%A1%80-ajax%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8&quot; aria-label=&quot;클로저를 활용하는 사례 ajax와 이벤트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저를 활용하는 사례: AJAX와 이벤트&lt;/h2&gt;
&lt;p&gt;클로저는 다음과 같이 주로 콜백을 사용하는 경우 맞닥뜨리게 된다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupStudentRecord&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;https://some.api/student/&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentID&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onRecord&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;record&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentID&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;lookupStudentRecord&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;114&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;Frank (114)&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;onRecord()&lt;/code&gt; 콜백은 미래의 어느 시점에 Ajax로 부터 응답이 오면 호출될 것이다. 물론 콜백이 호출되는 시점에선 &lt;code class=&quot;language-text&quot;&gt;lookupStudentRecord&lt;/code&gt;는 이미 종료되고 난 뒤일 것이다.&lt;/p&gt;
&lt;p&gt;그렇다면 콜백에서 어떻게 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;를 참조할 수 있는 것일까? 바로 클로저 덕분이다.&lt;/p&gt;
&lt;p&gt;이벤트 핸들러 또한 클로저를 활용하는 또 다른 사례 중 하나이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;listenForClicks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;btn&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; label&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;The &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt; label &lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; button was clicked!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; submitBtn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;submit-btn&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;listenForClicks&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;submitBtn&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Checkout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;label&lt;/code&gt; 변수는 이벤트 핸들러 &lt;code class=&quot;language-text&quot;&gt;onClick()&lt;/code&gt; 함수에 의해 에워싸여진다. 따라서 버튼이 눌려져서 &lt;code class=&quot;language-text&quot;&gt;onClick()&lt;/code&gt; 핸들러가 호출되는 시점에서도 여전히 &lt;code class=&quot;language-text&quot;&gt;label&lt;/code&gt; 변수를 참조할 수 있게 되는 것이다.&lt;/p&gt;
&lt;h2 id=&quot;만약-클로저를-볼-수-없다면&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%8C%EC%95%BD-%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EB%B3%BC-%EC%88%98-%EC%97%86%EB%8B%A4%EB%A9%B4&quot; aria-label=&quot;만약 클로저를 볼 수 없다면 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;만약 클로저를 볼 수 없다면?&lt;/h2&gt;
&lt;p&gt;다음과 같은 (철학적인) 격언을 들어본적 있는가?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;만약 숲속에서 나무가 쓰러졌는데 아무도 그 소리를 듣지 못했다면, 그 나무가 소리를 냈다고 할 수 있는가?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;물론 과학적인 관점에서 나무는 음파를 발생시킨 것이 맞다. 하지만 중요한 포인트는 소리가 난 것이 정말 중요한 것인가? 라는 점이다.&lt;/p&gt;
&lt;p&gt;클로저가 기술적인, 혹은 학술적인 관점에서 “존재”한다고 해도 &lt;strong&gt;볼 수 없다면&lt;/strong&gt;, 클로저가 그렇게 중요한 것일까? 아니다.&lt;/p&gt;
&lt;p&gt;다음 예시 코드를 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;myName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; greeting &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;greeting&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;myName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;Hello, Kyle!&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내부 함수 &lt;code class=&quot;language-text&quot;&gt;output()&lt;/code&gt;은 외부 스코프에 있는 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;myName&lt;/code&gt; 변수를 참조하고 있다. 하지만 &lt;code class=&quot;language-text&quot;&gt;output()&lt;/code&gt; 함수 호출이 이 함수가 호출된 스코프에서 일어나고 있으므로 이는 클로저가 아니라 단순히 렉시컬 스코프를 통해 두 변수를 참조한 것이다.&lt;/p&gt;
&lt;p&gt;사실, 글로벌 스코프는 어디에서든 접근이 가능하기 때문에 본질적으로 클로저에 의해 에워싸일 수 없다. 결국 모든 함수들도 글로벌 스코프, 혹은 스코프 체인의 관점에서 보자면 글로벌 스코프의 “자손(descendant)” 스코프에서 호출되므로 사실 따지고 보면 글로벌 스코프에 있는 변수들은 클로저에 의해 에워싸여 지는 것이 아니라 단순히 렉시컬 스코프 체인에 의해 탐색되는 것이다.&lt;/p&gt;
&lt;p&gt;다음 코드를 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; students &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Sarah&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFirstStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;firstStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; students&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFirstStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Kyle&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내부 함수 &lt;code class=&quot;language-text&quot;&gt;firstStudent()&lt;/code&gt;에서 외부 변수 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;를 참조하고 있지만, &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;는 글로벌 스코프의 변수이므로 &lt;code class=&quot;language-text&quot;&gt;firstStudent()&lt;/code&gt; 함수가 어디서 호출되건 상관없이 (클로저가 아니라) 렉시컬 스코프를 통해 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;에 접근할 수 있다. 따라서 모든 함수는 어디서 호출되건 상관없이 글로벌 변수에 접근할 수 있으므로, 글로벌 변수들은 클로저에 의해 에워싸여 진다고 할 수는 없다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;또한, 존재는 하지만 한 번도 참조되지 않는 변수의 경우 클로저와는 별다른 관련이 없다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;nobody&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Nobody&apos;s here yet.&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;student&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Nobody&apos;s here yet.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서, 내부 함수 &lt;code class=&quot;language-text&quot;&gt;nobody()&lt;/code&gt;가 에워싸는 외부 변수는 없다. 단지 자신의 스코프 내부에 있는 &lt;code class=&quot;language-text&quot;&gt;msg&lt;/code&gt; 변수만 참조할 뿐이다. &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt; 변수가 &lt;code class=&quot;language-text&quot;&gt;nobody()&lt;/code&gt; 함수를 둘러싼 외부 스코프에 있다고 하더라도 내부 함수 &lt;code class=&quot;language-text&quot;&gt;nobody()&lt;/code&gt;에 의해 참조되지 않으므로 이 경우 자바스크립트 엔진은 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수가 종료되면 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt; 변수를 메모리에서 제거해버린다.&lt;/p&gt;
&lt;p&gt;따라서 위 코드에선 어떠한 클로저도 관찰되지 않는다.&lt;/p&gt;
&lt;p&gt;함수 호출이 발생하지 않는 경우에도 클로저는 관찰되지 않는다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greetStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hello, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt; studentName &lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;greetStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Kyle&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 아무런 일도 일어나지 않는다.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드에선 분명 외부 함수 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt;가 호출되고, 내부 함수 &lt;code class=&quot;language-text&quot;&gt;greeting()&lt;/code&gt;이 외부 변수 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt;을 참조하므로 클로저가 존재한다고 할 수 있지만 내부 함수가 “호출”되지는 않는다. 즉, 내부 함수가 어디에 저장되지 않고 그냥 “버려진다”.&lt;/p&gt;
&lt;p&gt;따라서 이 경우, 따지고보면 자바스크립트 엔진이 짧은 시간동안 클로저를 생성하지만 우리가 이 클로저를 관찰할 수는 없다.&lt;/p&gt;
&lt;p&gt;분명 숲속에서 나무가 쓰러졌지만 우리가 듣지는 못했으므로 별로 신경쓰지는 않는다… 클로저도 마찬가지다. 우리가 클로저를 확인할 수 있어야 의미가 있는 것이지, 존재는 하지만 볼 수 없다면 별 의미 없는 것이다.&lt;/p&gt;
&lt;h2 id=&quot;관측가능한-클로저의-정의&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B4%80%EC%B8%A1%EA%B0%80%EB%8A%A5%ED%95%9C-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%98-%EC%A0%95%EC%9D%98&quot; aria-label=&quot;관측가능한 클로저의 정의 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;관측가능한 클로저의 정의&lt;/h2&gt;
&lt;p&gt;그렇다면 &lt;strong&gt;관측가능한(observable)&lt;/strong&gt; 클로저의 정의를 한번 내려보자.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;클로저는 어떤 함수가 이 함수의 스코프 밖에 있는 변수에 대해, 해당 변수를 사용할 수 없는 스코프에서 실행됨에도 불구하고 변수를 사용하는 경우 관측할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 정의에서 핵심적인 부분은 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;반드시 함수가 호출되어야 한다.&lt;/li&gt;
&lt;li&gt;반드시 함수 외부 스코프에 존재하는 변수를 하나 이상 참조해야 한다.&lt;/li&gt;
&lt;li&gt;반드시 참조하는 변수가 속한 스코프 이외의 스코프에서 함수를 호출해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이러한 관측 중심(observation-oriented) 정의가 시사하는 바는 클로저를 단순히 비직관적이고 학술적인 것으로 치부하지 말고, 클로저가 프로그램에 미치는 영향을 잘 살펴서 클로저를 잘 활용할 줄 알아야 한다는 점이다. &lt;/p&gt;
&lt;h2 id=&quot;클로저와-가비지-컬렉션&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80%EC%99%80-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98&quot; aria-label=&quot;클로저와 가비지 컬렉션 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저와 가비지 컬렉션&lt;/h2&gt;
&lt;p&gt;클로저는 본질적으로 함수 인스턴스와 연관되어 있기 때문에, 함수 인스턴스가 살아있을 동안(유지되는 동안) 함수 인스턴스의 클로저가 감싸는 변수들 또한 계속 살아있게 된다. 만약 열 개의 함수가 모두 같은 변수를 에워싸는 경우, 아홉개의 함수 인스턴스가 없어진다고 해도 여전히 살아있는 마지막 함수 인스턴스가 해당 변수를 계속해서 유지시키게 된다. 그러다 이 마지막 함수 인스턴스가 없어지는 순간 변수를 감싸던 클로저도 사라지게 되고, 마침내 변수도 가비지 컬렉트 된다.&lt;/p&gt;
&lt;p&gt;이는 효율적이고 성능이 좋은 프로그램을 작성하는데 아주 큰 영향을 미친다. 즉, 클로저가 이미 사용이 끝난 변수가 가비지 컬렉트 되지 못하게 막을 수 있다는 것이다. 따라서 더 이상 사용하지 않는 함수 인스턴스를 없애는 것이 매우 중요하다. 다음 코드를 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;manageBtnClickEvents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; clickHandlers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;listener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cb&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;clickHandler&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;clicked!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;evt&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            clickHandlers&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;clickHandler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                &lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                clickHandler
            &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;// passing no callback unsubscribes&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;// all click handlers&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; handler &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; clickHandlers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;removeEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                    &lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                    handler
                &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

            clickHandlers &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; onSubmit &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;manageBtnClickEvents&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mySubmitBtn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;checkout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// handle checkout&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;trackAction&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// log action to analytics&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// later, unsubscribe all handlers:&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;onSubmit&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드에서, 내부 함수 &lt;code class=&quot;language-text&quot;&gt;onClick()&lt;/code&gt;의 클로저는 인자로 전달된 이벤트 콜백 &lt;code class=&quot;language-text&quot;&gt;cb&lt;/code&gt;을 가진다. 즉, 이벤트 핸들러 &lt;code class=&quot;language-text&quot;&gt;checkout()&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;trackAction()&lt;/code&gt;에 대한 레퍼런스가 클로저를 통해 유지된다는 말이며 이 두 핸들러가 이벤트에 등록(subscribe)되어 있는 동안에는 가비지 컬렉트 되지 않는다.&lt;/p&gt;
&lt;p&gt;마지막 줄을 보면 &lt;code class=&quot;language-text&quot;&gt;onSubmit()&lt;/code&gt; 함수에 아무런 인자도 전달해주지 않음으로써 모든 이벤트 핸들러를 등록 취소(unsubscribe)하고 있음을 할 수 있다. 이로 인해 &lt;code class=&quot;language-text&quot;&gt;clickHandlers&lt;/code&gt; 배열이 비워지게 되고, 등록된 모든 핸들러가 제거됨에 따라 &lt;code class=&quot;language-text&quot;&gt;cb&lt;/code&gt;를 통해 레퍼런스 하고 있는 &lt;code class=&quot;language-text&quot;&gt;checkout()&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;trackAction()&lt;/code&gt;에 대한 클로저도 제거된다.&lt;/p&gt;
&lt;p&gt;따라서, 여기서 살펴본 것과 이벤트 핸들러들을 등록하는 것보다 핸들러를 더 이상 사용하지 않는 경우 등록을 취소하는 것이 더 중요하며 이렇게 해야 프로그램이 좀 더 효율적으로 동작할 수 있게 된다.&lt;/p&gt;
&lt;h2 id=&quot;클로저는-변수-단위인가-스코프-단위인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%8A%94-%EB%B3%80%EC%88%98-%EB%8B%A8%EC%9C%84%EC%9D%B8%EA%B0%80-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%8B%A8%EC%9C%84%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;클로저는 변수 단위인가 스코프 단위인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저는 변수 단위인가 스코프 단위인가?&lt;/h2&gt;
&lt;p&gt;클로저에 대해 생각해볼 또 하나는 과연 클로저가 오직 참조되는 외부 변수에만 적용이 되는 것인지, 아니면 외부 스코프 체인(및 외부 스코프에 존재하는 모든 변수들) 전체에 적용이 되는 것인지에 대한 것이다.&lt;/p&gt;
&lt;p&gt;방금 살펴본 예제에 대해 살펴보자면 내부 함수 &lt;code class=&quot;language-text&quot;&gt;onClick()&lt;/code&gt;의 클로저는 &lt;code class=&quot;language-text&quot;&gt;cb&lt;/code&gt;만 감싸는 걸까?, 아니면 &lt;code class=&quot;language-text&quot;&gt;clickHandler&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;clickHandlers&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;btn&lt;/code&gt; 또한 감싸는 걸까?&lt;/p&gt;
&lt;p&gt;사실 개념적으로, 클로저는 스코프 단위가 아니라 &lt;strong&gt;변수 단위&lt;/strong&gt;이다. Ajax 콜백, 이벤트 핸들러 뿐만 아니라 모든 형태의 클로저들은 오직 명시적으로 참조하는 외부 변수만 감싼다.&lt;/p&gt;
&lt;p&gt;하지만 현실은 이보다 좀 더 복잡할 수 있다. 다음을 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;manageStudentGrades&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentRecords&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; grades &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; studentRecords&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;getGrade&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; addGrade&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ************************&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getGrade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; record&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;grade&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sortAndTrimGradesList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// sort by grades, descending&lt;/span&gt;
        grades&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;g1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; g2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; g2 &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; g1&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token comment&quot;&gt;// only keep the top 10 grades&lt;/span&gt;
        grades &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; grades&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;slice&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addGrade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;newGrade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        grades&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;newGrade&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;sortAndTrimGradesList&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; grades&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; addNextGrade &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;manageStudentGrades&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; grade&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;86&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; grade&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;87&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; grade&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;75&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ... many more records&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Sarah&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; grade&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;91&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// later&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addNextGrade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;81&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [ 91, 87, 86, 81, 75 ]&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addNextGrade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;68&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [ 91, 87, 86, 81, 75, 68 ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;외부 함수 &lt;code class=&quot;language-text&quot;&gt;manageStudentGrades()&lt;/code&gt;는 학생들의 목록을 받아 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt; 함수 레퍼런스를 리턴한다. 그리고 이렇게 리턴받은 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt; 함수 레퍼런스를 &lt;code class=&quot;language-text&quot;&gt;addNextGrade&lt;/code&gt;라는 변수에 저장하였다. 이후 &lt;code class=&quot;language-text&quot;&gt;addNextGrade()&lt;/code&gt; 함수에 새로운 점수를 인자로 주어 실행하면 내림차순으로 정렬된 상위 10개의 점수를 리턴받게 된다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;manageStudentGrades()&lt;/code&gt; 함수가 종료된 이후 &lt;code class=&quot;language-text&quot;&gt;addNextGrade()&lt;/code&gt; 함수를 호출하는 동안에도 &lt;code class=&quot;language-text&quot;&gt;grades&lt;/code&gt; 변수는 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt; 함수의 클로저 내부에 계속 유지된다. 여기서 다시한번 명심해야할 것이, 클로저가 저장하는 것은 &lt;code class=&quot;language-text&quot;&gt;grades&lt;/code&gt; 변수 그 자체이지 &lt;code class=&quot;language-text&quot;&gt;grades&lt;/code&gt; 변수가 가지고 있는 배열이 아니다.&lt;/p&gt;
&lt;p&gt;이것 말고도 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt;의 클로저가 저장하는 것이 있다. 눈치챘는가? 바로 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList&lt;/code&gt; 함수이다. &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt;에서 이 함수를 호출하므로 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt;의 클로저 내부에는 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList()&lt;/code&gt;의 identifier가 저장되어야 한다. 또한, 이 함수가 클로저를 통해 계속해서 유지되므로 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList()&lt;/code&gt;의 클로저(에 저장된 변수들) 또한 유지된다. 하지만 여기서는 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList()&lt;/code&gt;가 참조하는 외부 변수가 없으므로(&lt;code class=&quot;language-text&quot;&gt;grades&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt;에서도 참조하므로 제외) 추가적으로 클로저에 유지되는 변수는 없다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getGrade()&lt;/code&gt; 함수는 어떤가? &lt;code class=&quot;language-text&quot;&gt;.map()&lt;/code&gt;의 콜백 함수로 전달되어 &lt;code class=&quot;language-text&quot;&gt;manageStudentGrades()&lt;/code&gt; 함수 바깥 스코프에서 실행되는건 맞지만 &lt;code class=&quot;language-text&quot;&gt;addGrade()&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList()&lt;/code&gt;에서 참조하고 있지는 않다.&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;language-text&quot;&gt;manageStudentGrades()&lt;/code&gt;를 실행할 때 &lt;code class=&quot;language-text&quot;&gt;studentRecords&lt;/code&gt;로서 넘기는 (매우) 큰 배열을 갖는 변수는 어떨까? 이 변수도 감싸지는 걸까? 만약 클로저에 의해 감싸진다면 많은 학생들의 데이터를 저장하는 배열은 가비지 컬렉트되지 않을 것이고, 그에 따라 프로그램이 소모하는 메모리 크기가 더욱 커질 것이다. 하지만 코드를 다시한번 자세히 살펴보면, 어떠한 내부 함수도 &lt;code class=&quot;language-text&quot;&gt;studentRecords&lt;/code&gt;를 참조하지는 않는다.&lt;/p&gt;
&lt;p&gt;따라서 앞서 살펴본 것처럼 클로저가 변수 단위로 적용된다는 점을 고려해볼때, &lt;code class=&quot;language-text&quot;&gt;getGrade&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;studentRecords&lt;/code&gt;는 어떠한 내부 함수도 참조하지 않기 때문에 클로저에 저장되지 않는다고 할 수 있다. 따라서 이 두 변수(identifier)들은 &lt;code class=&quot;language-text&quot;&gt;manageStudentGrade()&lt;/code&gt; 함수가 종료되면 정상적으로 가비지 컬렉트될 것이다.&lt;/p&gt;
&lt;p&gt;실제로 &lt;code class=&quot;language-text&quot;&gt;addGrade&lt;/code&gt; 함수 내부에 브레이크 포인트를 걸어서 디버깅을 해보면 다음과 같이 클로저 내부엔 &lt;code class=&quot;language-text&quot;&gt;grades&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;sortAndTrimGradesList&lt;/code&gt;만 존재하고 &lt;code class=&quot;language-text&quot;&gt;studentRecords&lt;/code&gt;는 존재하지 않음을 알 수 있다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_debug.png&quot; alt=&quot;See Closure in Debug Mode&quot;&gt;
    &lt;figcaption&gt;디버깅 환경: VSCode, Node v14.17.5&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;&gt; 3편에 계속…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 클로저 Part3]]></title><description><![CDATA[이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 1편 보러가기…]]></description><link>https://jaehyeon48.github.io/javascript/closure_3/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/closure_3/</guid><pubDate>Sat, 22 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 아래의 원문을 번역/요약한 글입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&quot;&gt;You Don’t Know JS Yet/Chapter 7: Using Closures&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_1&quot;&gt;1편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_2&quot;&gt;2편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;p&gt;앞서 살펴본 바로는 클로저가 변수 단위로 적용되는 것 같았다. 하지만 다음과 같은 경우는 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;storeStudentInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;id&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; grade&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;whichValue&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// warning: using `eval(..)` is a bad idea!&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;eval&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;whichValue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; info &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;storeStudentInfo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;87&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;name&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Suzy&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;grade&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 87&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내부 함수 &lt;code class=&quot;language-text&quot;&gt;getInfo()&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;id&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;grade&lt;/code&gt; 변수 중 어떠한 것도 명시적으로 클로저로 감싸고 있지는 않다. 그렇지만 &lt;code class=&quot;language-text&quot;&gt;eval()&lt;/code&gt;을 통해 여전히 해당 변수들에 접근이 가능한 것처럼 보인다. 따라서 내부 함수에 의해 명시적으로 참조되지는 않지만 해당 변수들이 클로저를 통해 유지되는것 처럼 보인다. 그렇다면 앞서 살펴본 “클로저는 변수 단위로 적용된다”는 것이 틀린걸까?&lt;/p&gt;
&lt;p&gt;때에 따라 다르다. 대부분의 현대 자바스크립트 엔진들은 명시적으로 참조되지 않는 변수들을 클로저에서 제거하는 최적화 과정을 수행한다. 하지만 여기서 &lt;code class=&quot;language-text&quot;&gt;eval()&lt;/code&gt;을 사용한 경우처럼 최적화를 수행할 수 없는 경우가 있으며, 이 경우 클로저는 변수들을 그대로 가지고 있게 된다.&lt;/p&gt;
&lt;p&gt;다시말해, 일단 클로저는 반드시 스코프 단위로 적용되어야 하며, 구현에 따라 차이가 있을 수 있고, 추가적인 최적화를 통해 클로저가 저장하는 전체 스코프를 명시적으로 참조하는 부분으로 최소화 할 수 있다 (즉, 원래 스코프 단위로 적용되는 것을 변수 단위로 적용되도록 최적화).&lt;/p&gt;
&lt;p&gt;당장 몇 년전 까지만 해도 대부분의 자바스크립트 엔진들은 이러한 최적화를 수행하지 않았다. 즉, 이벤트 핸들러 같은 콜백들이 우리가 생각한 것보다 훨씬 오래 메모리에 유지됐을 수도 있다는 것이다. 또한 최적화가 스펙의 일부가 아니라 추가적인(optional) 작업이라는 점을 고려해보았을 떄, 최적화가 무조건 수행될 것이라고 생각해서는 안된다.&lt;/p&gt;
&lt;p&gt;따라서 클로저 내의 어떤 변수가 배열/객체와 같이 아주 큰 값을 가지는 경우, 해당 변수가 더 이상 필요없으면 최적화 혹은 가비지 컬렉션에 의존하지말고 직접(manually) 변수를 제거하는 것이 안전하다고 할 수 있다. 이것을 2부 마지막에 살펴본 예시에 적용해보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;manageStudentGrades&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentRecords&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; grades &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; studentRecords&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;getGrade&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// unset `studentRecords` to prevent unwanted&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// memory retention in the closure&lt;/span&gt;
    studentRecords &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; addGrade&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서, &lt;code class=&quot;language-text&quot;&gt;studentRecords&lt;/code&gt; 변수를 클로저에서 아예 제거해버리는 것이 아니다. 클로저에서 제거하는것은 우리가 할 수 없는 작업이다. 대신, 이 변수에 &lt;code class=&quot;language-text&quot;&gt;null&lt;/code&gt; 등을 할당하여 변수가 더 이상 큰 배열을 가리키지 않도록 하여 배열이 메모리에서 제거(GC)되도록 하여 메모리 효율을 더 좋게 했다.&lt;/p&gt;
&lt;p&gt;다시한번 말하지만, 사실 대부분의 요즘 엔진들은 자동적으로 최적화 과정을 수행한다. 하지만 위와 같이 더 이상 사용하지 않는 변수들에 직접 조치를 취하여 불필요한 메모리 낭비를 막는 것이 좋은 습관이다.&lt;/p&gt;
&lt;p&gt;또, 위 코드에서 &lt;code class=&quot;language-text&quot;&gt;.map(getGrade)&lt;/code&gt;이 수행된 이후 더 이상 &lt;code class=&quot;language-text&quot;&gt;getGrade()&lt;/code&gt;를 필요로 하지 않으므로 이 함수 레퍼런스를 없애서 메모리를 (조금이나마) 더 확보할 수도 있다. 여기서는 프로그램이 매우 간단하기 때문에 이렇게 까지 하지는 않았지만, 만약 실제 애플리케이션을 개발하면서 메모리 최적화를 하는 경우 이러한 부분까지 신경을 써주는게 좋다.&lt;/p&gt;
&lt;p&gt;자, 결론은 간단하다. &lt;strong&gt;프로그램 내에서 클로저가 어디에 나타나는지 파악하고, 클로저 내에 어떤 변수가 포함되는지 파악하는 것이 중요하다. 이렇게 해야 정말 필요한 것들만 클로저 내에 유지함으로써 메모리 낭비를 막을 수 있다&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;다른-관점에서-바라보기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8B%A4%EB%A5%B8-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B0%94%EB%9D%BC%EB%B3%B4%EA%B8%B0&quot; aria-label=&quot;다른 관점에서 바라보기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;다른 관점에서 바라보기&lt;/h2&gt;
&lt;p&gt;앞서 내린 클로저에 대한 정의를 다시 살펴보면, 함수가 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_citizen&quot;&gt;일급 객체&lt;/a&gt;로서 동작한다는 사실을 알 수 있다. 클로저는 함수가 어디에서 호출되건 상관없이 해당 함수가 선언된 당시의 외부의 스코프/변수에 &lt;strong&gt;링크&lt;/strong&gt;를 연결하는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8000/javascript/closure_1/#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%A7%EC%85%88&quot;&gt;여기&lt;/a&gt;서 살펴본 코드를 다시한번 살펴보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addTo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; num1 &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; num2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; add10To &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; add42To &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add10To&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 25&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add42To&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 51&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;우리가 여태껏 살펴보고 있는 관점에서 보자면, 함수가 어디에서 호출되건 관계없이 클로저는 함수가 선언된 원래의 환경에 대한 “숨겨진 링크”를 유지하여 함수가 클로저 내에 유지되는 변수들에 참조할 수 있도록 한다. 앞서 이러한 그림도 살펴본 적이 있다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/visualizing_closures.png&quot; alt=&quot;Visualizing Closures&quot;&gt;
    &lt;figcaption&gt;출처: https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;하지만 이러한 관점 이외에 다른 각도에서 클로저를 바라보는 관점도 존재한다. 이 관점에서는 함수가 인자로서 전달되는 특성에 좀 더 초점을 맞춰 우리의 사고 모델(mental model)을 더욱 견고하게 해준다.&lt;/p&gt;
&lt;p&gt;이 관점은 “일급 객체로서의 함수”보다, 자바스크립트 내에서 함수는 레퍼런스 통해 할당되고, 인자로 전달된다는 사실에 더 초점을 둔다. 위 코드에 대해 말하자면, 내부 함수 인스턴스 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;문을 통해 외부 스코프로 나와 변수(&lt;code class=&quot;language-text&quot;&gt;add10To&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;add42To&lt;/code&gt;)에 할당된다고 생각하기 보다, 함수 인스턴스들은 자기의 스코프 환경에 그대로 있다고 생각하는 것이다.&lt;/p&gt;
&lt;p&gt;그럼 &lt;code class=&quot;language-text&quot;&gt;return&lt;/code&gt;문을 통해 외부 스코프로 보내지는 것은 무엇일까? 바로 함스 인스턴스의 &lt;strong&gt;레퍼런스&lt;/strong&gt;이다. 즉, 함수 인스턴스 자체가 밖으로 나오는 것이 아니라, 함수 인스턴스는 제자리에 가만히 있고, 이 함수 인스턴스의 레퍼런스가 밖으로 나오는 것이다. 다음 그림이 이와 같은 상황을 묘사하고 있다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/visualizing_closures_alt.png&quot; alt=&quot;Visualizing Closures, an Alternative Perspective&quot;&gt;
    &lt;figcaption&gt;출처: https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;위 그림에서, &lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt;를 호출하면 여전히 &lt;code class=&quot;language-text&quot;&gt;num1&lt;/code&gt;변수가 저장된 새로운 스코프(파란색)를 생성한다. &lt;code class=&quot;language-text&quot;&gt;addTo&lt;/code&gt; 인스턴스의 스코프(초록색)도 마찬가지다. 하지만 앞선 그림과의 차이점은, 초록색 스코프는 여전히 파란색 스코프 안에 존재한다는 것이고, &lt;code class=&quot;language-text&quot;&gt;addTo10&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;addTo42&lt;/code&gt; 레퍼런스만이 글로벌 스코프(분홍색)으로 나와 있다는 점이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;addTo10(15)&lt;/code&gt;이 호출되면 여전히 파란색 내부에 존재하는 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수 인스턴스가 호출된다. 물론 함수 인스턴스가 생성된 이후로 움직인 적이 없으므로 자연스럽게 이 함수 인스턴스의 스코프 체인에 접근할 수 있는 것이다. &lt;code class=&quot;language-text&quot;&gt;addTo42(9)&lt;/code&gt; 호출도 마찬가지다. 여기선 사실 렉시컬 스코프 이외에 어떠한 일도 벌어나지 않았다.&lt;/p&gt;
&lt;p&gt;그럼 함수가 다른 스코프로 이동했을 때도 링크를 통해 원래의 스코프에 접근할 수 있는 것이 클로저가 아니라면 도대체 뭐가 클로저란 말인가? 지금 살펴보고 있는 모델에선 함수는 제자리에 가만히 있지 않은가?&lt;/p&gt;
&lt;p&gt;이 관점에서의 클로저는, 어떤 함수 인스턴스에 대해 적어도 하나 이상의 (함수 인스턴스의) 함수 레퍼런스가 프로그램에 존재하는 한, 해당 함수 인스턴스가 자신의 스코프 환경을 유지한 채로 유지(alive)되는 것 이라고 할 수 있다.&lt;/p&gt;
&lt;p&gt;물론 이러한 정의는 흔히 사용되는 클로저에 대한 정의와는 사뭇 다르다. 하지만 이 정의는 레퍼런스와 제자리(in-place)에 있는 함수 인스턴스로 클로저를 간단하게 설명할 수 있다는 점에서 유용하다고 할 수 있다.&lt;/p&gt;
&lt;p&gt;물론 우리가 이전에 살펴본 모델이 틀렸다는것이 절대 아니다. 이전에 살펴본 정의는 좀 더 개념적이고, 학술적인 관점에서 클로저를 설명한 것이다. 반대로 지금 우리가 살펴보고 있는 모델은 좀 더 구현에 기반한, 자바스크립트가 실제로 동작하는 원리에 근거하여 클로저를 바라본 것이다.&lt;/p&gt;
&lt;h2 id=&quot;왜-클로저를-사용하는가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%9C-%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94%EA%B0%80&quot; aria-label=&quot;왜 클로저를 사용하는가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;왜 클로저를 사용하는가?&lt;/h2&gt;
&lt;p&gt;이제 클로저를 좀 알게 된거 같으니, 클로저를 활용하여 프로그램의 구조를 개선시키는 예시를 살펴보자.&lt;/p&gt;
&lt;p&gt;어느 페이지에 있는 버튼을 누르게 되면 데이터를 취합하여 Ajax 통신을 하는 프로그램이 있다고 하자. 클로저를 사용하지 않으면 다음과 같이 코딩할 것이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; APIendpoints &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;studentIDs&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://some.api/register-students&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;studentIDs&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeRequest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; btn &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; evt&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; recordKind &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dataset&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;kind&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        APIendpoints&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// &amp;lt;button data-kind=&quot;studentIDs&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//    Register Students&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// &amp;lt;/button&gt;&lt;/span&gt;
btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; makeRequest&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;makeRequest&lt;/code&gt; 함수는 클릭 이벤트로 부터 &lt;code class=&quot;language-text&quot;&gt;evt&lt;/code&gt; 변수를 통해 이벤트 객체를 전달받는다. 그 후 타겟 버튼의 &lt;code class=&quot;language-text&quot;&gt;data-kind&lt;/code&gt; 속성에서 데이터를 얻어 이 데이터로 적절한 URL을 찾은 다음 Ajax 통신을 한다.&lt;/p&gt;
&lt;p&gt;물론 이 프로그램은 잘 작동하지만, 이벤트 핸들러가 실행될 때마다 DOM 속성을 읽어야 한다는 단점이 있다. 이벤트 핸들러가 이 속성을 “기억”하는 방법이 없을까? 클로저를 이용하여 코드를 개선해보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; APIendpoints &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;studentIDs&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;https://some.api/register-students&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;studentIDs&apos;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// ..&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setupButtonHandler&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; recordKind &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dataset&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;kind&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeRequest&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
                APIendpoints&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
                data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// &amp;lt;button data-kind=&quot;studentIDs&quot;&gt;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;//    Register Students&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// &amp;lt;/button&gt;&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setupButtonHandler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;btn&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기선 &lt;code class=&quot;language-text&quot;&gt;setupButtonHandler()&lt;/code&gt;라는 외부 함수를 만들어서 &lt;code class=&quot;language-text&quot;&gt;data-kind&lt;/code&gt;의 값을 &lt;code class=&quot;language-text&quot;&gt;recordKind&lt;/code&gt; 변수에 저장시켰다. 이렇게 하면 추후에 &lt;code class=&quot;language-text&quot;&gt;makeRequest()&lt;/code&gt; 함수가 &lt;code class=&quot;language-text&quot;&gt;recordKind&lt;/code&gt; 변수를 클로저 내에 저장하여 이벤트가 발생할 때마다 DOM을 읽을 필요 없이 클로저에 있는 &lt;code class=&quot;language-text&quot;&gt;recordKind&lt;/code&gt;를 참조하게 되어 프로그램이 더욱 효율적으로 동작하게 된다. 또한, &lt;code class=&quot;language-text&quot;&gt;recordKind&lt;/code&gt; 변수를 &lt;code class=&quot;language-text&quot;&gt;setupButtonHandler()&lt;/code&gt; 함수 내에 둠으로써 이 변수의 노출을 최소화 하였다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;참고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;사실, 개선된 코드에서 &lt;code class=&quot;language-text&quot;&gt;makeRequest&lt;/code&gt; 함수로 전달된 &lt;code class=&quot;language-text&quot;&gt;evt&lt;/code&gt; 변수는 사용되지 않지만, 이전 코드와의 일관성을 위해 그대로 남겨놓았다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;p&gt;이와 같은 패턴에 기반하여, &lt;code class=&quot;language-text&quot;&gt;data-kind&lt;/code&gt; 뿐만 아니라 알맞은 URL과 데이터 또한 저장하여 더욱 효율을 높일 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// const APIendpoints = { ... };&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// const data = { ... };&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;setupButtonHandler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;btn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; recordKind &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dataset&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;kind&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; requestURL &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; APIendpoints&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; requestData &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;recordKind&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    btn&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addEventListener&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;token string&quot;&gt;&apos;click&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeRequest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;evt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;requestURL&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; requestData&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;더 개선된 코드에선 &lt;code class=&quot;language-text&quot;&gt;recordKind&lt;/code&gt;가 아니라 &lt;code class=&quot;language-text&quot;&gt;requestURL&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;requestData&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;makeRequest()&lt;/code&gt; 함수의 클로저 내에 저장된다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;클로저를 사용함으로써 얻을 수 있는 이점을 정리해보자면 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;함수 인스턴스가 이전에 사용한 데이터 등을 재활용할 수 있게 함으로써 프로그램의 효율성을 증대시킨다.&lt;/li&gt;
&lt;li&gt;변수의 불필요한 노출을 최소화 함으로써 코드의 가독성을 증대시킨다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 클로저 Part1]]></title><description><![CDATA[이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 2편 보러가기 3편 보러가기 이 글 에서 살펴본 POLE 원칙에 의하면, identifier…]]></description><link>https://jaehyeon48.github.io/javascript/closure_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/closure_1/</guid><pubDate>Fri, 21 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 아래의 원문을 번역/요약한 글입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&quot;&gt;You Don’t Know JS Yet/Chapter 7: Using Closures&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_2&quot;&gt;2편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;../closure_3&quot;&gt;3편 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;p&gt;&lt;a href=&quot;../limiting_scope_exposure_1&quot;&gt;이 글&lt;/a&gt; 에서 살펴본 POLE 원칙에 의하면, identifier의 불필요한 노출을 최소화 하기 위해 함수/블록 스코프를 적절히 활용하는 것이 좋다. 이렇게 하면 코드의 가독성이 더 좋아지고 유지보수 또한 더 쉬워질뿐만 아니라 이름 충돌과 같은 여러 문제들도 피할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;클로저&lt;/strong&gt;는 이와 같은 방식에 기반을 두고 있다. 즉, 계속해서 사용할 변수들을 바깥의 더 큰 스코프에 놔두기 보다는 더 작은 내부 스코프에 “캡슐화(encapsulate)” 하여 해당 변수를 숨김과 동시에, 내부 함수에서는 계속해서 해당 변수들에 참조할 수 있게 하는 것이다. &lt;strong&gt;함수들은 클로저를 통해 참조하고 있는 바깥 변수들을 “기억”한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위 링크에 있는 글에서도 이미 클로저를 사용한 적이 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; cache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; factorial&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ****************&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 외부 스코프에 존재하는 &quot;cache&quot;를 참조하고 있음 -&gt; 클로저!!&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아마 여태껏 자바스크립트를 사용해오면서 위와 같은 코드를 본 적이 있거나, 혹은 작성해본 경험이 있을 것이다. 혹시 비동기를 사용하면서 콜백을 사용할 때 콜백 함수에서 외부 스코프에 있는 변수를 참조한 적이 있는가? 그게 바로 클로저이다!&lt;/p&gt;
&lt;p&gt;클로저는 여태껏 프로그래밍 세계에서 발명된 가장 중요한 특성 중 하나이다. 클로저는 함수형 프로그래밍, 모듈 패턴, 심지어는 객체 지향과 같은 주요 패러다임의 발판이다. 따라서 자바스크립트를 완전히 마스터하고, 주요 디자인 패턴들을 사용하기 위해선 반드시 클로저를 이해해야 한다.&lt;/p&gt;
&lt;p&gt;다음 내용으로 넘어가기 전에 반드시 각 개념들을 충분한 시간을 들여 숙지한 다음 넘어가길 바란다.&lt;/p&gt;
&lt;h2 id=&quot;클로저-살펴보기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0&quot; aria-label=&quot;클로저 살펴보기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저 살펴보기&lt;/h2&gt;
&lt;p&gt;클로저는 사실 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_calculus&quot;&gt;Lambda calculus&lt;/a&gt;에서 사용된 개념이다. 하지만 여기선 클로저를 설명하기 위해 수학적 공식이나 기호등을 사용하지는 않을 것이다. 대신 좀 더 실용적인 부분에 초점을 맞출 것이다. 우선, 만약 자바스크립트에 클로저가 없었다면 프로그램이 어떤 방식으로 동작했을지에 대해 살펴보고 추후에 다른 시각으로 클로저를 이리 저리 살펴볼 예정이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;클로저는 오로지 함수에 관한 것이다. 함수 이외의 것에는 클로저라는 것이 적용되지 않는다. 일반적인 객체에는 클로저가 없으며, 클래스에도 클로저가 없다 (클래스의 메소드에는 존재할 수 있다!). 다시 말하지만, &lt;strong&gt;오직 함수만이 클로저를 갖는다&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;클로저를 관찰(observe)하기 위해선 함수를 반드시 원래 함수가 선언된 스코프와 다른 스코프 (a different branch of the scope chain)에서 호출되어야 한다. 함수가 선언된 스코프와 동일한 스코프 내에서 해당 함수를 호출한다면 클로저를 관찰할 수 없게 된다. 관찰적 관점/정의에 의하면 이는 클로저가 아니다.&lt;/p&gt;
&lt;p&gt;다음 예시의 코드를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lookupStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;studentID&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; students &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Kyle&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;73&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; id&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Sarah&apos;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greetStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; student &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; students&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;student&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; student&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;id &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; studentID&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;greeting&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;student&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; chosenStudents &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;lookupStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;lookupStudent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;112&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// accessing the function&apos;s name:&lt;/span&gt;
chosenStudents&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;name&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// greetStudent&lt;/span&gt;

chosenStudents&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Hello, Sarah!&lt;/span&gt;

chosenStudents&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Howdy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// Howdy, Frank!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;p&gt;우선 위 코드에서 주목해야할 점은, &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수 내부에서 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수를 선언하여 리턴하고 있다는 점이다. 그 후 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수는 두 번 호출되어 각각의 독립적인 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수 인스턴스가 &lt;code class=&quot;language-text&quot;&gt;chosenStudents&lt;/code&gt; 배열에 저장된다. 각 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수의 인스턴스가 배열에 저장된 것인지를 확인하기 위해 &lt;code class=&quot;language-text&quot;&gt;.name&lt;/code&gt; 함수 속성을 이용하여 체킹하고 있음을 알 수 있다.&lt;/p&gt;
&lt;p&gt;이 때 얼핏 보기엔 각 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수 호출이 끝나면 이 함수의 모든 내부 변수들은 가비지 컬렉터에 의해 사라지고, 리턴되는 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수만 계속해서 보존되는 것 같다. 하지만 이 부분을 유심히 살펴볼 필요가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수를 잘 살펴보면, 매개 변수로 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 변수를 받을 뿐만 아니라, &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수의 스코프 내에 존재하는 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt; 배열과 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt; 변수를 참조하고 있음을 알 수 있다. 이처럼 내부 함수가 &lt;strong&gt;자신이 선언되었을 때의 환경(정확히는 Lexical environment)인 스코프를 “기억”하여 자신이 선언된 스코프 이외의 스코프에서 호출되어도 여전히 자기가 기억하고 있는 스코프를 참조할 수 있도록 하는 것을 클로저&lt;/strong&gt;라고 한다.&lt;/p&gt;
&lt;p&gt;이 때 클로저에 의해 참조되는 외부 변수를 &lt;strong&gt;자유 변수(Free variable)&lt;/strong&gt;라고 한다. 여기서는 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;가 자유 변수이다. 또, 학술적으로 말하자면 각 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수가 자유 변수 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;를 “에워 싼다(close over)“라고 한다.&lt;/p&gt;
&lt;p&gt;그렇다면 위 코드에서 클로저는 무슨 역할을 하고 있는 걸까?&lt;/p&gt;
&lt;p&gt;클로저는 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수의 외부 스코프가 종료(즉, 외부 함수인 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt;가 리턴되면서 종료되는 것)된 이후에도 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt;로 하여금 계속해서 외부 변수(&lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;)에 참조할 수 있게 해준다. &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;는 가비지 컬렉트 되지 않고 계속해서 메모리에 존재하며, 추후 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수의 인스턴스가 실행될 때에도 이 두 변수들은 계속해서 값을 지닌채 남아있게 된다.&lt;/p&gt;
&lt;p&gt;만약 자바스크립트에 클로저가 없었다면 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수가 종료(리턴)되자 마자 이 함수의 스코프가 사라지고 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;는 가비지 컬렉트 되어 메모리에서 사라지게 될 것이다. 이 상태에서 나중에 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수 인스턴스 중 하나를 호출하면 어떤 일이 벌어질까?&lt;/p&gt;
&lt;p&gt;클로저라는 것이 없다면, &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수 인스턴스에서 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수의 스코프 영역에 접근하려고 시도하지만 해당 스코프는 더 이상 존재하지 않으므로, 아마 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;에 접근하려고 하는 순간 &lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt;가 발생할 것이다.&lt;/p&gt;
&lt;p&gt;하지만 실제로는 어떠한 에러도 발생하지 않는다. &lt;code class=&quot;language-text&quot;&gt;chosenStudents[0](&quot;Hello&quot;);&lt;/code&gt; 코드가 정상적으로 동작하여 &lt;code class=&quot;language-text&quot;&gt;&apos;Hello, Sarah!&apos;&lt;/code&gt; 라는 결과를 출력한다는 것은 &lt;code class=&quot;language-text&quot;&gt;lookupStudent()&lt;/code&gt; 함수가 종료된 이후에도 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수가 정상적으로 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt; 변수에 참조할 수 있다는 증거이다. 이 모든것은 결국 클로저가 있기에 가능한 일이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;사실, 위에서 우리가 간과한 부분이 하나 있다. 바로 화살표 &lt;code class=&quot;language-text&quot;&gt;=&gt;&lt;/code&gt; 함수도 “함수”이기 때문에 자신만의 스코프를 생성한다는 것이다. 즉, 엄밀히 따지고 보면 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수 내부에서 &lt;code class=&quot;language-text&quot;&gt;students&lt;/code&gt; 배열의 &lt;code class=&quot;language-text&quot;&gt;.find()&lt;/code&gt; 메소드의 콜백 함수로 화살표 함수를 넘기고 있고, 이 화살표 함수에서 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;를 참조하므로 실은 &lt;code class=&quot;language-text&quot;&gt;greetStudent()&lt;/code&gt; 함수에서 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;를 “에워싸는” 것이 아니라, 화살표 함수에서 &lt;code class=&quot;language-text&quot;&gt;studentID&lt;/code&gt;를 “에워싼다”.&lt;/p&gt;
&lt;p&gt;사실 여전히 모든 코드가 정상적으로 동작하기 때문에 이와 같은 부분이 그렇게 중요한 것은 아니다. 그래도 화살표 함수 역시 “함수”이기 때문에 클로저를 생성한다는 사실을 간과하지는 말자.&lt;/p&gt;
&lt;h2 id=&quot;클로저를-이용한-덧셈&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%A7%EC%85%88&quot; aria-label=&quot;클로저를 이용한 덧셈 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저를 이용한 덧셈&lt;/h2&gt;
&lt;p&gt;이제 가장 보편적인 클로저 예시 중 하나를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;num1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addTo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;num2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; num1 &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; num2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; add10To &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; add42To &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add10To&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 25&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add42To&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 51&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt; 함수 내부에 있는 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수의 각각의 인스턴스는 각자의 &lt;code class=&quot;language-text&quot;&gt;num1&lt;/code&gt; 변수(값은 각각 &lt;code class=&quot;language-text&quot;&gt;10&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;42&lt;/code&gt;)를 “에워싸고” 있기 때문에 &lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt; 함수가 종료된다고 해서 &lt;code class=&quot;language-text&quot;&gt;num1&lt;/code&gt; 변수가 사라지지는 않는다.&lt;/p&gt;
&lt;p&gt;이후에 &lt;code class=&quot;language-text&quot;&gt;add10To(15);&lt;/code&gt; 과 같이 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수의 인스턴스를 호출하여도 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수 인스턴스가 에워싸고 있는 &lt;code class=&quot;language-text&quot;&gt;num1&lt;/code&gt; 변수는 그대로 자신의 값(이 경우 &lt;code class=&quot;language-text&quot;&gt;10&lt;/code&gt;)을 유지한다. 따라서 연산 결과는 &lt;code class=&quot;language-text&quot;&gt;10 + 15 = 25&lt;/code&gt;가 되어 정상적으로 &lt;code class=&quot;language-text&quot;&gt;25&lt;/code&gt;를 출력하게 된다.&lt;/p&gt;
&lt;p&gt;위 예시에서 간과하고 넘어가기 쉬운 부분을 다시 한번 짚고 넘어가자. &lt;strong&gt;클로저는 하나의 함수 선언(lexical definition)이 아니라, 함수의 각 인스턴스와 연관된 개념&lt;/strong&gt;이다. 위 코드에서 외부 함수 &lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt; 내부에 있는 &lt;code class=&quot;language-text&quot;&gt;addTo&lt;/code&gt; 함수의 선언이 하나만 존재하기 때문에 클로저도 하나만 존재하는 것으로 착각하기 쉽다.&lt;/p&gt;
&lt;p&gt;하지만 실제로 매번 &lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt; 함수가 호출될 때마다 새로운, 독립적인 &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수 인스턴스가 생성되고, 각 함수 인스턴스마다 새로운 클로저가 생성된다. 따라서 내부 함수의 각 인스턴스(예시에서는 &lt;code class=&quot;language-text&quot;&gt;add10To&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;add42To&lt;/code&gt;로 이름이 붙여짐)는 각자의 독립적인 클로저를 갖는다.&lt;/p&gt;
&lt;h2 id=&quot;클로저는-스냅샷이-아니다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%8A%94-%EC%8A%A4%EB%83%85%EC%83%B7%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4&quot; aria-label=&quot;클로저는 스냅샷이 아니다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저는 스냅샷이 아니다&lt;/h2&gt;
&lt;p&gt;앞서 살펴본 두 예제에서 우리는 클로저 안에 들어있는 변수의 “값을 읽어 오기만” 했다. 이를 통해 클로저라는 것이 어떤 특정 순간의 변수의 값을 “캡쳐”하는 것이라고 오해할 수도 있다. 이는 전혀 사실이 아니다.&lt;/p&gt;
&lt;p&gt;클로저는 “값”에 대한 참조를 유지하는 일종의 스냅샷이 아니라, &lt;strong&gt;“변수” 그 자체에 대한 살아있는 링크(live link)를 유지하는 것&lt;/strong&gt;이다. 단순히 클로저 내에 있는 변수의 값을 읽는 것 뿐만 아니라, 해당 변수의 값을 변경할 수도 있다! 어떤 함수가 클로저를 통해 변수를 에워 싼다는 것은 해당 함수가 변수를 어디서든 계속해서 “사용”할 수 있다는 소리이다. 이것이 클로저가 여러 프로그래밍 분야에서 널리 사용되는 이유이다. 클로저는 그 만큼 강력한 기능을 제공하기 때문이다.&lt;/p&gt;
&lt;p&gt;다음은 위 예시에 대해 각 함수의 인스턴스와 스코프에 대한 링크를 그림으로 묘사한 것이다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/visualizing_closures.png&quot; alt=&quot;Visualizing Closures&quot;&gt;
    &lt;figcaption&gt;출처: https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;위 그림에서 볼 수 있듯, &lt;code class=&quot;language-text&quot;&gt;adder()&lt;/code&gt; 함수를 호출할 때마다 &lt;code class=&quot;language-text&quot;&gt;num1&lt;/code&gt; 변수를 가지는 새로운 파란색 스코프가 생성되고, &lt;code class=&quot;language-text&quot;&gt;addTo()&lt;/code&gt; 함수의 인스턴스(초록색 스코프) 또한 생성된다. 각 함수의 인스턴스(&lt;code class=&quot;language-text&quot;&gt;addTo10()&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;addTo42()&lt;/code&gt;)가 빨간색 글로벌 스코프 내에 존재하고, 빨간색 스코프 내에서 호출된다는 점도 알아두자.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;이제 클로저에 의해 에워 싸인 변수가 업데이트 되는 예시를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeCounter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; count&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hits &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;makeCounter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt; 변수는 내부 함수 &lt;code class=&quot;language-text&quot;&gt;getCurrent()&lt;/code&gt;에 의해 에워 싸이기 때문에 가비지 컬렉트의 대상이 아니다. 그리고 &lt;code class=&quot;language-text&quot;&gt;hits()&lt;/code&gt; 함수를 호출할 때마다 이 함수에서 &lt;code class=&quot;language-text&quot;&gt;count&lt;/code&gt; 변수에 접근하여 값을 1만큼 증가시킨 후 증가된 값을 반환한다.&lt;/p&gt;
&lt;p&gt;클로저를 생성하기 위해 일반적으로 함수(스코프)를 이용하여 내부 함수를 감싸는 경우가 많은데, 굳이 함수(스코프)를 사용할 필요는 없다. 단지 외부의 “스코프”가 내부 함수를 감싸기만 하면 된다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; hits&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 블록 스코프 이용&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;hits&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getCurrent&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        count &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; count &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; count&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hits&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;p&gt;대부분의 (초보) 개발자들이 클로저를 &lt;strong&gt;변수 중심&lt;/strong&gt;이 아니라 값 중심으로 생각하는 경향이 있기 때문에 다음과 같이 클로저를 이용하여 변수의 값을 “캡쳐”하려고 하는 실수를 종종 저지르곤 한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 클로저라는 것은 &apos;Frank&apos;라는 값(문자열)이 아니라 &lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// studentName 변수 그 자체를 에워 싸는것임.&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hello, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// &apos;Hello, Suzy!&apos;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;greeting()&lt;/code&gt;(a.k.a &lt;code class=&quot;language-text&quot;&gt;hello()&lt;/code&gt;) 이라는 함수를 정의할 때 클로저가 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt;이 당시에 가지고 있던 값(&lt;code class=&quot;language-text&quot;&gt;&apos;Frank&apos;&lt;/code&gt;)를 저장할 것이라고 잘못 생각하는 경우가 있다. 하지만 실제로 &lt;code class=&quot;language-text&quot;&gt;greeting()&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;&apos;Frank&apos;&lt;/code&gt; 라는 “값”이 아니라 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt;이라는 “변수”를 저장한다. 따라서 나중에 &lt;code class=&quot;language-text&quot;&gt;greeting()&lt;/code&gt;을 호출할 때, 호출할 당시의 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt; 변수의 값이 출력된다.&lt;/p&gt;
&lt;h2 id=&quot;루프문에서의-클로저&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A3%A8%ED%94%84%EB%AC%B8%EC%97%90%EC%84%9C%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80&quot; aria-label=&quot;루프문에서의 클로저 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;루프문에서의 클로저&lt;/h2&gt;
&lt;p&gt;위와 같은 실수는 루프문 내부에서 함수를 정의할 때도 발생한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keeps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;keepI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// i를 에워쌈 (close over)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3 -&gt; ???&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3 -&gt; ????&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 3 -&gt; ❓&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;참고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;보통 위와 같은 클로저 예시는 주로 루프문 내부에서 &lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt; 혹은 이벤트 핸들러를 이용하는 경우가 많다. 하지만 나(원문 저자)는 예시를 좀 더 단순화 하기 위해 배열에 함수를 저장하는 방식을 사용했다. 하지만 이렇게 하든 &lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt;등을 사용하든 근본적인 클로저의 원리는 동일하다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;아마 &lt;code class=&quot;language-text&quot;&gt;keeps[0]&lt;/code&gt;에 저장된 함수(인스턴스)가 생성될 때 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;의 값이 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;이었으므로 &lt;code class=&quot;language-text&quot;&gt;keeps[0]();&lt;/code&gt;의 결과가 &lt;code class=&quot;language-text&quot;&gt;0&lt;/code&gt;이 나올거라고 예상했을지도 모르겠다. 하지만 이는 앞서 말했듯이 클로저를 변수 중심이 아니라 값 중심으로 생각했기 때문에 발생한 잘못된 예측이다. &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt;문의 구조 때문에 각 iteration 마다 독립적인 (새로운) &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;가 존재한다고 생각했을 수도 있다. 하지만 여기선 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;로 선언되었기 때문에 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;는 오직 (&lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 블록 스코프가 아니라 글로벌 스코프에) 하나만 존재한다.&lt;/p&gt;
&lt;p&gt;따라서 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt;문을 다 돌고 나서 함수를 실행할 때 &lt;code class=&quot;language-text&quot;&gt;3&lt;/code&gt;이 나오는 이유는 프로그램 내에 오직 하나만 존재하는 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;의 값이 3이기 때문이다. 물론 &lt;code class=&quot;language-text&quot;&gt;keeps&lt;/code&gt; 배열에 저장된 각각의 &lt;code class=&quot;language-text&quot;&gt;keepI&lt;/code&gt; 함수 인스턴스는 서로 독립적인 클로저를 갖고 있지만, 이 독립적인 클로저들이 모두 같은 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;를 저장하고(에워싸고) 있다. 그림으로 묘사하면 다음과 같다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_1.png&quot; alt=&quot;Using Closure in loop example 1&quot;&gt;
&lt;/figure&gt;
&lt;p&gt;그럼 위 코드를 우리가 원하는 결과가 나오게끔 하려면 어떻게 해야할 까? 다음과 같이 각 iteration 마다 새로운 변수를 생성하는 방법이 있을 것이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keeps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// i의 값을 복사하는 변수를 매 iteration 마다 생성&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; j &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// `keeps[i]` 에서는 i 변수를 에워싸는 것이 아니므로 이런식으로&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 작성해도 괜찮음&lt;/span&gt;
    keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;keepEachJ&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// i가 아니라 j를 에워쌈&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; j&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기선 각각의 내부 함수 인스턴스가 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;와는 완전 별개인 새로운 변수 &lt;code class=&quot;language-text&quot;&gt;j&lt;/code&gt;를 에워싸고 있기 때문에 우리가 원하는 결과가 정상적으로 출력됨을 알 수 있다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_2.png&quot; alt=&quot;Using Closure in loop example 2&quot;&gt;
&lt;/figure&gt;
&lt;p&gt;물론 더 깔끔한 방법이 있다. &lt;a href=&quot;/javascript/hoisting/#%EB%A3%A8%ED%94%84%EB%AC%B8&quot;&gt;여기&lt;/a&gt;서 살펴본 것과 같이 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 사용하면 각 iteration 마다 개별적인 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;가 생성되므로 위 문제를 더욱 간단하게 해결할 수 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keeps &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 각 iteration 마다 자동적으로 새로운&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// i가 생성됨&lt;/span&gt;
    keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;keepEachI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 0&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 1&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keeps&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_3.png&quot; alt=&quot;Using Closure in loop example 3&quot;&gt;
&lt;/figure&gt;
&lt;p&gt;&gt; 2편에 계속…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 변수 노출 최소화 하기 Part2]]></title><description><![CDATA[1부 보러가기 var, 그리고 let 앞서 1부 마지막에 살펴본 코드에서  부분을 유심히 살펴보자. 왜 으로 선언하지 않고 로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical…]]></description><link>https://jaehyeon48.github.io/javascript/limiting_scope_exposure_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/limiting_scope_exposure_2/</guid><pubDate>Thu, 20 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../limiting_scope_exposure_1&quot;&gt;1부 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;var-그리고-let&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#var-%EA%B7%B8%EB%A6%AC%EA%B3%A0-let&quot; aria-label=&quot;var 그리고 let permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;var, 그리고 let&lt;/h2&gt;
&lt;p&gt;앞서 1부 마지막에 살펴본 코드에서 &lt;code class=&quot;language-text&quot;&gt;var bucket&lt;/code&gt; 부분을 유심히 살펴보자. 왜 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;으로 선언하지 않고 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical)이유가 존재한다.&lt;/p&gt;
&lt;p&gt;일단 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수는 자바스크립트 초창기 시절부터 항상 함수 스코프를 가지는, 즉 “함수 전체에 속하는” 변수였다. 어디에서 선언되건 관계없이 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;는 가장 가까운 함수 스코프(없으면 글로벌 스코프) 에 속하게 된다. 만약 다음과 같이 블록 안에 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;가 선언되더라도 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;는 블록 스코프가 아니라 함수 스코프이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; b &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 블록 스코프에 속하는 것이 아니라 함수 스코프에 속함&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 100&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그럼 왜 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 대신 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;를 사용한걸까? 일단 한눈에 보기에도 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 구별되기도 하고, &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 자체가 주는 의미가 “이 변수는 함수 스코프임” 이기 때문이다. 물론 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 함수 스코프 내에 선언하여 사용할 수도 있지만, 블록 내에 있는 다른 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 변수들과 잘 구별되지 않으므로 함수 전체에서 사용하는 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;인지 혹은 특정 블록 내에서 사용하는 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;인지 구별이 잘 되지 않을 수 있다.&lt;/p&gt;
&lt;p&gt;다시말해, 내 생각(원문 저자)엔 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;보다 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;가 “함수 전체에서 사용되는 변수”라는 의미를 더 잘 나타내므로 각자의 목적에 맞게 두 변수를 적절히 사용하는 것이 좋아보인다. 즉, “함수 스코프”라는 것을 나타내고 싶을땐 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;를, “블록 스코프”라는 것을 나타내고 싶을땐 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 사용하는게 적절할 것 같다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;⚠️ 경고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 같이 사용하라는 내 생각은 분명 논쟁의 소지가 다분하다. 보통 “var는 오류가 많아. let을 사용해!” 라던가, 혹은 “var는 절대로 사용하면 안된다. 반드시 let을 써라”와 같은 말을 들어봤을 수도 있다. 물론 이러한 주장도 일리는 있다. 하지만 이 주장들도 내 주장과 마찬가지로 어디까지나 “주장”일 뿐이다. &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;는 고장나거나(broken), 혹은 deprecated 된 녀석이 아니다. 자바스크립트 초창기부터 아주 잘 작동해왔으며, 아마 앞으로도 (자바스크립트가 없어질때까지) 그럴것이다!&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;그럼-let은&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%9F%BC-let%EC%9D%80&quot; aria-label=&quot;그럼 let은 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그럼 let은?&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;를 사용할지, 혹은 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 사용할지를 결정하는 것은 다음 물음을 통해 그 해답을 얻을 수 있다. “이 변수를 가장 최소한으로 노출시키는 스코프가 어디일까?”&lt;/p&gt;
&lt;p&gt;이 질문에 대한 답을 찾으면 해당 변수가 블록 스코프인지 혹은 함수 스코프인지 결정이 날 것이다. 만약 처음에는 블록 스코프라고 생각해서 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;을 사용했다가, 나중에 살펴보니까 실은 함수 스코프인 경우 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;로 변경하는 경우가 생길 수도 있다.&lt;/p&gt;
&lt;h2 id=&quot;trycatch&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#trycatch&quot; aria-label=&quot;trycatch permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;try…catch!&lt;/h2&gt;
&lt;p&gt;앞서 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 함수의 매개변수들은 함수 스코프임을, &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; (그리고 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;)는 블록 스코프임을 암시한다는 것을 살펴보았다. 하지만 여기에 한가지 예외 상황이 있는데, 바로 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 구문이다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;try...catch&lt;/code&gt;문이 처음으로 등장했던 ES3 (1999년) 부터, &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;는 블록 스코프 기능을 가지고 있었다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;doesntExist&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError: doesntExist is not defined&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; onlyHere &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; outerVariable &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;outerVariable&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// true&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;error&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError: error is not defined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;문에 의해 선언된 &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt;변수는 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;블록에 속하는 블록 스코프 변수이다. 또한 또 다른 블록 스코프 변수 (&lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;)를 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 블록 내에 포함할 수도 있다. 하지만 함수 스코프인 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;블록에 귀속되지 않고 함수 스코프 방식(여기서는 글로벌 스코프)으로 동작한다.&lt;/p&gt;
&lt;p&gt;ES2019 부터는 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;문에 변수를 선언하지 않을 수도 있다 (즉, &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; 변수 없이 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt;를 사용). 만약 이렇게 하면 &lt;code class=&quot;language-text&quot;&gt;catch&lt;/code&gt; 블록은 “블록” 이지만 “스코프”가 아니게 된다. 따라서 &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; 변수를 굳이 사용할 필요가 없다면 변수를 생략해도 된다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;doSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;doAnotherOne&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;블록-내에서-함수-선언하기-fib&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9D-%EB%82%B4%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%ED%95%98%EA%B8%B0-fib&quot; aria-label=&quot;블록 내에서 함수 선언하기 fib permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블록 내에서 함수 선언하기 (FiB)&lt;/h2&gt;
&lt;p&gt;이제껏 우리는 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;가 함수 스코프, &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;(그리고 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;)는 블록 스코프라는 것을 살펴보았다. 그렇다면 블록 내에 존재하는 함수 선언은 어떻게 처리될까? 이 문제를 Function Declarations in Blocks (Fib)라고 한다. 우리는 흔히 함수 선언이 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 유사하다고 생각한다. 그럼 함수 선언도 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 같이 함수 스코프일까?&lt;/p&gt;
&lt;p&gt;그럴 수도 있고, 아닐 수도 있다. 하이고… 골이 땡긴다 🤦&lt;/p&gt;
&lt;p&gt;한번 천천히 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;정말 실행되나?&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 실행하면 어떤 결과가 나올까?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ask&lt;/code&gt; identifier가 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt; 블록 내부에 존재하므로 블록 밖인 글로벌 스코프에서 &lt;code class=&quot;language-text&quot;&gt;ask()&lt;/code&gt;를 호출하면 &lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt;가 발생할 것 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ask&lt;/code&gt;라는 identifer가 존재는 하지만 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;이므로 (왜냐면 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문이 실행되지 않았기 때문에!) &lt;code class=&quot;language-text&quot;&gt;ask()&lt;/code&gt;를 호출하면 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt;가 발생할 것이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;ask()&lt;/code&gt;가 정상적으로 동작하여 결과가 출력될 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 때 정말 정말 혼란스러운 일이 발생한다. 위 코드의 결과는 자바스크립트 런타임(실행환경)에 따라 다를 수 있다! 이와 같은 상황은 자바스크립트에서 legacy로 인해 예측 불가능한 결과가 나오는 몇 안되는 상황 중 하나이다.&lt;/p&gt;
&lt;p&gt;자바스크립트 스펙을 살펴보면 블록 내부에 존재하는 함수 선언은 블록 스코프이어야 한다고 되어있다. 따라서, 따지고 보면 1번이 정답이다. 하지만 브라우저(엔진)들은 거의 대부분 2번 방식으로 동작할 것이다. 즉, 함수의 identifier가 블록 외부로 노출이 되지만 자동적으로 초기화 되지는 않기 때문에 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로 남아있게 된다.&lt;/p&gt;
&lt;p&gt;그렇다면 도대체 왜 브라우저(엔진)들은 스펙대로 동작하지 않고 자기 멋대로(?) 동작하는 걸까?? 그 이유는, 브라우저들은 ES6에서 블록 스코프에 대한 개념이 생기기 전부터 이미 FiB에 관해 특정한 방식으로 동작해왔기 때문이다. 만약 스펙대로 동작하고자 기존에 동작하던 방식을 바꿔버리면 웹사이트들이 정상적으로 동작하지 못하게 될 수 있기 때문에 스펙과 다르게 동작하는 것이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;함수 선언을 블록 내부에 하는 경우 중 한 예시는 다음 코드와 같이 특정 조건에 따라 함수를 다르게 정의하는 경우이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isArray &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;undefined&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;[object Array]&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이와 같은 방법으로 코딩하는 이유는, 만약 함수 내부에서 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문을 사용하여 동작을 다르게 정의하면 매번 함수를 호출할 때마다 불필요하게 체킹을 해야 하므로 성능상의 패널티가 존재하기 때문이다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;⚠️ 경고&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FiB의 예측 불허한 특성 이외에, 위 코드와 같이 분기문을 통해 여러 버전의 함수를 만들게 되면 디버깅이 (매우) 힘들어지는 단점이 있다. 예를 들어, &lt;code class=&quot;language-text&quot;&gt;isArray()&lt;/code&gt; 함수에 버그가 발생하여 해당 버그를 고쳐야할 때 우선 어느 버전의 &lt;code class=&quot;language-text&quot;&gt;isArray()&lt;/code&gt;에 문제가 생겼는지 살펴봐야한다. 가끔 분기 조건을 잘못 체크하여 엉뚱한 버전을 고치는 경우가 발생할 수도 있다. 따라서 하나의 함수에 대해 분기문을 통해 여러 버전을 만드는 경우, 디버깅이 매우 힘들어 질 수 있다는 점을 분명히 염두해야 한다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;br/&gt;
&lt;p&gt;앞서 살펴본 예시 외에도 FiB에 대한 여러가지 이례적인 케이스들이 도사리고 있다. 이러한 케이스들도 물론 자바스크립트 실행환경에 따라 다르게 동작한다. 예를 들면:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;이거 호출?&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;아니면 이거 호출?&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;그것도 아니면 이것들 중 하나?&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;ask&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;아 혹시 이건가?&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;함수 호이스팅을 고려해 본다면 &lt;code class=&quot;language-text&quot;&gt;아 혹시 이건가?&lt;/code&gt;를 출력하는 제일 마지막 &lt;code class=&quot;language-text&quot;&gt;ask()&lt;/code&gt; 함수가 &lt;code class=&quot;language-text&quot;&gt;ask();&lt;/code&gt; 출력 바로 위에 호이스팅 되어 이 함수가 실행될 것이라 예측할 수도 있다. 진짜 그럴까? &lt;/p&gt;
&lt;p&gt;아니다 (하… 🤦‍♂️)&lt;/p&gt;
&lt;p&gt;이러한 이상한(?) 케이스들을 전부 소개할 생각도 없고, 왜 이런식으로 동작하는지 설명할 생각은 더더욱 없다. 내 생각(원문 저자)엔 이러한 경우들은 그냥 미스테리한 legacy 동작들이다.&lt;/p&gt;
&lt;p&gt;적어도 내가 생각하기로는, 이렇게 이상하게 동작하는 FiB를 피하는 가장 실용적인 해결책은 &lt;strong&gt;그냥 FiB를 사용하지 않는것&lt;/strong&gt;이다. 즉, 블록안에서 함수 선언을 하지말고 항상 가장 바깥 함수 스코프(만약 여러 스코프가 중첩된 경우 그 중 가장 바깥) 혹은 글로벌 스코프에다 함수를 선언하는 것이 예측 불가능한 상황들을 피할 수 있는 방법인 것 같다.&lt;/p&gt;
&lt;p&gt;따라서 앞에서 살펴본 두 버전의 &lt;code class=&quot;language-text&quot;&gt;isArray&lt;/code&gt;를 선언하는 방법은 다음과 같이 할 수 있을 것 같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isArray &lt;span class=&quot;token operator&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;undefined&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;[object Array]&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아 물론이다. 이렇게 하면 다소 성능이 저하될 수는 있다. 하지만 보다 전체적인 관점에서 봤을 때 이렇게 하는 것이 더 좋을 것이다.&lt;/p&gt;
&lt;p&gt;만약 위와 같이 코딩함으로 인해 발생하는 성능 저하가 애플리케이션에 치명적이라면, 다음과 같이 코딩할 수도 있을 것이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// override the definition, if you must&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;typeof&lt;/span&gt; Array&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;isArray &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;undefined&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function-variable function&quot;&gt;isArray&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;isArray&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;prototype&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;[object Array]&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 유심히 살펴봐야 할 것은, &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문 내부에서 함수 선언문 말고 함수 표현식을 사용했다는 점이다. 이렇게 “함수 표현식”을 블록 안에 사용하는 것은 괜찮다. 우리가 앞에서 피하고자 했던 FiB는 블록 내부에 함수 표현식이 아니라 함수 선언문을 사용하는 것이었다.&lt;/p&gt;
&lt;p&gt;만약 FiB 스타일로 코딩을 해서 테스팅 했을 때 정상적으로 돌아간다고 쳐도, FiB 스타일로부터 얻는 이점보다 추후에 FiB의 예측불가능한 특성으로 인한 단점이 더 커질 것이다. 따라서 되도록이면 FiB 스타일을 사용하지 말자.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 호이스팅]]></title><description><![CDATA[이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables…]]></description><link>https://jaehyeon48.github.io/javascript/hoisting/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/hoisting/</guid><pubDate>Wed, 19 Aug 2020 16:21:13 GMT</pubDate><content:encoded>&lt;p&gt;이 글은 아래의 원문을 번역/요약한 글입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch5.md&quot;&gt;You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;언제-변수를-사용할-수-있을까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%96%B8%EC%A0%9C-%EB%B3%80%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;언제 변수를 사용할 수 있을까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;언제 변수를 사용할 수 있을까?&lt;/h2&gt;
&lt;p&gt;스코프 내에 있는 변수는 어느순간 부터 사용 가능한 걸까? 변수가 선언(생성)된 시점부터 사용할 수 있지 않을까?? 꼭 그렇지만은 않다. 다음 코드를 생각해보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hello!&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;Hello!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아마 이런식의 코드를 작성해본 경험이 있을 것이다. 이 코드는 아주 잘 작동한다 하지만 이런방식의 코드가 어떻게, 혹은 왜 동작하는지 생각해본적이 있는가? 위 코드에서, 함수 &lt;code class=&quot;language-text&quot;&gt;greeting()&lt;/code&gt; 은 분명 3번째 줄에 선언되었는데 어째서 1번째 줄에서 해당 함수를 호출할 수 있는걸까?&lt;/p&gt;
&lt;p&gt;자바스크립트 코드가 컴파일되는 과정에서 모든 identifier들은 각자가 속한 스코프에 “등록”된다 (사실 자바스크립트는 인터프리터 언어라기 보다 컴파일 언어에 더 가깝다!). 특히, 어떤 스코프에 진입(enter)했을 때 해당 스코프의 모든 identifier들이 스코프의 시작 부분에 “생성”된다. &lt;/p&gt;
&lt;p&gt;이렇게 변수들이 스코프 (한참) 아래에 선언되어 있음에도 불구하고 해당 스코프에 진입하자 마자 스코프의 모든 변수들에 접근할 수 있게 되는 현상을 &lt;strong&gt;호이스팅(hoisting)&lt;/strong&gt; 이라고 한다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;하지만 호이스팅만으로는 위 질문에 대한 답을 할 수 없다. 스코프 시작 부분에서 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 identifier를 “볼 수 있지만”, 어떻게 함수를 “호출”까지 할 수 있게 되는걸까? 다시말해, 어떻게 스코프가 시작할 때 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 identifier가 값(여기서는 함수 레퍼런스)을 가질 수 있게 되는 것일까?&lt;/p&gt;
&lt;p&gt;이 질문에 대답은 &lt;strong&gt;함수 호이스팅(function hoisting)&lt;/strong&gt;으로 설명할 수 있다. 즉, &lt;code class=&quot;language-text&quot;&gt;function&lt;/code&gt; 키워드로 선언된 (“함수를 formal하게 선언한다” 라고함) 함수의 identifier가 자동적으로 스코프의 상단에 등록될 때, 이 identifier는 자동적으로 자신의 함수 레퍼런스로 초기화된다. 이렇게 자동적으로 자신의 함수 레퍼런스로 초기화 됨으로 인해 (&lt;code class=&quot;language-text&quot;&gt;function&lt;/code&gt; 키워드로 선언된) 함수를 스코프 내의 어디에서나 호출할 수 있는 것이다.&lt;/p&gt;
&lt;p&gt;참고로, 함수 호이스팅과 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수의 호이스팅은 함수 스코프 단위로 일어나고, &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수의 호이스팅은 블록 스코프 단위로 일어난다.&lt;/p&gt;
&lt;h2 id=&quot;함수-호이스팅-함수-선언문-vs-함수-표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8-vs-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;함수 호이스팅 함수 선언문 vs 함수 표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;함수 호이스팅: 함수 선언문 vs. 함수 표현식&lt;/h2&gt;
&lt;p&gt;위에서 살펴봤듯이, 함수 호이스팅은 오직 “함수 선언”(&lt;code class=&quot;language-text&quot;&gt;function&lt;/code&gt; 키워드를 이용한 함수 선언)에만 적용된다. 함수 표현식(function expression)에는 적용되지 않는다. 다음 코드를 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// TypeError: greeting is not a function&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;hi&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 가 발생했다는 점에 주목해보자. &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 는 어떤 값에 대해 허용되지 않는 동작을 수행했다는 의미이다. 자바스크립트 실행 환경에 따라 &lt;code class=&quot;language-text&quot;&gt;&apos;undefined&apos; is not a function&lt;/code&gt; 과 같은 메시지가 나올 수도 있다.&lt;/p&gt;
&lt;p&gt;중요한 것은 에러의 종류가 &lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt; 가 아니라 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 라는 점이다. 즉, 스코프 내에서 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 identifier를 못찾았다는 것이 아니라, &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 identifier는 찾았지만 해당 순간에 함수를 가리키고(reference) 있지 않았다는 뜻이다. 함수가 아닌 것에다 함수 호출을 했으니 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 가 발생한 것이다.&lt;/p&gt;
&lt;p&gt;그렇다면 그 순간에 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 은 어떤 값을 저장하고 있었을까? &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수의 경우, 호이스팅 될 때 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 로 초기화된다. 그러다 자신이 원래 선언된 위치로 오게 되면 비로소 원래의 값으로 할당되는 것이다. 위 코드의 경우, 3번째 줄이 되어서야 &lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 변수가 함수를 가리키게 된다.&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;종합해보면 이렇다. 함수 선언(function declaration)은 스코프 맨 위로 hoist 될 때 자동적으로 원래 가리키고 있던 함수로 초기화된다. &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수는 hosit될 때 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 로 초기화 된다. 함수 표현(function expression)의 경우, 프로그램 실행 때 원래 선언된 위치에서 변수가 함수 표현을 reference 하게 된다.&lt;/p&gt;
&lt;h2 id=&quot;변수-호이스팅&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85&quot; aria-label=&quot;변수 호이스팅 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;변수 호이스팅&lt;/h2&gt;
&lt;p&gt;이번에는 변수 호이스팅에 대해 좀 더 알아보자.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;greeting &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;greeting&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hello&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; greeting &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Howdy!&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 변수가 4번째 줄에 선언되었음에도 불구하고 1번째 줄에서 정상적으로 값을 할당하고 있는데, 그 이유는&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;greeting&lt;/code&gt; 이라는 identifier가 hoist 되었기 때문이고,&lt;/li&gt;
&lt;li&gt;해당 스코프의 최상단에서 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 로 할당되었기 때문이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;비유&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B9%84%EC%9C%A0&quot; aria-label=&quot;비유 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;비유&lt;/h3&gt;
&lt;p&gt;호이스팅을 설명하는 글에서 주로 사용하는 비유는 “들어올린다”(lift)는 것이다. 즉, 무거운 물건을 들어올리듯이 identifier들을 스코프의 최상단으로 들어올린다는 것이다. 어떤 경우, 자바스크립트 엔진이 다음 코드와 같이 실제로 소스 코드를 변경하여 identifier를 재배치 한다고 하는 글도 있다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; greeting&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
greeting &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Hello&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;greeting&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hello&lt;/span&gt;
greeting &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Howdy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, 함수 호이스팅의 경우 프로그램 실행 전에 엔진이 함수 선언부 전체를 hoist 한다고 주장하는 경우도 있다. 거기다 함수 선언문이 먼저 호이스팅 되고 그 다음에 변수가 호이스팅 된다고 주장한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 호이스팅 전&lt;/span&gt;
studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hi, Suzy!&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hi, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 호이스팅 후&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;Hi, &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Hi, Suzy!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이러한 비유는 호이스팅을 비교적 쉽게 설명할 수 있다는 장점이 있지만, 사실 이는 정확한 표현이 아니다. &lt;strong&gt;자바스크립트는 코드를 재배열하지 않는다!&lt;/strong&gt; 단지 코드를 실행하기 전에 코드를 분석(parse) 해서 스코프 내의 identifier를 찾아놓을 뿐이다.&lt;/p&gt;
&lt;p&gt;즉, 호이스팅 이라는 것은 runtime과 관련된 것이 아니라 compile-time과 관련된 작업이다. 프로그램 실행(runtime)때 엔진이 코드를 바꿔서 실행하는 것이 아니라, 컴파일(compile-time)때 코드를 분석하여 스코프 내에 있는 identifier들을 찾아 정리해놓는 것이다.&lt;/p&gt;
&lt;h2 id=&quot;재할당&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%AC%ED%95%A0%EB%8B%B9&quot; aria-label=&quot;재할당 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;재할당?&lt;/h2&gt;
&lt;p&gt;만약 다음과 같이 어떤 스코프 내에서 동일한 변수가 두 번 이상 선언되면 어떻게 될까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Frank&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ?&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;두 번째 &lt;code class=&quot;language-text&quot;&gt;var studentName&lt;/code&gt; 이 해당 변수를 “재선언(re-declared)” 했으므로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 를 출력하는 것이 맞을까? 아니다. 사실 “재선언” 이라는 것은 존재하지 않는다. 앞서 살펴본 호이스팅에 빗대어 살펴보자면 위 코드는 다음과 같다고 할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// no-op&lt;/span&gt;
studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Frank&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Frank&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;호이스팅 이라는 것이 실제로는 스코프의 시작 부분에 변수들을 등록하는 것이므로, 위와 같이 두 번째 선언문은 사실상 의미없는 no-op(no-operation) 문장이다.&lt;/p&gt;
&lt;p&gt;또한 한 가지 알아둬야할 것이,  &lt;code class=&quot;language-text&quot;&gt;var studentName;&lt;/code&gt; 문장은 &lt;code class=&quot;language-text&quot;&gt;var studentName = undefined;&lt;/code&gt; 와 동일한 문장이 아니다! 다음 코드를 통해 이와 같은 사실을 알 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Frank&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 여전히 Frank&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;undefined&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 명시적으로 undefined로 초기화&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 의 경우는 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 실행하면 즉시 &lt;code class=&quot;language-text&quot;&gt;SyntaxError&lt;/code&gt; 가 발생하는 것을 볼 수 있다. 그 이유는 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; (그리고 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;) 의 경우 재선언이 불가능하기 때문이다.&lt;/p&gt;
&lt;p&gt;물론, 다음과 같은 경우도 불가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// OR&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 의 경우 규칙이 더 엄격하다. &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 과 같이 재선언이 불가능함은 물론, &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수는 선언할 때 &lt;strong&gt;무조건&lt;/strong&gt; 초기화 해야한다. 그리고 초기화한 후 값을 재할당 하는 것이 불가능하다.&lt;/p&gt;
&lt;p&gt;즉, 다음과 같은 코드는 불가능하다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; myVariable&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// SyntaxError -&gt; 무조건 선언과 동시에 초기화 해야함&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Frank&lt;/span&gt;
studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// TypeError -&gt; 재할당 불가&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수에 재할당을 할 때 발생한 에러가 &lt;code class=&quot;language-text&quot;&gt;SyntexError&lt;/code&gt; 가 아니라 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 라는 점에 주목해보자. 이 두 개의 에러간에는 미묘한 차이가 있는데, &lt;code class=&quot;language-text&quot;&gt;SyntaxError&lt;/code&gt; 는 프로그램을 미처 실행하기도 전에 발생한 에러이고, &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt; 는 프로그램 실행 도중에 발생한 에러이다. 위 코드에서 보면 재할당 하기전의 &lt;code class=&quot;language-text&quot;&gt;console.log(studentName);&lt;/code&gt; 문장에서 정상적으로 &lt;code class=&quot;language-text&quot;&gt;Frank&lt;/code&gt; 가 출력됨을 알 수 있다. 만약 &lt;code class=&quot;language-text&quot;&gt;SyntaxError&lt;/code&gt; 였다면 프로그램이 실행조차 되지 않아 &lt;code class=&quot;language-text&quot;&gt;Frank&lt;/code&gt; 가 출력되지 못했을 것이다.&lt;/p&gt;
&lt;h2 id=&quot;루프문&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A3%A8%ED%94%84%EB%AC%B8&quot; aria-label=&quot;루프문 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;루프문&lt;/h2&gt;
&lt;p&gt;이제까지 살펴본 바로는, 변수를 “재선언” 하는 것은 바람직하지 않은 것 같다. 그렇다면 루프문에선 어떨까? 다음 코드를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keepGoing&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 while문 안에 있는 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 변수는 계속해서 “재선언” 되는 것일까? 그렇다면 에러가 발생하는 걸까?&lt;/p&gt;
&lt;p&gt;정답은 “재선언 되지 않는다” 이다. 스코프에 관련된 규칙들은 &lt;strong&gt;스코프 인스턴스에 개별적&lt;/strong&gt;으로 적용된다. 다시말해, 실행중에 매 순간 스코프에 진입(enter)할 때마다 모든것이 리셋된다.&lt;/p&gt;
&lt;p&gt;루프문의 경우, &lt;strong&gt;각 iteration은 각자의 스코프 인스턴스를 갖는다&lt;/strong&gt;. 위 코드의 경우, while문 각각의 iteration은 서로 별개의 “스코프 인스턴스”이고, 각 스코프 인스턴스에서 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 변수는 오직 한 번만 선언된다. 따라서 각 스코프 인스턴스 별로 한 번만 선언되므로 재선언이 발생하지 않는 것이고, 그에 따라 어떠한 에러도 발생하지 않는 것이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 의 경우는 어떨까? 위 코드에서 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 로 선언되면 어떤 일이 발생하는 걸까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keepGoing&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수는 재선언을 허용하므로 여기서는 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 변수가 계속해서 재선언 되는 것일까?&lt;/p&gt;
&lt;p&gt;아니다.  &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수는 “함수 스코프”로 취급되므로 위 코드에서 변수 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 는 글로벌 스코프에 오직 한 번만 선언되고, 값만 계속해서 재할당 되는 것이다. 위 코드에서 while문 바로 아래에 &lt;code class=&quot;language-text&quot;&gt;console.log()&lt;/code&gt; 를 이용하여 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 가 글로벌 스코프로 선언되었음을 확인할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keepGoing&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 0.5보다 큰값&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 여기서 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 으로 선언되었다면 &lt;code class=&quot;language-text&quot;&gt;ReferenceError&lt;/code&gt; 가 발생할 것이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프에서는 어떨까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;value&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 0: 0&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 1: 10&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// 2: 20&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서도 마찬가지로, &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 각 iteration 마다 별개의 스코프 인스턴스가 존재하고, &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 변수는 각 스코프 인스턴스 내에서 오직 한 번만 선언된다.&lt;/p&gt;
&lt;p&gt;그렇다면 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 는 어떤가? (&lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 도 변수이다!) &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 는 “재선언” 되는 것일까? 이 물음에 대한 해답을 찾기 위해 우선 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 가 어떤 스코프에 속해있는지를 살펴보자. 언뜻 보기엔 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 바깥 스코프(위 코드의 경우, 글로벌 스코프)에 속해있는것 같지만 아니다. &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 와 같이 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 스코프에 속해있다.&lt;/p&gt;
&lt;p&gt;좀 더 쉽게 이해하기 위해, 위 코드가 내부적으로 다음과 같이 변환된다고 생각할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 물론 실제로 이렇게 변환되는 것은 아니다.&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; $$i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $$i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $$i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; $$i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;value&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드를 보면 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 가 어느 스코프에 속하는지 좀 더 명확해보인다. 즉, &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 도 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt; 와 마찬가지로 각 iteration의 스코프 인스턴스에 속하여 오직 한 번만 선언된다.&lt;/p&gt;
&lt;p&gt;다음과 같은 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 형태도 논리는 동일하다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; someObj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; students&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* ... */&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서도 변수(&lt;code class=&quot;language-text&quot;&gt;key&lt;/code&gt; , &lt;code class=&quot;language-text&quot;&gt;student&lt;/code&gt;) 는 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 각 iteration 스코프 인스턴스에 속한다. 따라서 이 경우에도 재선언은 일어나지 않는다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;그럼 이제 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 의 경우도 한번 살펴보자. 사실 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 도 앞서 살펴본 경우와 동일하게 동작한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;keepGoing&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; keepGoing &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프의 경우도 마찬가지다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; key &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; someObj&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; student &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; students&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만 문제가 하나 있다. 다음을 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// 첫 번째 iteration 이후 에러 발생!!&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;// TypeError: Assignment to constant variable.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;왜 에러가 발생하는 것일까? 앞에서 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 을 통해 살펴보았을 때는 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 가 각 iteration 스코프마다 선언되므로 전혀 문제가 없었다!&lt;/p&gt;
&lt;p&gt;하지만 위 코드를 다음과 같이 확장해보면 문제를 금방 파악할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; $$i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $$i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; $$i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; $$i&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; value &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;i&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;: &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;value&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 보면 알 수 있겠지만, 여기서도 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 가 각 iteration 스코프 마다 선언되는 것은 맞다. 이는 재선언이 아니므로 전혀 문제되지 않는다.&lt;/p&gt;
&lt;p&gt;진짜 문제는, 가상의 &lt;code class=&quot;language-text&quot;&gt;$$i&lt;/code&gt; 의 값이 변한다는 점이다. 즉, &lt;code class=&quot;language-text&quot;&gt;$$i++&lt;/code&gt; 표현식에서 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 타입의 &lt;code class=&quot;language-text&quot;&gt;$$i&lt;/code&gt; 값을 바꾸고 있기 때문에 에러가 발생하는 것이다.&lt;/p&gt;
&lt;p&gt;물론 위 코드는 어디까지나 이해를 돕기 위해 만들어낸 &lt;strong&gt;가상의&lt;/strong&gt; 코드이다. 실제로 자바스크립트 엔진이 &lt;code class=&quot;language-text&quot;&gt;$$i&lt;/code&gt; 를 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 변수로 선언할 수도 있다. 하지만 이렇게 하면 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 를 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt; 루프에서 사용할 때 예외적인 상황이 발생하는 것이므로 그리 바람직할 것 같지는 않다.&lt;/p&gt;
&lt;h2 id=&quot;tdz-temporal-dead-zone&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tdz-temporal-dead-zone&quot; aria-label=&quot;tdz temporal dead zone permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TDZ, Temporal Dead Zone&lt;/h2&gt;
&lt;p&gt;앞서 우리는 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 변수가 스코프의 최상단 부분으로 호이스팅 될 때 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt; 로 초기화 된다는 사실을 살펴보았다.&lt;/p&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 의 경우는 조금 다르다. 다음을 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드를 실행하면 &lt;code class=&quot;language-text&quot;&gt;ReferenceError: Cannot access &apos;studentName&apos; before initialization&lt;/code&gt; 와 같은 에러가 발생한다. 에러 메시지를 살펴보면, &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt; 이라는 변수가 (첫째 줄에) 존재하기는 하나, 아직 초기화 되지 않아 사용할 수 없다는 의미이다.&lt;/p&gt;
&lt;p&gt;그럼 다음과 같이 초기화 해주면 될까?&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여전히 동일한 에러가 발생한다. 뭐가 문제일까? 초기화 되지 않은(uninitialized) 변수를 어떻게 초기화(initialize)할 수 있을까?&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 의 경우, 해당 변수를 “초기화”하는 &lt;strong&gt;유일한 방법&lt;/strong&gt;은 &lt;strong&gt;변수를 선언할 때 초기화&lt;/strong&gt; 하는 방법밖에 없다. 즉,&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Suzy&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// 혹은&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// Suzy&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;스코프에 진입하여 변수가 자동적으로 초기화 될 때까지 해당 변수를 사용할 수 없는 &lt;strong&gt;기간&lt;/strong&gt;을 TDZ라고 한다. 즉, TDZ란 변수가 존재는 하지만 아직 초기화 되지 않아서 사용할 수 없는 구간이라 할 수 있다. 변수가 원래 선언된 위치에 도달해서야 비로소 해당 변수를 사용할 수 있게 되는 것이다. 다음 코드에 대해 TDZ를 그림으로 나타내면 아래와 같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pi&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; pi &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;3.14&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;pi&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/hoisting/tdz.png&quot; alt=&quot;TDZ example&quot;&gt;
    &lt;figcaption&gt;TDZ 예시&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;사실 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt; 도 TDZ가 존재하지만, TDZ의 크기가 0이라서 눈에 보이지는 않는다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;한편, TDZ는 “위치”가 아니라 “시간”과 관련된 개념이다. 다음 코드를 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, do you know?&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위치적으로 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt; 을 참조하는 &lt;code class=&quot;language-text&quot;&gt;console.log&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;let studentName = &apos;Suzy&apos;;&lt;/code&gt; 선언문보다 뒤에 존재하지만, 시간적으로 봤을 때 &lt;code class=&quot;language-text&quot;&gt;askQuestion()&lt;/code&gt; 함수 호출이 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt; 의 초기화 보다 먼저 일어나기 때문에 TDZ 에러가 발생한 것이다.&lt;/p&gt;
&lt;p&gt;혹자는 다음과 같이 호이스팅이 일어나기 때문에 에러가 발생하지 않는 것 아니냐고 물을 수도 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;studentName&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;, do you know?&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; studentName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;askQuestion&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// undefined, do you know?&lt;/span&gt;

studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;앞서도 언급했지만 “호이스팅” 이라는 것은 개념적인 것이다. 즉, &lt;strong&gt;실제로는 자바스크립트를 컴파일 하는 과정에서 identifier들을 스코프의 맨 윗부분에 등록하는 과정을 호이스팅&lt;/strong&gt; 이라고 부르는 것이다. 실제로 위 코드와 같은 일이 일어나는 것이 아니다.&lt;/p&gt;
&lt;p&gt;그럼 어떻게 TDZ 에러를 피할 수 있을 까? 한 가지 방법은, 항상 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수 선언문을 스코프 맨 윗부분에 작성하는 것이다. 이렇게 하면 TDZ의 크기(length)를 0으로 만들어 TDZ 에러를 예방할 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;tdz-좀-더-살펴보기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tdz-%EC%A2%80-%EB%8D%94-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0&quot; aria-label=&quot;tdz 좀 더 살펴보기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TDZ 좀 더 살펴보기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#whats-the-deal-with-tdz&quot;&gt;원문&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;우선 TDZ가 생겨난 배경부터 살펴보자. 사실 TDZ는 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;로 인해 생겨난 개념이다.&lt;/p&gt;
&lt;p&gt;초기에 ES6를 개발할 때, TC39 멤버들은 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;(와 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;)가 블록의 최상단으로 호이스팅 되어야 하는지 결정했어야 했고, 결국 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 같이 호이스팅 되도록 설계했다. &lt;/p&gt;
&lt;p&gt;근데 왜 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와는 달리 자동적으로 (&lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로) 초기화되지 않는걸까? 다음 코드를 통해 그 이유를 알 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 어떤 값이 출력될까?&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;studentName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; studentName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;만약 위 코드에서 &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt; 변수가 블록 최상단으로 호이스팅될 뿐만 아니라, 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로 초기화된다고 가정해보자. 그렇게 되면 &lt;code class=&quot;language-text&quot;&gt;const studentName = &apos;Frank&apos;;&lt;/code&gt;문장을 기준으로, &lt;code class=&quot;language-text&quot;&gt;studentName&lt;/code&gt;이 윗 부분에선 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;의 값을 가질 것이고, 변수 선언문 부터는 &lt;code class=&quot;language-text&quot;&gt;&apos;Frank&apos;&lt;/code&gt;라는 값을 가질 것이다.&lt;/p&gt;
&lt;p&gt;하지만 생각해보면 이상하지 않은가? &lt;strong&gt;상수(constant)&lt;/strong&gt;가 서로 다른 두 개의 값을 가지는 것은 말이 안되는 것 같다! 바로 여기서 문제가 발생한 것이다. 즉, &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수는 오직 최초에 초기화된 값 하나만 가질 수 있으므로 호이스팅 되면서 자동적으로 &lt;code class=&quot;language-text&quot;&gt;undefined&lt;/code&gt;로 초기화 되는것은 말이 안된다. 하지만 호이스팅은 일어나므로 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 선언문이 어디에 있건 관계없이 변수 전역에서 해당 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt; 변수를 “볼 수 있어야 한다(visible)“. 그럼 해당 변수가 존재하기 시작하는 시점인 스코프의 최상단으로부터 변수가 초기화되는 시점(변수의 선언문이 존재하는 위치) 까지의 “기간(period of time)“은 어떻게 처리해야할까?&lt;/p&gt;
&lt;p&gt;우리는 이러한 “기간”을 ”&lt;strong&gt;dead zone&lt;/strong&gt;“이라고 부르기로 했다. 따라서 호이스팅은 일어나지만 값이 자동적으로 초기화 되지 않음으로 인해 발생하는 혼란일 방지하고자 TDZ에 있는 변수를 참조하게 되면 TDZ에러를 발생시킨다.&lt;/p&gt;
&lt;h3 id=&quot;그렇다면-let은&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-let%EC%9D%80&quot; aria-label=&quot;그렇다면 let은 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;그렇다면 let은?&lt;/h3&gt;
&lt;p&gt;TDZ가 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;때문에 생겨난 것은 알겠다. 그럼 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;은 왜 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;와 같이 동작하는 걸까? &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;은 여러 값을 가져도 괜찮잖아?&lt;/p&gt;
&lt;p&gt;그러게 말이다. 하지만 TC39에서 “일관성”을 위해 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;도 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;와 동일하게 TDZ를 적용시켰다. 하지만 내 생각(원문 저자)엔 “일관성”을 유지하고자 그러한 결정을 내린것이라면 차라리 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;으로 하여금 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 같이 동작하도록 했으면 어땠을까 싶다. 분명 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;보다는 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;에 더 가까운 편이니까.&lt;/p&gt;
&lt;p&gt;TDZ에 관한 추가적인 학습은 다음 링크를 참고하길 바란다:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dmitripavlutin.com/javascript-variables-and-temporal-dead-zone/&quot;&gt;Don’t Use JavaScript Variables Without Knowing Temporal Dead Zone&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js의 이벤트 루프 Part1]]></title><description><![CDATA[2부 보러가기 이벤트 루프란? 이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation…]]></description><link>https://jaehyeon48.github.io/javascript/nodejs_event_loop_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/nodejs_event_loop_1/</guid><pubDate>Wed, 19 Aug 2020 14:20:15 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../nodejs_event_loop_2/&quot;&gt;2부 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h2 id=&quot;이벤트-루프란&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%9E%80&quot; aria-label=&quot;이벤트 루프란 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 루프란?&lt;/h2&gt;
&lt;p&gt;이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation들을 커널에 맡기는 방식으로 진행하는데, 대부분의 현대 운영체제들은 멀티 스레드이므로 백그라운드에서 여러 operation들을 동시에 실행시키는 것이 가능하다.&lt;/p&gt;
&lt;p&gt;이렇게 백그라운드에서 operation을 처리하다가 해당 작업을 완료하면 커널이 Node.js에게 작업이 완료되었다고 알리고, 알림을 받은 Node.js는 적절한 핸들러(콜백)를 &lt;code class=&quot;language-text&quot;&gt;poll queue&lt;/code&gt; 에 등록하여 이 콜백을 (추후에) 실행한다. 더 자세한 사항들은 잠시 후에 살펴보자.&lt;/p&gt;
&lt;h2 id=&quot;이벤트-루프-살펴보기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0&quot; aria-label=&quot;이벤트 루프 살펴보기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 루프 살펴보기&lt;/h2&gt;
&lt;p&gt;Node.js를 실행하게 되면 이벤트 루프를 초기화하고 (개발자가 작성한) 자바스크립트 파일을 실행한다. 이벤트 루프의 전체적인 흐름을 그림으로 나타내면 다음과 같다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop1.png&quot; alt=&quot;event loop example 1&quot; style=&quot;width:721px; height: 550px&quot;&gt;
    &lt;figcaption&gt;출처: https://www.voidcanvas.com/nodejs-event-loop/&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop2.png&quot; alt=&quot;event loop example 2&quot; style=&quot;width:798px; height: 500px&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;br/&gt;
&lt;p&gt;이벤트 루프의 각 단계를 &lt;code class=&quot;language-text&quot;&gt;phase&lt;/code&gt; 라고 하며, 각각의 phase마다 콜백을 실행할 FIFO 구조의 큐를 가지고 있어서 이벤트 루프가 각 phase에 진입하면 해당 phase에서 수행해야 할 operation들을 수행한 후 해당 phase 큐에 있는 모든 콜백 (혹은 일정한 수의 콜백)을 실행한다.&lt;/p&gt;
&lt;p&gt;모든 콜백 (혹은 limit을 넘지않는 수의 콜백)을 처리하고 나면 이벤트 루프는 다음 phase로 이동하여 위 동작들을 반복한다. 이 때, 어떤 phase에서 다음 phase로 넘어가는 과정을 &lt;code class=&quot;language-text&quot;&gt;tick&lt;/code&gt; 이라고 한다.&lt;/p&gt;
&lt;p&gt;위 그림 중 첫 번째 그림은 이벤트 루프를 libuv의 관점에서 본 것이고, 두 번째 그림은 자바스크립트의 관점에서 본 것이라 할 수 있다. 위 두 관점을 하나로 합쳐 다음 그림으로 표현할 수 있다:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop3.png&quot; alt=&quot;event loop example 3&quot;&gt;
    &lt;figcaption&gt;출처: https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;phase-overview&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#phase-overview&quot; aria-label=&quot;phase overview permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Phase Overview&lt;/h2&gt;
&lt;p&gt;각 phase들이 무엇인지 간략하게 살펴보면 다음과 같다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Timer**&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;setInterval()&lt;/code&gt; 에 의해 등록된 콜백들을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Pending I/O callbacks**&lt;/code&gt; : 이벤트 루프의 이전 iteration에서 실행되지 못한 콜백들을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Idle, prepare**&lt;/code&gt; : 이벤트 루프와 직접적인 관련은 없고, Node.js의 내부 관리를 위해 존재한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Poll**&lt;/code&gt; : 새로운 I/O 이벤트를 받아오고, I/O와 연관된 콜백들을 실행한다. &lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt; 이벤트에 대한 콜백, 타이머, &lt;code class=&quot;language-text&quot;&gt;setImmediate()&lt;/code&gt; 와 관련된 콜백을 제외한 사실상 대부분의 콜백이 이 phase에서 실행된다. 필요하다면 Node가 이 phase에서 block될 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Check**&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;setImmediate()&lt;/code&gt; 에 의해 등록된 콜백들을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**Close callbacks**&lt;/code&gt; : &lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt; 이벤트에 대한 콜백들이 실행된다. (e.g. &lt;code class=&quot;language-text&quot;&gt;socket.on(&apos;close&apos;, cb);&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;phase-자세히-살펴보기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#phase-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0&quot; aria-label=&quot;phase 자세히 살펴보기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Phase 자세히 살펴보기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;우선, 이벤트 루프가 구현된 코드는 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// UNIX 버전 기준. Windows 버전도 전체적인 구조는 동일하다.&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L369&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/master/deps/uv/src/win/core.c#L596&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv_run&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; uv_run_mode mode&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; timeout&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; r&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; ran_pending&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__loop_alive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;r&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__update_time&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;r &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;stop_flag &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__update_time&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__run_timers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    ran_pending &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__run_pending&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__run_idle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__run_prepare&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    timeout &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mode &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; UV_RUN_ONCE &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;ran_pending&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; mode &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; UV_RUN_DEFAULT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      timeout &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv_backend_timeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;uv__io_poll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; timeout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;/* Run one final update on the provider_idle_time in case uv__io_poll
     * returned because the timeout expired, but no events were received. This
     * call will be ignored if the provider_entry_time was either never set (if
     * the timeout == 0) or was already updated b/c an event was received.
     */&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__metrics_update_idle_time&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;uv__run_check&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv__run_closing_handles&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mode &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; UV_RUN_ONCE&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token comment&quot;&gt;/* UV_RUN_ONCE implies forward progress: at least one callback must have
       * been invoked when it returns. uv__io_poll() can return without doing
       * I/O (meaning: no callbacks) when its timeout expires - which means we
       * have pending timers that satisfy the forward progress constraint.
       *
       * UV_RUN_NOWAIT makes no guarantees about progress so it&apos;s omitted from
       * the check.
       */&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;uv__update_time&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;uv__run_timers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    r &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__loop_alive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mode &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; UV_RUN_ONCE &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; mode &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; UV_RUN_NOWAIT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token comment&quot;&gt;/* The if statement lets gcc compile it to a conditional store. Avoids
   * dirtying a cache line.
   */&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;stop_flag &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;stop_flag &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; r&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;각 메소드 들을 하나씩 순서대로 살펴보면 다음과 같다. phase와 관련된 메소드의 코드는 각각의 phase에 대해 알아볼 때 살펴보자.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__loop_alive()**&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// UNIX 버전&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L357&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__loop_alive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__has_active_handles&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;
         &lt;span class=&quot;token function&quot;&gt;uv__has_active_reqs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;
         loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;closing_handles &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// Windows 버전&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/core.c#L584&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__loop_alive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__has_active_handles&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;
         &lt;span class=&quot;token function&quot;&gt;uv__has_active_reqs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt;
         loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;endgame_handles &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 다음 세 조건 중 하나라도 만족하면 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 를, 모두 만족하지 못하면 &lt;code class=&quot;language-text&quot;&gt;false&lt;/code&gt; 를 반환한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;현재 active한 핸들러(콜백)가 있는가?&lt;/li&gt;
&lt;li&gt;현재 active한 요청(operation)이 있는가?&lt;/li&gt;
&lt;li&gt;closing 핸들러 (close 이벤트 핸들러)가 있는가?&lt;/li&gt;
&lt;li&gt;이벤트 루프의 iteration마다 &lt;code class=&quot;language-text&quot;&gt;uv__loop_alive()&lt;/code&gt; 를 호출하여 리턴값이 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt; 일 경우에만 계속해서 이벤트 루프를 돌린다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv_update_time()**&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv_update_time&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; new_time &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__hrtime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;new_time &lt;span class=&quot;token operator&quot;&gt;&gt;=&lt;/span&gt; loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;time&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;time &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new_time&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__hrtime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_clocktype_t&lt;/span&gt; type&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;timespec&lt;/span&gt; ts&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;clock_gettime&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;CLOCK_MONOTONIC&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;ts&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; ts&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tv_sec&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; NANOSEC &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; ts&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;tv_nsec&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;내부적으로 시스템 콜을 호출하여 현재 루프의 시간을 (ms의 정확도로) 업데이트 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__run_timers()**&lt;/code&gt; : Timer phase&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__run_pending()**&lt;/code&gt; : Pending I/O phase&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__run_idle() &amp;amp; uv__run_prepare()**&lt;/code&gt; : idle &amp;#x26; prepare phase&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__io_poll()**&lt;/code&gt; : poll phase&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__run_check**&lt;/code&gt; : check phase&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;**uv__run_closing_handles()&lt;/code&gt;** : close phase&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;timer-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#timer-phase&quot; aria-label=&quot;timer phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Timer phase&lt;/h3&gt;
&lt;p&gt;이벤트 루프가 &lt;code class=&quot;language-text&quot;&gt;Timer phase&lt;/code&gt; 에 진입하면 타이머 큐에 콜백들이 있는지를 살펴보고, 있으면 해당 콜백들을 실행한다. 사실, 편의상 타이머 “큐”라고 했지만 타이머 phase의 큐는 “queue” 자료구조가 아니라 “min-heap” 자료구조이다. 힙에는 타이머들이 각각의 타이머가 만료되는 시간을 기준으로 저장되며, 이벤트 루프가 이 힙에 있는 타이머를 하나씩 살펴보면서 실행한다.&lt;/p&gt;
&lt;p&gt;코드를 통해 조금 더 자세히 말하자면 다음과 같다. 일단 Timer phase는 내부적으로 &lt;code class=&quot;language-text&quot;&gt;uv__run_timers()&lt;/code&gt; 로 구현되어있다. 앞서 min-heap에 저장한 작업들 중 &lt;code class=&quot;language-text&quot;&gt;uv__update_time()&lt;/code&gt; 을 통해 계산한 현재 (iteration의) 시간과 각각의 타이머가 만료되는 시간을 비교하여 만료된 타이머의 콜백들을 실행한다. 다시말해, 만료되지 않은 타이머(즉, 아직 실행하면 안되고 더 나중에 실행해야하는 콜백의 타이머)를 발견할 때까지 계속해서 타이머를 체크해 나간다. 그러다 만료되지 않은 타이머를 발견하면 즉시 타이머 체크를 종료하고 다음 phase로 넘어간다.&lt;/p&gt;
&lt;p&gt;이 때, Timer phase에는 system-dependent한 limit이 존재하는데, 이로 인해 만약 만료된 타이머들이 남아있다고 하더라도 Timer phase를 수행한 시간이 limit을 넘게 되면 남아있는 만료된 타이머들(의 콜백)을 실행하지 않고 다음 phase로 넘어간다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/timer.c#L163&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__run_timers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;heap_node&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; heap_node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;uv_timer_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; handle&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    heap_node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;heap_min&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timer_heap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;heap_node &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    handle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;container_of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;heap_node&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_timer_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; heap_node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handle&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;timeout &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;time&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;uv_timer_stop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handle&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;uv_timer_again&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handle&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    handle&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timer_cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handle&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;Node.js의 타이머는 “정확히” 명시된 시간 이후에 실행되지 않는다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다시말해, &lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;setInterval()&lt;/code&gt; 에 지정해주는 delay(timer)는 콜백이 &lt;strong&gt;정확히&lt;/strong&gt; 얼마 뒤에 실행되는지를 나타내는 것이 아니라, 콜백이 &lt;strong&gt;적어도&lt;/strong&gt; 해당 delay 이후에 실행된다는 것을 나타낸다. 이는 현재 시간을 계산하고, 현재 시간과 타이머의 시간을 비교하는 작업이 CPU-intensive한 작업이라 다소 시간이 걸리기 때문이며 또한 현재 Node.js의 콜스택 상태 등에 영향을 받기 때문이다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;setTimeout(cb, 100)&lt;/code&gt; 에서 delay &lt;code class=&quot;language-text&quot;&gt;100&lt;/code&gt; 이 나타내는 의미는 콜백 &lt;code class=&quot;language-text&quot;&gt;cb&lt;/code&gt; 가 “정확히 100ms 이후에 실행된다”는 것이 아니라, “적어도 100ms 이후에” 혹은 “최소한 100ms 있다가” 실행된다는 의미이다. 따라서 해당 &lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt; 을 실행시킨 후 정확히 100ms 이후에 &lt;code class=&quot;language-text&quot;&gt;cb&lt;/code&gt; 가 실행되는지는 알 수 없다 (정확히 100ms 이후에 실행될 수도 있고, 100ms보다 더 뒤에 실행될 수도 있다).&lt;/p&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;타이머의 최소값은 1ms이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;한 가지 흥미로운 사실은, 만약 &lt;code class=&quot;language-text&quot;&gt;setTimeout(cb, 0);&lt;/code&gt; 과 같이 사용한다면 내부적으로 타이머 &lt;code class=&quot;language-text&quot;&gt;0ms&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 로 변환된다는 것이다.&lt;/p&gt;
&lt;p&gt;그 이유는 크롬에서 위와 같이 동작하기 때문인데, Node.js 에서도 크롬과 동일한 방식으로 동작하게 하기 위해 위와 같이 작동한다. 크롬의 V8 코드를 보면 다음과 같이 짜여있음을 알 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;cpp&quot;&gt;&lt;pre class=&quot;language-cpp&quot;&gt;&lt;code class=&quot;language-cpp&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/core/frame/DOMTimer.cpp#93&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;double&lt;/span&gt; intervalMilliseconds &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; std&lt;span class=&quot;token double-colon punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;oneMillisecond&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; interval &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; oneMillisecond&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉, 주어진 딜레이 값과 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 중에 더 큰 값을 타이머로 세팅하는 것을 볼 수 있다. 따라서 사실상 default 타이머는 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 라고 할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;pending-io-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#pending-io-phase&quot; aria-label=&quot;pending io phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Pending I/O phase&lt;/h3&gt;
&lt;p&gt;타이머 phase 이후, 이벤트 루프는 Pending I/O phase에 진입하여 이전에 처리되지 못하고 연기(pending)된 콜백들을 실행한다. 이러한 콜백들은 &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 에 저장되어 있다.&lt;/p&gt;
&lt;p&gt;이렇게 “연기”된 콜백들이 존재하는 이유는, 이벤트 루프가 각 phase를 실행할 때 해당 phase의 큐에 있는 모든 작업을 처리하는 것이 아니라 (limit 등에 의해) 일정량의 작업만 처리하고 다음으로 넘어가기 때문이다. 만약 모든 작업을 처리하게 된다면 이벤트 루프가 특정 phase에서 block될 수 있을 것이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L806&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/req-inl.h#L141&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// UNIX 버전&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__run_pending&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  QUEUE&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; q&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  QUEUE pq&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;uv__io_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; w&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;QUEUE_EMPTY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;pending_queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token function&quot;&gt;QUEUE_MOVE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;pending_queue&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pq&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;QUEUE_EMPTY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pq&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    q &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;QUEUE_HEAD&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pq&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;QUEUE_REMOVE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token function&quot;&gt;QUEUE_INIT&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    w &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;QUEUE_DATA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;q&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv__io_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; pending_queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    w&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; w&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; POLLOUT&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pending I/O phase의 메소드는 &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 가 비어있으면 0을 리턴하고 종료한다. 만약 &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 에 콜백들이 있으면 해당 콜백들을 실행하고 1을 리턴한다.&lt;/p&gt;
&lt;h3 id=&quot;idle-prepare-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#idle-prepare-phase&quot; aria-label=&quot;idle prepare phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Idle, Prepare phase&lt;/h3&gt;
&lt;p&gt;사실 이름을 잘못 지었다(?). 이름은 &lt;code class=&quot;language-text&quot;&gt;Idle phase&lt;/code&gt;이지만 매 tick마다 실행된다. &lt;code class=&quot;language-text&quot;&gt;Prepare phase&lt;/code&gt; 도 마찬가지로 polling을 시작하기 전마다 실행된다.&lt;/p&gt;
&lt;p&gt;어쨌든 종합해보자면, 이 두 phase는 Node.js의 내부 동작을 위해 존재하는 phase이다. 따라서 이 글에서는 다루지 않겠다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;&gt; 2부에 계속…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 변수 노출 최소화 하기 Part1]]></title><description><![CDATA[2부 보러가기 이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 6: Limiting Scope Exposure…]]></description><link>https://jaehyeon48.github.io/javascript/limiting_scope_exposure_1/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/limiting_scope_exposure_1/</guid><pubDate>Wed, 19 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../limiting_scope_exposure_2&quot;&gt;2부 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;p&gt;이 글은 아래의 원문을 번역/요약한 글입니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch6.md&quot;&gt;You Don’t Know JS Yet/Chapter 6: Limiting Scope Exposure&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;이 글에서는 서로 다른 레벨의 (함수 및 블록) 스코프를 사용하여 프로그램을 구조화 하는 방법을 알아보고, 특히 변수의 과노출(over exposure)를 어떻게, 그리고 왜 해야 하는지에 대해서 살펴볼 것이다.&lt;/p&gt;
&lt;h2 id=&quot;최소한으로-노출하기least-exposure&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EC%86%8C%ED%95%9C%EC%9C%BC%EB%A1%9C-%EB%85%B8%EC%B6%9C%ED%95%98%EA%B8%B0least-exposure&quot; aria-label=&quot;최소한으로 노출하기least exposure permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최소한으로 노출하기(Least Exposure)&lt;/h2&gt;
&lt;p&gt;함수가 자신만의 스코프를 가지는 것은 타당해 보인다. 하지만 왜 블록들도 자기만의 스코프를 가지는 걸까?&lt;/p&gt;
&lt;p&gt;소프트웨어 보안 분야에서 흔히 적용되는 원칙중에 &lt;strong&gt;최소 권한의 원칙(The Principle of Least Privilege, POLP)&lt;/strong&gt; 라는 것이 있다. (&lt;a href=&quot;https://digitalguardian.com/blog/what-principle-least-privilege-polp-best-practice-information-security-and-compliance&quot;&gt;POLP 원칙에 대한 추가 자료&lt;/a&gt;) 그리고 우리가 현재 살펴볼 내용에 적용되는, POLP 원칙의 변형으로 &lt;strong&gt;최소 노출의 원칙(The Principle of Least Exposure, POLE)&lt;/strong&gt;이 있다.&lt;/p&gt;
&lt;p&gt;POLP 원칙은 소프트웨어 아키텍쳐에 대해 방어적인 자세를 취한다. 즉, 시스템의 구성요소들은 최소한의 권한(lease privilege), 최소한의 접근(least access), 그리고 최소한의 노출(least exposure)을 갖도록 설계되어야 한다는 것이다. 이렇게 정말 필요한 최소한의 기능들로 구성된 요소들로 시스템을 설계하게 되면, 어떠한 요소에 해킹이나 에러가 발생했을 때 다른 요소에 미치는 영향이 적어지게 되므로 시스템 전체적으로는 더욱 견고해진다.&lt;/p&gt;
&lt;p&gt;POLP 원칙이 시스템 레벨의 요소 설계에 적용되는 원칙이라면, 이것의 변형인 POLE은 좀 더 낮은 레벨에 적용되는 원칙이다. 우리는 이 POLE원칙을 어떻게 스코프가 서로 상호작용 하는지에 대해 살펴볼 때 적용할 것이다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;그렇다면 POLE 원칙이 “Least Exposure”, 즉 최소한으로 노출한다는 것인데, 도대체 무엇을 최소한으로 노출한다는 걸까? 바로 스코프 내에 존재하는 &lt;strong&gt;변수&lt;/strong&gt;들이다. &lt;/p&gt;
&lt;p&gt;이렇게 생각해보자. 프로그램을 작성할 때 변수들을 그냥 글로벌 스코프에 때려박으면(?) 어떨까? 일단 좋은 생각은 아닌것 같다. 하지만 왜 그런지 이유를 살펴보자. 프로그램의 한 부분(모듈)에서 사용되는 변수가 스코프를 통해 다른 부분(모듈)에 “노출” 되면 일반적으로 다음의 세 가지 위험이 발생한다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;변수 이름 충돌&lt;/strong&gt;: 일반적인, 혹은 흔히 사용되는 변수/함수 이름을 서로 다른 두 모듈에서 사용했다가 두 모듈을 (글로벌 스코프 에서) 합치게 되면 변수 이름이 충돌하게 된다.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;예기치 못한 상황&lt;/strong&gt;: 만약 원래라면 어떤 모듈 내에서만 사용되어야 하는 변수/함수를 노출하게 되면 다른 개발자가 해당 변수/함수를 의도하지 않는 방식으로 사용할 수 있다. 이렇게 되면 버그의 발생 확률이 커지게 된다. &lt;/p&gt;
&lt;p&gt;예를 들어, 어떤 모듈내에서 배열을 사용하는데, 해당 배열에는 오직 숫자만 저장되도록 의도했다고 하자. 이 때 만약 이 배열을 외부로 노출하게 되면 다른 누군가가 해당 배열에 문자열과 같이 숫자가 아닌 값을 저장할 수도 있다. 이렇게 되면 프로그램이 내가 의도한대로 동작하지 않게 될 것이다.&lt;/p&gt;
&lt;p&gt;더 안좋은 점은, 악의를 품은 누군가가 프로그램을 악이용 하게 될 수도 있다는 점이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;의도하지 않은 의존관계&lt;/strong&gt;: 불필요하게 변수/함수를 노출시키면 당장은 프로그램이 돌아가는데 문제가 없을지 몰라도 추후에 리팩토링등을 하는 과정에서 심각한 문제가 발생할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;br/&gt;
&lt;p&gt;스코프에 적용되는 POLE 원칙이 의마하는 바는 &lt;strong&gt;최대한 숨길 수 있으면 숨기고 정말 필요한 부분만 외부로 노출하라&lt;/strong&gt;는 것이다. 여러 개의 중첩 스코프를 사용하는 경우, 최대한 변수들을 내부 스코프로 숨기는 것이 바람직하다 (즉, 가능한 제일 안쪽 스코프에 변수를 선언).&lt;/p&gt;
&lt;p&gt;POLE 원칙에 따라 프로그램을 작성하게 되면 위에서 살펴본 3가지 위험들을 피하거나, 혹은 최소화 할 수 있다. 다음 코드를 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;y&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; tmp &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tmp&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;token comment&quot;&gt;// 4&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;diff&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;token comment&quot;&gt;// 2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;diff()&lt;/code&gt; 함수 내에서 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt; 보다 크면 &lt;code class=&quot;language-text&quot;&gt;x&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;y&lt;/code&gt;를 스왑하여 빼기 결과 &lt;code class=&quot;language-text&quot;&gt;y - x&lt;/code&gt;가 항상 0보다 같거나 크도록 하고 있다. 이 때 스왑하는 과정에서 &lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt;변수가 사용되었는데, 위 예제는 간단한 예시이므로 &lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt;변수가 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문 내에 존재하던, 혹은 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문을 빠져나와 함수 스코프 내에 존재하던 딱히 상관없다 (물론 글로벌 스코프에 존재하는 것은 바람직하지 않다!). 하지만 POLE원칙에 의하면 &lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt;변수를 최대한 안쪽 스코프에 숨기는 것이 좋으므로, &lt;code class=&quot;language-text&quot;&gt;tmp&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문 스코프 내에 존재하는 것이다.&lt;/p&gt;
&lt;h2 id=&quot;함수-스코프를-이용하여-숨기기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%88%A8%EA%B8%B0%EA%B8%B0&quot; aria-label=&quot;함수 스코프를 이용하여 숨기기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;함수 스코프를 이용하여 숨기기&lt;/h2&gt;
&lt;p&gt;앞에서 왜 변수와 함수(선언)를 최대한 숨겨야 하는지 알아보았다. 알아보는건 좋은데, &lt;strong&gt;어떻게 숨겨야할까?&lt;/strong&gt;  일단 블록 스코프 단위인 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;는 나중에 살펴보는 것으로 하고, 일단 &lt;code class=&quot;language-text&quot;&gt;var&lt;/code&gt;와 함수 선언을 어떻게 숨기는지에 대해 알아보자.&lt;/p&gt;
&lt;p&gt;이들을 숨기는 방법은 간단하다. 함수를 선언해서 스코프를 만들어내면 된다. 한번 예제를 통해 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; cache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드는 팩토리얼을 계산하는 재귀함수와 계산 결과를 저장하는 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt; 객체로 구성되어 있다. 이전에 계산한 결과들을 저장하여 추후에 함수를 여러번 호출했을 때 중복되는 연산을 줄이기 위해 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt; 객체를 사용했는데, 잘 생각해보면 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;의 내부적인 요소이므로 함수 외부로 “노출”되면 안될 것 같다 (특히 글로벌 스코프에는 더욱 안될 것 같다!).&lt;/p&gt;
&lt;p&gt;여기서 이러한 과노출(over exposure) 문제를 해결하기 위해 단순히 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;를 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt; 내부에 집어넣으면 될 것 같지만, 사실 그렇게 간단하지는 않다. &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;을 여러번 호출해도 동일한 (하나의) &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;가 계속해서 존재해야 하므로 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt; 함수 외부에 존재해야만 한다. 만약 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt; 내부에 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;를 넣게 되면 함수를 호출하고 종료할 때 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;도 같이 사라지므로 우리가 원하는 대로 동작하지 않을 것이다. 그렇다면 어떻게 해야 할까?&lt;/p&gt;
&lt;p&gt;바로 함수형 프로그래밍에서 사용되는 기법인 “메모이제이션(memoization)“을 사용하는 것이다. 함수형 프로그래밍 패러다임에서는 성능 최적화를 위해 함수가 계산한 결과를 저장(캐싱)하여 동일한 입력으로 여러 번 호출해도 최초 한번만 계산하고 이후에는 캐시에 저장된 값을 이용하는 방법을 메모이제이션 이라고 부른다 (계산 성능은 좋아지지만 그 대신 메모리를 더 사용하게 된다). 일반적으로 메모이제이션 기법을 사용하기 위해 “클로저”라는 것을 이용하게 되는데, 이는 추후에 따로 살펴보자.&lt;/p&gt;
&lt;p&gt;따라서, 메모이제이션을 적용하여 위 코드를 다시 작성하면 다음과 같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 바깥(outer/global) 스코프&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 중간(middle) 스코프&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; cache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; factorial&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ****************&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 안쪽(inner) 스코프&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; factorial &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 720&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 40320&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;hideTheCache()&lt;/code&gt; 함수는 단지 여러 번의 함수 호출에도 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;가 계속해서 유지되도록 스코프를 형성하는 역할만을 수행한다. 또한, &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt; 함수가 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;에 접근할 수 있도록 하기 위해 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;와 동일한 스코프 (&lt;code class=&quot;language-text&quot;&gt;hideTheCache()&lt;/code&gt; 함수 스코프)에 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;을 선언하였고, &lt;code class=&quot;language-text&quot;&gt;hideTheCache()&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;을 반환함으로써 추후 외부 변수가 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;을 가리키게 할 수 있도록 하였다. 이렇게 함으로써 &lt;code class=&quot;language-text&quot;&gt;factorial()&lt;/code&gt;을 여러 번 호출하더라도 바깥으로부터 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;를 감추면서 동시에 계속해서 유지할 수 있다.&lt;/p&gt;
&lt;p&gt;근데 이렇게 하면 변수(여기서는 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;)를 확실히 감출 수 있을 것 같긴 한데… 이런식으로 변수/함수를 감출 때마다 &lt;code class=&quot;language-text&quot;&gt;hideTheCache()&lt;/code&gt;와 같이 바깥 함수를 선언하면 이름 충돌등의 문제가 발생할 것 같다. 더 나은 방법은 없을까?&lt;/p&gt;
&lt;p&gt;물론 있다. 위와 같이 변수/함수를 감춰야 하는 상황마다 굳이 이름을 정해서 함수를 선언하는 방법보다, 다음과 같이 함수 표현식을 사용하는 방법이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; factorial &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hideTheCache&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; cache &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; factorial&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; cache&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 720&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;factorial&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// 40320&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;잠깐… 근데 위 방법도 여전히 함수를 선언해서 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;를 감추는 것 같은데 뭐가 달라진거지?&lt;/p&gt;
&lt;p&gt;확실히 달라진게 맞다. 함수 선언식에 사용된 identifier는 외부 스코프에 속하는 것이 맞다. 반면, 함수 표현식에 사용된 identifier는 해당 함수 내부 스코프에 속한다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;funcDeclaration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token function-variable function&quot;&gt;funcExpression&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [Function: func]&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;funcDeclaration&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [Function: funcDeclaration]&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;funcExpression&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;func&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ReferenceError: func is not defined&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;따라서, 함수 표현식을 사용하게 되면 &lt;code class=&quot;language-text&quot;&gt;hideTheCache&lt;/code&gt; identifier는 &lt;code class=&quot;language-text&quot;&gt;cache&lt;/code&gt;와 동일한 스코프에 존재하므로 외부 스코프에서 함수 이름이 충돌하지 않게 된다. 이렇게 하면  (&lt;code class=&quot;language-text&quot;&gt;hideTheCache&lt;/code&gt;와 같이) 변수를 감추기 위해 스코프를 형성하는 용도로 생성하는 함수의 이름을 충돌 걱정 없이 의미에 맞게(semantically) 자유롭게 쓸 수 있게 된다.&lt;/p&gt;
&lt;p&gt;혹은, 아예 이름을 적지 않을 수도 있다. 즉 익명(anonymous) 함수 표현식을 사용하는 것이다.&lt;/p&gt;
&lt;h3 id=&quot;iife&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#iife&quot; aria-label=&quot;iife permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;IIFE&lt;/h3&gt;
&lt;p&gt;함수 표현식을 사용한 코드의 마지막에 &lt;code class=&quot;language-text&quot;&gt;})();&lt;/code&gt;로 끝나는 부분을 살펴보자. 단순히 함수 표현식을 “사용”만 한 것이 아니라, 함수 표현식 전체를 괄호&lt;code class=&quot;language-text&quot;&gt;(...)&lt;/code&gt;로 감싸고 이 괄호 옆에 괄호&lt;code class=&quot;language-text&quot;&gt;()&lt;/code&gt;를 하나 더 붙였다. 이는 우리가 정의한 함수 표현식을 호출하는 역할을 한다.&lt;/p&gt;
&lt;p&gt;이렇게 함수 표현식을 이용하여 함수를 정의하고, 정의한 함수를 &lt;strong&gt;즉시&lt;/strong&gt; 호출하는 패턴을 &lt;strong&gt;IIFE(Immediately Invoked Function Expression)&lt;/strong&gt;라고 한다 (보통 “이피”라고 발음한다).&lt;/p&gt;
&lt;p&gt;앞서 살펴봤듯이, IIFE는 변수/함수를 숨기기 위해 (함수) 스코프를 생성할 때 매우 유용하다. 일단 기본적으로 표현식(expression) 이므로 자바스크립트 내에서 표현식이 위치할 수 있는 자리 어디서든지 IIFE를 사용할 수 있으며 이름을 붙일수도, 붙이지 않을 수도(익명) 있다. 익명으로 사용하는 것이 좀 더 흔한 방법이다.&lt;/p&gt;
&lt;p&gt;앞에서 사용한 방법과 비교하기 위해, IIFE 패턴 자체만 한번 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// outer scope&lt;/span&gt;

&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// inner scope&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// more outer scope&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;한 가지 흥미로운 사실은, 우리가 앞에서 사용했던 방법에서는 사실 함수를 감싸는 괄호를 제거하여도 정상적으로 동작한다. 하지만 이 코드와 같이 IIFE를 홀로 쓴다면 함수를 무조건 괄호로 감싸야 한다. 그래야 자바스크립트 엔진이 함수를 함수 선언으로 받아들이지 않고 표현식으로 받아들이게 된다. 사실 애초에 IIFE를 따로 쓸때 괄호로 감싸지 않으면 에러가 난다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// SyntaxError&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;블록-스코프를-이용하여-숨기기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9D-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%88%A8%EA%B8%B0%EA%B8%B0&quot; aria-label=&quot;블록 스코프를 이용하여 숨기기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블록 스코프를 이용하여 숨기기&lt;/h2&gt;
&lt;p&gt;앞에서 IIFE를 이용해서 함수 스코프를 생성하여 변수/함수를 숨기는 방법을 알아봤으니, 이제 중괄호쌍 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;를 이용하여 &lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;를 숨기는 방법을 알아보자. 이때 알아두어야할 것이, 중괄호 &lt;code class=&quot;language-text&quot;&gt;{}&lt;/code&gt;는 대부분의 경우 &lt;strong&gt;블록&lt;/strong&gt;을 생성하지만, 해당 블록이 반드시 &lt;strong&gt;스코프&lt;/strong&gt;가 되는 것은 아니다.&lt;/p&gt;
&lt;p&gt;즉 중괄호쌍 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;을 사용하면 블록이 생성되고, 해당 블록 내부에 블록 스코프를 가지는 선언(&lt;code class=&quot;language-text&quot;&gt;let&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;등)이 존재하는 경우에만 스코프가 된다. 다음을 보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// let 변수가 있으므로 중괄호가 블록 스코프의 역할을 한다.&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; thisIsNowScope &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// for 문의 중괄호 또한 블록 스코프이다&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token comment&quot;&gt;// 이 중괄호는 그냥 &quot;블록&quot;이다. 스코프가 아니다.&lt;/span&gt;
            console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;또한, 모든 중괄호쌍 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;이 블록을 생성하는 것은 아니다. 😕&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체 리터럴로 사용되는 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;는 블록도, 스코프도 아니다.&lt;/li&gt;
&lt;li&gt;클래스를 선언할 때 사용되는 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;은 블록도, 스코프도 아니다.&lt;/li&gt;
&lt;li&gt;함수 &lt;code class=&quot;language-text&quot;&gt;function&lt;/code&gt;도 중괄호를 사용하지만 사실 따지고 보면 블록이 아니라 함수 body를 정의하기 위한 하나의 문장이다. 그렇지만 (함수) 스코프의 역할을 한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;switch&lt;/code&gt;문에 사용되는 중괄호는 블록도, 스코프도 아니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;정리해보자면, 중괄호쌍 &lt;code class=&quot;language-text&quot;&gt;{...}&lt;/code&gt;는 블록을 생성할 수도, 생성하지 않을 수도 있으며 스코프가 될 수도, 되지 않을 수도 있다. 이래서 자바스크립트가 어렵다.. 😱&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;이렇게 중괄호쌍이 블록을 생성하지 않는 예외의 경우를 제외하고, 중괄호쌍은 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문 혹은 &lt;code class=&quot;language-text&quot;&gt;for&lt;/code&gt;문과 같이 다른 문장에 “붙어서(attached)” 블록을 정의할 수 있다. 또한 위 코드의 제일 바깥쪽에 사용된 중괄호와 같이 다른 문장에 붙지 않고 혼자서 사용되는 경우에도 블록을 정의할 수 있다.&lt;/p&gt;
&lt;p&gt;자바스크립트와 같이 블록 스코프를 지원하는 대부분의 프로그래밍 언어의 경우 하나 혹은 몇 개의 변수만을 위해 작은 크기의 스코프(a narrow slice of scope)를 명시적으로 생성하는 것은 &lt;strong&gt;매우 매우 흔한 패턴&lt;/strong&gt;이다. 따라서 POLE 원칙을 잘 준수하기 위해선 이러한 패턴을 적절하게 잘 사용하여 identifier의 노출을 최소화 하는것이 바람직하다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;명시적으로 블록 스코프를 생성하는 패턴은 다른 블록의 내부에서도 매우 유용하게 사용될 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;somethingHappened&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// 블록이지만, 스코프는 아님&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token comment&quot;&gt;// 블록이자 스코프&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; msg &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; somethingHappened&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token function&quot;&gt;notifyOthers&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;msg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;

    &lt;span class=&quot;token function&quot;&gt;recoverFromSomething&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;여기선 &lt;code class=&quot;language-text&quot;&gt;msg&lt;/code&gt; 변수를 숨기기 위해 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문 내부에 더 작은 블록 스코프를 명시적으로 생성하였다. 아마 대부분의 개발자들은 위 방법과는 다르게 그냥 &lt;code class=&quot;language-text&quot;&gt;msg&lt;/code&gt; 변수를 &lt;code class=&quot;language-text&quot;&gt;if&lt;/code&gt;문의 스코프 내에 놔둘지도 모르겠다. 사실 위 예시와 같이 몇줄 안되는 코드에서는 명시적으로 추가의 블록 스코프를 생성해도 되고, 안해도 별 상관은 없겠지만 코드의 규모가 커짐에 따라 이러한 과노출 문제가 더욱 불거질 수 있다.&lt;/p&gt;
&lt;p&gt;따라서 나(원문 작성자)는 POLE 원칙을 충실히 이행하기 위해 몇줄 안되는 코드라고 하더라고 위 예시와 같이 명시적으로 스코프를 생성하여 변수의 노출 범위를 최소화 하는 것을 추천한다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;명시적인 블록 스코프를 사용한 또 다른 예시를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getNextMonthStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;dateStr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; nextMonth&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; year&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; curMonth&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; year&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; curMonth&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; dateStr&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token regex&quot;&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;token regex-source language-regex&quot;&gt;(\d{4})-(\d{2})-\d{2}&lt;/span&gt;&lt;span class=&quot;token regex-delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;??&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        nextMonth &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Number&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;curMonth&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextMonth &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        year&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token template-string&quot;&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;year&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;nextMonth&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;padStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&apos;0&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token interpolation-punctuation punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;-01&lt;/span&gt;&lt;span class=&quot;token template-punctuation string&quot;&gt;`&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;getNextMonthStart&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;2019-12-25&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;token comment&quot;&gt;// 2020-01-01&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에 있는 스코프와 스코프 내부의 identifier들을 정리하면 다음과 같다:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;글로벌 스코프에는 함수 &lt;code class=&quot;language-text&quot;&gt;getNextMonthStart()&lt;/code&gt; 가 존재한다.&lt;/li&gt;
&lt;li&gt;함수 &lt;code class=&quot;language-text&quot;&gt;getNextMonthStart()&lt;/code&gt; 스코프 내부에는 &lt;code class=&quot;language-text&quot;&gt;dateStr&lt;/code&gt;(매개변수), &lt;code class=&quot;language-text&quot;&gt;nextMonth&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;year&lt;/code&gt; 세 개의 identifier가 존재한다.&lt;/li&gt;
&lt;li&gt;함수 안의 블록 스코프 내부에는 &lt;code class=&quot;language-text&quot;&gt;curMonth&lt;/code&gt; identifier가 존재한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이 때 &lt;code class=&quot;language-text&quot;&gt;curMonth&lt;/code&gt;를 함수 스코프 내부에 두지 않고 굳이 명시적으로 블록 스코프를 생성한 이유는, &lt;code class=&quot;language-text&quot;&gt;curMonth&lt;/code&gt;를 사용하는 문장이 &lt;code class=&quot;language-text&quot;&gt;curMoth&lt;/code&gt; 변수 선언 밑의 두 문장 밖에 없기 때문이다. 따라서 &lt;code class=&quot;language-text&quot;&gt;curMonth&lt;/code&gt;의 과노출을 방지하기 위해 블록 스코프를 명시적으로 생성하였다.&lt;/p&gt;
&lt;p&gt;이 예시는 매우 간단한 예시이므로 과노출로 인한 위험이 적다. 하지만 이와 같이 &lt;strong&gt;습관적으로&lt;/strong&gt; 과노출을 방지하는 마음가짐(mindset)을 가져야 POLE 원칙을 따름으로써 얻을 수 있는 이점을 누릴 수 있다. 따라서 작고 사소한 부분이더라도 이런식으로 일관되게 POLE 원칙을 준수하는 것이 바람직하다.&lt;/p&gt;
&lt;p&gt;마지막으로 좀 더 복잡한 예시를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;sortNamesByLength&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;names&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; buckets &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; firstName &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; names&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;buckets&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;firstName&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            buckets&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;firstName&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        buckets&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;firstName&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;length&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;firstName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; sortedNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; bucket &lt;span class=&quot;token keyword&quot;&gt;of&lt;/span&gt; buckets&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bucket&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
                bucket&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;token comment&quot;&gt;// 리스트에 정렬된 bucket을 append&lt;/span&gt;
                sortedNames &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;sortedNames&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;bucket&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; sortedNames&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;sortNamesByLength&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Sally&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Suzy&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Frank&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;John&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Jennifer&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;token string&quot;&gt;&apos;Scott&apos;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// [ &apos;John&apos;, &apos;Suzy&apos;, &apos;Frank&apos;, &apos;Sally&apos;, &apos;Scott&apos;, &apos;Jennifer&apos; ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에는 5개의 스코프에 걸쳐 총 6개의 identifier가 존재한다. 각 identifier들은 서로 이름이 충돌하지 않기 때문에 모든 identifier들을 글로벌 스코프에 몰아 넣을수도 있지만, POLE 원칙에 위배되기 때문에 그렇게 하지 않았다.&lt;/p&gt;
&lt;p&gt;&gt; 2부에 계속…&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Node.js의 이벤트 루프 Part2]]></title><description><![CDATA[1부 보러가기 Poll phase Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase…]]></description><link>https://jaehyeon48.github.io/javascript/nodejs_event_loop_2/</link><guid isPermaLink="false">https://jaehyeon48.github.io/javascript/nodejs_event_loop_2/</guid><pubDate>Wed, 19 Aug 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;../nodejs_event_loop_1/&quot;&gt;1부 보러가기&lt;/a&gt;&lt;/p&gt;
&lt;hr class=&quot;custom-hr&quot;&gt;
&lt;h3 id=&quot;poll-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#poll-phase&quot; aria-label=&quot;poll phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Poll phase&lt;/h3&gt;
&lt;p&gt;Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase에 진입하면 우선 &lt;code class=&quot;language-text&quot;&gt;watcher_queue&lt;/code&gt; 를 살펴보고, 해당 큐에 파일 읽기 콜백, TCP 통신 콜백등과 같은 작업들이 존재한다면 해당 작업들을 수행한다.&lt;/p&gt;
&lt;p&gt;이 때 더이상 실행할 콜백이 없는 상태에 이르게 되면 &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;check_queue&lt;/code&gt; (&lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 의 콜백들이 저장됨), &lt;code class=&quot;language-text&quot;&gt;closing_callbacks_queue&lt;/code&gt; (&lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt; 이벤트 콜백들이 저장됨)에 저장된 작업들이 있는지 살펴본다. 만약 해야 할 작업이 있다면 즉시 Poll phase를 종료하고 다음 phase로 넘어간다. 만약 해야 할 작업이 없다면 Poll phase에서 일정 시간동안 대기한다.&lt;/p&gt;
&lt;p&gt;그럼 과연 얼마나 대기하는지를 코드를 통해 살펴보자. 우선 Poll phase의 메소드인 &lt;code class=&quot;language-text&quot;&gt;uv__poll&lt;/code&gt; (UNIX는 &lt;code class=&quot;language-text&quot;&gt;uv__io_poll&lt;/code&gt;) 의 인자 목록을 살펴보면 다음과 같다 (메소드 전체는 너무 길기때문에 생략한다).&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__io_poll&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; timeout&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 번째 인자로 이벤트 루프를, 두 번째 인자로 “대기 시간”을 받는 것을 알 수 있다. 이렇게 Poll phase는 인자로 얼마만큼의 시간동안 대기할 것인가를 받아서 해당 시간만큼 대기한다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 값이 0이면 polling을 건너뛰고 바로 다음 phase인 Check phase로 넘어간다. &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 값은 다음 과정을 통해 계산된다:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;만약 이벤트 루프가 현재 &lt;code class=&quot;language-text&quot;&gt;UV_RUN_DEFAULT&lt;/code&gt; 모드로 동작한다면 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;uv_backend_timeout&lt;/code&gt; 메소드를 통해 계산된다.&lt;/li&gt;
&lt;li&gt;만약 이벤트 루프가 현재 &lt;code class=&quot;language-text&quot;&gt;UV_RUN_ONCE&lt;/code&gt; 모드로 동작하고 &lt;code class=&quot;language-text&quot;&gt;uv_run_pending&lt;/code&gt; 의 리턴값이 0 (즉, &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 가 비어있는 경우) 이면 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;uv_backend_timeout&lt;/code&gt; 메소드를 통해 계산된다.&lt;/li&gt;
&lt;li&gt;이외의 경우, &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 은 0이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;이벤트 루프의 모드에 관한 자세한 내용은 &lt;a href=&quot;http://docs.libuv.org/en/v1.x/loop.html#c.uv_run&quot;&gt;http://docs.libuv.org/en/v1.x/loop.html#c.uv_run&lt;/a&gt; 를 참고하길 바란다.&lt;/p&gt;
&lt;br/&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;uv_backend_timeout&lt;/code&gt; 메소드의 코드를 살펴보면 다음과 같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L337&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/core.c#L398&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// UNIX 버전&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv_backend_timeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;stop_flag &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;uv__has_active_handles&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;uv__has_active_reqs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;QUEUE_EMPTY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;idle_handles&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;QUEUE_EMPTY&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;pending_queue&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;closing_handles&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__next_timeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서 볼 수 있듯, 다음 중 하나에 해당되는 경우 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 은 0이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;루프의 &lt;code class=&quot;language-text&quot;&gt;stop_flag&lt;/code&gt; 가 0이 아닌경우 (즉, 루프를 종료해야 하는 경우).&lt;/li&gt;
&lt;li&gt;현재 active한 핸들러(콜백)가 없고, 현재 active한 요청(operation)이 없는 경우.&lt;/li&gt;
&lt;li&gt;실행되기를 기다리는 idle한 핸들러가 있는 경우.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 에서 대기 중인(pending) I/O 콜백이 있는 경우 (즉, 이미 대기 중인 I/O 동작이 있으므로 새로운 I/O 동작을 기다릴 필요가 없음).&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;close&lt;/code&gt; 이벤트 핸들러가 있는 경우.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;위 다섯개의 상황을 제외한 나머지 경우, &lt;code class=&quot;language-text&quot;&gt;uv__next_timeout&lt;/code&gt; 을 호출하여 &lt;code class=&quot;language-text&quot;&gt;timeout&lt;/code&gt; 을 계산한다. 코드는 다음과 같다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;c&quot;&gt;&lt;pre class=&quot;language-c&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/timer.c#L142&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;uv__next_timeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_loop_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;heap_node&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; heap_node&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_timer_t&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; handle&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token class-name&quot;&gt;uint64_t&lt;/span&gt; diff&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  heap_node &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;heap_min&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;timer_heap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;loop&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;heap_node &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;/* block indefinitely */&lt;/span&gt;

  handle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;container_of&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;heap_node&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;uv_timer_t&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; heap_node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;handle&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;timeout &lt;span class=&quot;token operator&quot;&gt;&amp;lt;=&lt;/span&gt; loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;time&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  diff &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; handle&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;timeout &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; loop&lt;span class=&quot;token operator&quot;&gt;-&gt;&lt;/span&gt;time&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;diff &lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; INT_MAX&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    diff &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; INT_MAX&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; diff&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;uv__next_timeout&lt;/code&gt; 은 현재 시간(iteration을 시작할 때 계산한 시간)을 기준으로 가장 가까운 타이머와의 차이를 반환한다. 즉, 이 경우 이벤트 루프가 Poll phase에서 가장 빨리 만료되는 타이머를 실행할 수 있는 시간이 될때까지만 기다리다가 다음 phase로 넘어간다.&lt;/p&gt;
&lt;p&gt;이 때 만약 타이머가 없다면 &lt;code class=&quot;language-text&quot;&gt;-1&lt;/code&gt; 을 리턴하는데, 이로인해 이벤트 루프가 Poll phase에서 무한히 기다리게 된다.&lt;/p&gt;
&lt;br/&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;종합해보자면, 이벤트 루프는 Poll phase에서&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Check phase 혹은 Close phase에 실행할 콜백이 있으면 Poll phase에서 기다리지 않는다.&lt;/li&gt;
&lt;li&gt;만약 Check phase 와 Close phase에 실행할 콜백이 없으면 타이머를 살펴보고, 타이머가 있으면 해당 타이머를 실행할 수 있을 때까지 Poll phase에서 기다렸다가 다음 phase로 넘어간다.&lt;/li&gt;
&lt;li&gt;만약 타이머도 없으면 일이 생길때 까지 Poll phase에서 대기한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I/O 폴링이 수행되는 방식은 OS별로 차이가 있다. Windows의 경우, IOCP(Input Output Completion Port)의 &lt;code class=&quot;language-text&quot;&gt;GetQueuedCompletionStatus&lt;/code&gt; 를 이용하고, Linux의 경우 &lt;code class=&quot;language-text&quot;&gt;epoll_wait&lt;/code&gt; 을, macOS의 경우 &lt;code class=&quot;language-text&quot;&gt;kqueue&lt;/code&gt; 를 이용한다.&lt;/p&gt;
&lt;h3 id=&quot;check-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#check-phase&quot; aria-label=&quot;check phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Check phase&lt;/h3&gt;
&lt;p&gt;Check phase의 동작 방식은 Timer phase와 비슷하다고 할 수 있다. 하지만 타이머 콜백(&lt;code class=&quot;language-text&quot;&gt;setTimeout()&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;setInterval()&lt;/code&gt;) 들이 언제 실행되는지 보장되지 않는 반면, &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 의 콜백들은 I/O phase 바로 다음에 처리되는 것이 보장된다.&lt;/p&gt;
&lt;br/&gt;
&lt;blockquote&gt;
&lt;p&gt;setTimeout vs. setImmediate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이 글의 첫 부분에서 봤던 이벤트 루프의 흐름에서 볼 수 있듯이, 루프의 iteration이 시작되고 우선 Timer phase에 진입하여 타이머 관련 콜백들을 처리하고, 그 다음에 I/O phase 를 거쳐 Check phase에 진입하므로 다음 코드의 결과를 쉽게 예측할 수 있을 것이다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setTimeout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setImmediate&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;언뜻 보기엔 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 이 먼저 실행되고 그 다음 &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 가 실행되는 것처럼 보인다. 하지만 위 코드의 결과는 &lt;strong&gt;예측할 수 없다!&lt;/strong&gt; 😱 위 코드를 여러번 실행해보면 서로 다른 결과가 나오는것을 확인할 수 있다.&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_1.png&quot; alt=&quot;setTimeout vs. setImmediate&quot;&gt;
    &lt;figcaption&gt;setTimeout vs. setImmediate&lt;/figcaption&gt;
&lt;/figure&gt;
&lt;p&gt;이러한 결과가 나오는 이유는, Timer phase에서 살펴본 것과 같이 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 의 default 딜레이 값은 0이 아니라 1이기 때문이다. 즉, 만약 0보다 작은 값을 딜레이로 주게 되면 Node.js가 자동적으로 딜레이를 1로 변경해버린다.&lt;/p&gt;
&lt;p&gt;따라서, 이벤트 루프가 현재 시간을 계산할 때, CPU가 얼마나 바쁜지에 따라 시간을 계산하는데 걸리는 시간이 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 를 초과할 수도, 그렇지 않을 수도 있다. 만약 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 보다 빠르게 시간을 계산했다면 &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 가 먼저 실행될 것이고, 시간을 계산하는데 &lt;code class=&quot;language-text&quot;&gt;1ms&lt;/code&gt; 보다 더 걸렸다면 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 이 실행될 것이다.&lt;/p&gt;
&lt;p&gt;하지만 다음과 같은 상황에서는 &lt;strong&gt;무조건&lt;/strong&gt; &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 의 콜백이 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 콜백보다 먼저 실행된다고 할 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;fs&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

fs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;readFile&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;__dirname&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setTimeout&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;setImmediate&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;그 이유는 우선, 프로그램이 시작되면 &lt;code class=&quot;language-text&quot;&gt;fs.readFile()&lt;/code&gt; 을 이용하여 파일을 비동기적으로 읽는다. 파일 읽기가 완료되면 &lt;code class=&quot;language-text&quot;&gt;pending_queue&lt;/code&gt; 에 콜백이 저장되어 추후에 실행되는데, 이 때 &lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 이 순차적으로 실행되고, 각각의 콜백이 Timer phase의 큐와 Check phase의 큐에 저장된다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O phase 를 지나 Poll phase에 진입했을 때, immediate 콜백과 타이머 콜백이 있으므로 곧장 Check phase로 가서 &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 의 콜백을 실행한다. → “setImmediate” 출력.&lt;/li&gt;
&lt;li&gt;그 다음 루프 iteration에서 Timer phase에 진입하여 만료된 타이머의 콜백을 실행한다 → “setTimeout” 출력.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;close-phase&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#close-phase&quot; aria-label=&quot;close phase permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Close phase&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&apos;close&apos;&lt;/code&gt; 이벤트, 혹은 &lt;code class=&quot;language-text&quot;&gt;socket.destroy()&lt;/code&gt; 와 같은 &lt;code class=&quot;language-text&quot;&gt;destroy&lt;/code&gt; 타입에 대한 콜백들을 실행한다. 이벤트 루프가 Close phase를 마치고 나면 &lt;code class=&quot;language-text&quot;&gt;uv__loop_alive&lt;/code&gt; 를 이용하여 iteration을 더 돌아야 하는지 판단한다.&lt;/p&gt;
&lt;h2 id=&quot;nexttickqueue--microtaskqueue&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#nexttickqueue--microtaskqueue&quot; aria-label=&quot;nexttickqueue  microtaskqueue permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;nextTickQueue &amp;#x26; microTaskQueue&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;process.nextTick()&lt;/code&gt; 의 콜백들이 저장되는 &lt;code class=&quot;language-text&quot;&gt;nextTickQueue&lt;/code&gt; 와, &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 등의 콜백이 저장되는 &lt;code class=&quot;language-text&quot;&gt;microTaskQueue&lt;/code&gt; 는 사실 이벤트 루프의 일부가 아니다.&lt;/p&gt;
&lt;p&gt;Node.js v11.0.0 이전에는 각 tick마다, 즉 어떤 phase에서 다음 phase로 넘어갈 때 (→ “C++/JavaScript 경계를 넘을 때” 라고 하기도 한다) 해당 큐에 저장된 모든 콜백들을 처리하는 방식으로 동작했다. 이 때 &lt;code class=&quot;language-text&quot;&gt;nextTickQueue&lt;/code&gt; 가 &lt;code class=&quot;language-text&quot;&gt;microTaskQueue&lt;/code&gt; 보다 높은 우선순위를 갖는다.&lt;/p&gt;
&lt;p&gt;하지만 Node.js v11.0.0 부터는 동작 방식이 약간 바뀌었는데, 기존 방식처럼 각 tick마다 두 개의 큐를 실행하는 것을 바탕으로 각 타이머 콜백(&lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; &amp;#x26; &lt;code class=&quot;language-text&quot;&gt;setInterval&lt;/code&gt;) 과 immediate 콜백 사이에 &lt;code class=&quot;language-text&quot;&gt;nextTick&lt;/code&gt; 콜백와 &lt;code class=&quot;language-text&quot;&gt;microTask&lt;/code&gt; 콜백이 실행된다. 다음 코드를 살펴보자:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;timeout1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;timeout2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;promise resolve&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;timeout3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;timeout4&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;Node.js v11.0.0 이후 버전에서 실행한 결과는 다음과 같다:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nextTickQueue_1.png&quot; alt=&quot;code result after v11.0.0&quot;&gt;
&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Node.js v11.0.0 이전 버전에서 실행한 결과는 다음과 같다:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nextTickQueue_2.png&quot; alt=&quot;code result before v11.0.0 &quot;&gt;
&lt;/figure&gt;
&lt;p&gt;위 결과에서 볼 수 있듯, v11.0.0 이전에는 매 tick마다 &lt;code class=&quot;language-text&quot;&gt;nextTick&lt;/code&gt; 콜백과 &lt;code class=&quot;language-text&quot;&gt;microTask&lt;/code&gt; 콜백들이 실행됐으나, v11.0.0 이후에는 타이머 콜백, (위 코드에는 없지만) immediate 콜백 마다 &lt;code class=&quot;language-text&quot;&gt;nextTick&lt;/code&gt; 콜백과 &lt;code class=&quot;language-text&quot;&gt;microTask&lt;/code&gt; 콜백을 실행함을 알 수 있다.&lt;/p&gt;
&lt;p&gt;이렇게 동작이 변경된 이유는, 크롬 브라우저와의 호환성 때문인데, 브라우저에서는 v11.0.0 이후 버전에서와 같이 동작하기 때문이다.&lt;/p&gt;
&lt;p&gt;물론 &lt;code class=&quot;language-text&quot;&gt;setImmediate&lt;/code&gt; 에 대해 실험해 봐도 위와 동일한 로직으로 동작함을 알 수 있다:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;immediate1&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;immediate2&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  Promise&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;resolve&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;promise resolve&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;immediate3&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;setImmediate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; console&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&apos;immediate4&apos;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node.js v11.0.0 이후 버전:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_2.png&quot; alt=&quot;code result after v11.0.0&quot;&gt;
&lt;/figure&gt;
&lt;p&gt;Node.js v11.0.0 이전 버전:&lt;/p&gt;
&lt;figure&gt;
    &lt;img src=&quot;https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_3.png&quot; alt=&quot;code result before v11.0.0 &quot;&gt;
&lt;/figure&gt;
&lt;h2 id=&quot;references&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#references&quot; aria-label=&quot;references permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;REFERENCES&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.libuv.org/en/v1.x/guide/basics.html#event-loops&quot;&gt;Basics of libuv - libuv documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop&quot;&gt;Design overview - libuv documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/&quot;&gt;The Node.js Event Loop, Timers, and process.nextTick()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810&quot;&gt;Event Loop and the Big Picture Series&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.voidcanvas.com/nodejs-event-loop/&quot;&gt;Node.js event loop workflow &amp;#x26; lifecycle in low level&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[Your name Thank you for reading my resume. If you want to contact me, Please send me an email.]]></description><link>https://jaehyeon48.github.io/resume-en/</link><guid isPermaLink="false">https://jaehyeon48.github.io/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;your-name&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#your-name&quot; aria-label=&quot;your name permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Your name&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;p&gt;&lt;em&gt;Thank you for reading my resume. If you want to contact me, Please send me an email.&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>