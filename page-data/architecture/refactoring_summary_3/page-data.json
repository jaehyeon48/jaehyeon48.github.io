{"componentChunkName":"component---src-templates-blog-post-js","path":"/architecture/refactoring_summary_3/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"345b74f6-142a-5697-8740-a33893502c29","excerpt":"리팩토링…","html":"<p><a href=\"https://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Signature/dp/0134757599\">리팩토링 2판</a>을 번역/요약한 글입니다.</p>\n<hr class=\"custom-hr\">\n<h1 id=\"코드에서-나는-악취\" style=\"position:relative;\"><a href=\"#%EC%BD%94%EB%93%9C%EC%97%90%EC%84%9C-%EB%82%98%EB%8A%94-%EC%95%85%EC%B7%A8\" aria-label=\"코드에서 나는 악취 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>코드에서 나는 악취</h1>\n<ul>\n<li>언제 리팩토링을 시작할 것인지(그리고 언제 멈출 것인지)를 아는 것은 리팩토링의 작동 원리를 아는 것 못지 않게 중요하다.</li>\n<li>인스턴스 변수를 제거하는 법이나 계층을 만드는 법을 설명하는 것은 쉽다. 하지만 이것들을 <em>언제</em> 해야 하는지를 설명하는 것은 쉽지 않다.</li>\n<li>우리의 경험에 따르면, 어떠한 (정량적) 지표도 숙련된 사람의 직관보다 못했다. 이제 우리는 리팩토링으로 개선할 수 있는 문제들에 대한 암시를 주려고 한다.</li>\n<li>이제부터 당신은 인스턴스 변수가 몇 개 정도 되면 많은 것인지, 혹은 메서드의 코드가 몇 줄 이상이면 많은 것인지 판단할 수 있는 감각을 기르려고 노력 해야 한다.</li>\n</ul>\n<h2 id=\"미스테리한-이름\" style=\"position:relative;\"><a href=\"#%EB%AF%B8%EC%8A%A4%ED%85%8C%EB%A6%AC%ED%95%9C-%EC%9D%B4%EB%A6%84\" aria-label=\"미스테리한 이름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>미스테리한 이름</h2>\n<blockquote>\n<p>컴퓨터 과학에서 어려운 점은 두 가지다: 캐시 무효화(invalidation)와 이름 짓기. - 필 칼튼</p>\n</blockquote>\n<ul>\n<li>코드는 추리 소설이 아니다. 국제적으로 미스테리한 인물이 되는 것에 대한 환상을 가질 수 있겠으나, 우리의 코드는 평범하고 깔끔해야 한다.</li>\n<li>깔끔한 코드의 가장 중요한 부분 중 하나는 좋은 이름이다. 따라서 함수, 모듈, 변수, 클래스 등이 무엇을 하는지, 그리고 어떻게 쓰는지를 잘 나타내는 이름을 (많은 생각을 통해) 지어야 한다.</li>\n<li>아마 우리가 하는 리팩토링의 거의 대부분은 이름을 바꾸기가 될 것이다.</li>\n<li>흔히 사람들은 이름을 바꾸는 리팩토링을 할 필요 없다고 생각하는데, 좋은 이름은 추후에 코드를 이해하는 데 소요되는 시간을 아껴줄 것이다.</li>\n<li>좋은 이름이 떠오르지 않는다면, 무언가 설계에 문제가 있지는 않은지 검토해 볼 필요가 있다. 좋은 이름을 골똘히 생각하다 보면 (설계에 대해 생각해 봄으로써) 코드가 상당히 간결해지는 경우도 있다.</li>\n</ul>\n<h2 id=\"중복된-코드\" style=\"position:relative;\"><a href=\"#%EC%A4%91%EB%B3%B5%EB%90%9C-%EC%BD%94%EB%93%9C\" aria-label=\"중복된 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>중복된 코드</h2>\n<ul>\n<li>코드 구조가 두 번 이상 반복된다면 하나로 합치는 것을 권장한다. 중복된 코드가 있다면 코드를 읽을 때도 무언가 차이가 있는지 면밀히 살펴봐야 하고, 중복된 코드를 수정하려고 하면 중복된 코드들 모두를 같이 바꿔주어야 한다.</li>\n<li>중복된 코드의 가장 단순한 예로는, 한 클래스에 존재하는 두 메소드가 같은 문장을 사용하는 경우이다. 이 경우 <a href=\"\">Extract Function</a>를 써서 추출된 함수를 두 곳에서 호출하는 형태로 바꾸는 것이 좋다.</li>\n<li>만약 코드가 똑같진 않고 비슷하다면 <a href=\"\">Slice Statements</a>를 이용하여 비슷한 부분을 하나로 묶을 수 있는지 살펴보는 것을 권장한다.</li>\n<li>공통 부모 클래스의 자식 클래스 내부에 중복되는 부분이 존재하는 경우엔 <a href=\"\">Pull Up Method</a>를 적용할 수 있다.</li>\n</ul>\n<h2 id=\"긴-함수\" style=\"position:relative;\"><a href=\"#%EA%B8%B4-%ED%95%A8%EC%88%98\" aria-label=\"긴 함수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>긴 함수</h2>\n<ul>\n<li>우리의 경험상, 함수들이 작을 때 (함수 코드가 짧을 때) 프로그램이 오랫동안 잘 동작했었다. 이러한 프로그램을 처음 맞닥뜨리는 개발자는 (함수들이) 끊임없이 서로에게 위임을 하는 모습을 보고 실질적으로 어떠한 계산도 일어나지 않는 것처럼 보일 수도 있다.</li>\n<li>하지만 몇 년 동안 이러한 코드를 다뤄봤다면 함수들이 작은 것이 얼마나 중요한지 깨달았을 것이다.</li>\n<li>작은 함수를 사용해야 <a href=\"https://en.wikipedia.org/wiki/Indirection\">indirection</a>의 이점을 누릴 수 있다.</li>\n<li>초창기 프로그래밍 언어에선 서브루틴을 호출할 때의 오버헤드로 인해 사람들이 짧은 함수를 사용하는 것을 꺼려 했다. 그러나 현대의 언어들은 이러한 오버헤드를 대부분 제거했다. 하지만 함수가 무슨 일을 하는지 살펴보려면 코드 이리저리 왔다 갔다 해야 하기 때문에 코드를 읽는 사람에겐 여전히 오버헤드가 존재하긴 한다.</li>\n<li>개발 환경을 통해 이러한 오버헤드를 줄일 수 있긴 하지만(vscode에서처럼 동시에 두 코드를 읽는다든지..), 작은 함수를 이해하는 핵심은 결국 좋은 이름이다. 함수의 이름이 잘 지어져있다면 함수의 body를 보지 않고서도 그 함수가 무엇을 하는지 알아낼 수 있다.</li>\n<li>좋은 이름의 이러한 이점을 최대한 활용해서, 함수를 공격적으로 쪼개야 한다. 우리는 주석을 달고 싶을 때 주석 대신 함수를 작성하는데, 이렇게 하면 우리가 주석으로 달려고 했던 내용을 이름과 함께 실제 코드로 작성함으로써 우리의 의도를 더욱 명확히 드러낼 수 있게 된다.</li>\n<li>함수 호출부가 원래의 코드보다 길어진다고 하더라도 함수로 분리한다. 단, 반드시 함수의 동작을 잘 설명하는 이름을 지어야 한다.</li>\n<li>여기서 핵심은 함수의 길이가 아니라 함수가 하는 동작과 그것을 구현한 코드 간의 괴리이다. 즉, 어떤 코드가 자신이 무엇을 하는지 잘 설명하지 못할 수록 함수로 분리하는 것이 좋다.</li>\n<li>큰 함수를 작은 함수로 분리할 땐 십중팔구 <a href=\"\">Extract Function</a> 방법을 쓰면 된다. 함수 내에서 서로 연관된 부분들을 묶어 새로운 함수로 분리하라.</li>\n<li>매개 변수와 임시 변수가 많은 함수의 경우, 코드를 추출해서 새로운 함수로 만드는 것이 힘들 수 있다. <a href=\"\">Extract Function</a> 방법을 쓰게 되면 분리된 함수에 너무 많은 인자를 넘겨야 해서 결국 분리한 효과를 누릴 수 없게 될 수 있다.</li>\n<li><a href=\"\">Replace Temp with Query</a>를 사용해서 임시 변수를 줄일 수 있고, <a href=\"\">Introduce Parameter Object</a>와 <a href=\"\">Preserve Whole Object</a>기법을 사용해서 함수로 전달되는 매개 변수의 개수를 줄일 수 있다.</li>\n<li>만약 위 기법들을 사용했음에도 불구하고 여전히 매개 변수와 임시 변수가 많이 남아있는 경우, 최후의 수단으로 <a href=\"\">Replace Function with Command</a>를 적용해볼 수 있다.</li>\n<li>추출할 코드를 판단하는 좋은 기준 중 하나는 바로 주석이다. 주석이 달려있는 코드를 함수로 분리한 후, 주석을 기반으로 이름을 지으면 된다. 코드가 더 명확해질 수만 있다면 비록 한 줄짜리 함수가 되더라도 분리하는 것을 추천한다.</li>\n<li>조건문과 반복문 또한 좋은 기준이 될 수 있는데, <a href=\"\">Decompose Conditional</a>을 사용해서 조건문을 분리할 수 있다. 거대한 <code class=\"language-text\">switch</code> 구문도 <a href=\"\">Extract Function</a>을 통해 한 줄짜리 함수 호출문으로 바꿀 수 있다. 만약 똑같은 조건에 의해 분기하는 <code class=\"language-text\">switch</code> 구문이 여러 개 있다면 <a href=\"\">Replace Conditional with Polymorphism</a>을 적용할 수 있다.</li>\n<li>반복문의 경우 반복문 자체와 반복문 내부의 로직을 분리하여 함수로 만드는 것을 추천한다. 만약 이렇게 추출된 함수의 이름 짓는 것이 어렵다면 반복문이 너무 많은 일을 하고 있진 않은지 살펴보라. 만약 두 가지 이상의 일을 한다면 <a href=\"\">Split Loop</a>을 적용해 볼 수 있다.</li>\n</ul>\n<h2 id=\"너무-많은-매개-변수\" style=\"position:relative;\"><a href=\"#%EB%84%88%EB%AC%B4-%EB%A7%8E%EC%9D%80-%EB%A7%A4%EA%B0%9C-%EB%B3%80%EC%88%98\" aria-label=\"너무 많은 매개 변수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>너무 많은 매개 변수</h2>\n<ul>\n<li>프로그래밍을 처음에 배울 때, 우리는 함수가 필요로 하는 모든 것을 매개 변수로 넘기라고 배운다. 만약 이렇게 안 하면 글로벌 변수를 사용해야 하기 때문에 이는 꽤 합리적인 가르침이다. 하지만 매개 변수가 너무 많은 경우 그 자체로 혼란스러울 수 있다.</li>\n<li>만약 다른 매개 변수를 통해 값을 구할 수 있는 매개 변수가 있다면 <a href=\"\">Replace Parameter with Query</a>를 사용하여 해당 매개 변수를 제거할 수 있다. 또한, <a href=\"\">Preserve Whole Object</a>를 사용하여 기존에 존재하는 자료 구조에서 데이터를 추출하여 매개 변수로 넘기는 대신 원본 자료 구조 그 자체를 넘기도록 할 수 있다.</li>\n<li>여러 개의 매개 변수들이 항상 세트로 묶여 사용된다면 <a href=\"\">Introduce Parameter Object</a>를 적용하여 하나의 객체로 묶을 수 있다.</li>\n<li>일종의 “flag”로 사용되는 매개 변수의 경우, <a href=\"\">Remove Flag Argument</a>기법을 적용해 볼 수 있다.</li>\n<li>클래스를 사용하여 매개 변수의 개수를 줄일 수도 있다. 특히, 여러 함수들이 동일한 매개 변숫값을 공유하는 경우 더욱 도움이 된다. 이 경우 <a href=\"\">Combine Functions into Class</a>를 사용하여 공유되어 사용되는 변수를 클래스 필드 변수로 바꿀 수 있다. 함수형 프로그래밍 관점에서 보자면 이는 부분 적용 함수들을 만드는 것과 흡사하다.</li>\n</ul>\n<h2 id=\"전역-변수\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%97%AD-%EB%B3%80%EC%88%98\" aria-label=\"전역 변수 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전역 변수</h2>\n<ul>\n<li>프로그래밍을 처음 배울 때부터, 우리는 전역 변수의 위험성에 대해 교육을 받는다. 전역 변수는 어디서나 접근이 가능하기 때문에 어디서든 그 값을 변경할 수 있다. 하지만 전역 변수를 수정하고 있는 부분을 찾는 것은 쉽지 않다. 이로 인해 전역 변수와 관련된 버그가 발생해도 어디서 잘못되었는지를 찾기 쉽지 않다.</li>\n<li>가장 흔한 예로 “전역 변수”를 들었지만, 이러한 문제는 클래스 변수와 싱글톤에서도 나타나는 문제이다.</li>\n<li>이러한 문제를 방지할 수 있는 핵심적인 방법은 바로 <a href=\"\">Encapsulate Variable</a>이다. 일단 전역 변수를 함수로 감싸게 되면 적어도 어디서 해당 변수를 참조하고 있는지를 비교적 쉽게 파악할 수 있다. 그런 다음 변수의 스코프 범위를 최대한 축소하는 것이 바람직하다.</li>\n<li>전역 변수가 가변(mutable)인 경우 상황은 더욱 끔찍하다. 일단 프로그램이 시작되면 값이 바뀌지 않는다는 보장이 있는 경우엔 그나마 안전하다고 할 수 있다.</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Paracelsus\">파라켈수스</a>가 “약과 독의 차이는 사용량이다”라고 한 것처럼, 전역 데이터가 적은 경우 어떻게든 잘 관리할 수 있지만, 전역 데이터가 많아지면 이를 관리하는 게 기하급수적으로 어려워진다.</li>\n<li>하지만 전역 데이터가 몇 개 없다고 해도, 추후 있을지도 모르는 변화에 대응하기 위해 이들을 캡슐화하는 것을 권장한다.</li>\n</ul>\n<h2 id=\"가변mutable-데이터\" style=\"position:relative;\"><a href=\"#%EA%B0%80%EB%B3%80mutable-%EB%8D%B0%EC%9D%B4%ED%84%B0\" aria-label=\"가변mutable 데이터 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가변(mutable) 데이터</h2>\n<ul>\n<li>데이터를 변경하는 경우, 예기치 못한 버그가 발생할 수 있다. 어떤 데이터에 대해, 그 데이터를 사용하는 곳에서 예상하는 것과는 다르게 변경을 해버리면 버그가 발생할 수 있고, 특히 이러한 일이 특별한 조건에서만 일어나는 일이라면 디버깅하기 매우 어렵다.</li>\n<li>이러한 이유로 함수형 프로그래밍에선 아예 데이터를 수정할 땐 그 데이터를 직접 수정하는 것이 아니라, 그 데이터를 기반으로 한 새로운 버전(new copy)의 데이터를 새로 “생성” 하도록 하고 있다.</li>\n<li><a href=\"\">Encapsulate Variable</a> 기법을 활용하여 데이터 변경이 특정 함수 내에서 일어나게 함으로써 데이터의 변화를 모니터링하기 쉽게 할 수 있다.</li>\n<li>만약 어떤 변수가 기존의 것과 다른 것을 저장하도록 변경된다면, <a href=\"\">Split Variable</a>을 사용해서 두 값을 분리하여 관리하도록 하는 것을 권장한다.</li>\n<li><a href=\"\">Slide Statements</a>와 <a href=\"\">Extract Function</a>을 활용하여 데이터를 업데이트 하는 부분을 최대한 따로 빼내어 함수를 순수 함수로 바꿀 수 있다.</li>\n<li>API에선 <a href=\"\">Separate Query from Modifier</a>를 사용하여, 정말 필요한 경우가 아니라면 side effect가 존재하는 코드를 호출자가 사용하지 못하도록 하는 것을 추천한다. 또한 최대한 빨리 <a href=\"\">Remove Setting Method</a>를 적용하라.</li>\n<li>여러 군데에서 계산할 수 있는 (따라서 변경 가능한) mutable 데이터에선 상당히 불쾌한 냄새가 난다. Mutable 데이터는 버그와 혼란의 근원일 뿐만 아니라, 딱히 필요가 없는 존재이다.</li>\n<li>Mutable 데이터엔 <a href=\"\">Replace Derived Variable with Query</a>를 사용하여 냄새를 제거할 수 있다.</li>\n<li>물론, mutable 데이터의 스코프 범위가 몇 줄 안되는 경우엔 딱히 문제 될 게 없을 수 있으나, 스코프가 커짐에 따라 리스크도 커지게 된다. <a href=\"\">Combine Functions into Class</a> 혹은 <a href=\"\">Combine Functions into Transform</a>과 같은 방법을 사용하여 변수를 업데이트하는데 필요한 코드의 수를 제한하라.</li>\n<li>만약 (mutable) 변수가 어떤 내부적인 구조를 가지고 있다면 일반적으로 그 자리에서 변경하기보단 구조 전체를 갈아치우는 게 더 좋을 수 있다. 이 경우 <a href=\"\">Change Reference to Value</a>를 사용하라.</li>\n</ul>","frontmatter":{"title":"리팩토링 2판 요약 정리 Ch.3","date":"December 12, 2021","category":"architecture"}}},"pageContext":{"slug":"/architecture/refactoring_summary_3/","previous":{"fields":{"slug":"/javascript/event-bubbling-and-capturing/"},"frontmatter":{"title":"이벤트 버블링과 캡처링"}},"next":null}},"staticQueryHashes":[]}