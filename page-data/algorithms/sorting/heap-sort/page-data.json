{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithms/sorting/heap-sort/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"694d1a16-186d-5bcb-8c16-cc004b2ce1a2","excerpt":"힙(Heap)이란? 힙 정렬은 Heap이라는 자료구조를 이용한 정렬 알고리즘입니다. 힙에는 최소 힙(min heap)과 최대 힙(max heap)이 있는데, 이들은 값이 저장되는 방향만 반대일 뿐 성질은 동일합니다. 이때 힙(heap)은 complete binary tree를 기반으로 한 자료구조로, 다음의 힙 성질(heap property)을 만족합니다: min-heap property: 각 노드의 값은 자기 자식의 값보다 작거나 같습니다. max-heap property…","html":"<h2 id=\"힙heap이란\" style=\"position:relative;\"><a href=\"#%ED%9E%99heap%EC%9D%B4%EB%9E%80\" aria-label=\"힙heap이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>힙(Heap)이란?</h2>\n<p>힙 정렬은 <strong>Heap</strong>이라는 자료구조를 이용한 정렬 알고리즘입니다. 힙에는 최소 힙(min heap)과 최대 힙(max heap)이 있는데, 이들은 값이 저장되는 방향만 반대일 뿐 성질은 동일합니다.</p>\n<p>이때 <strong>힙(heap)</strong>은 <a href=\"https://www.programiz.com/dsa/complete-binary-tree\" target=\"_blank\" rel=\"noreferrer noopener\">complete binary tree</a>를 기반으로 한 자료구조로, 다음의 힙 성질(heap property)을 만족합니다:</p>\n<ul>\n<li><strong>min-heap property</strong>: 각 노드의 값은 자기 자식의 값보다 작거나 같습니다.</li>\n<li><strong>max-heap property</strong>: 각 노드의 값은 자기 자식의 값보다 크거나 같습니다.</li>\n</ul>\n<p>leaf 노드는 자식이 없으므로 논리상 이 성질을 자동으로 만족하게 됩니다. 모든 노드가 위 성질을 만족하면, min heap의 경우 root에는 최솟값이 자리하게 되고, max heap의 경우 최대값이 자리하게 됩니다. 이 포스트에선 min heap을 기준으로 설명하겠습니다.</p>\n<h2 id=\"개념\" style=\"position:relative;\"><a href=\"#%EA%B0%9C%EB%85%90\" aria-label=\"개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>개념</h2>\n<p>힙 정렬은 우선 주어진 배열을 힙으로 만듭니다(heapify). 그런 다음, 힙에서 가장 작은 값을 차례로 하나씩 제거하면서 힙의 크기를 줄여나갑니다. 이렇게 하면 마지막에는 힙에 아무 원소도 남지 않게 되는데, 이 경우 힙 정렬 과정이 완료됩니다.</p>\n<p>우선 주어진 배열을 힙으로 만드는 과정, 힙에서 최소 원소를 제거하고 나서도 heap property를 만족하도록 힙을 “수선” 하는 과정을 살펴봅시다.</p>\n<h3 id=\"힙-만들기\" style=\"position:relative;\"><a href=\"#%ED%9E%99-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"힙 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>힙 만들기</h3>\n<p>일반적으로 트리를 표현할 때는 포인터 등을 이용하여 구현할 수도 있으나, complete binary tree이기 때문에 그렇게 하지 않고도 간단하게 구현할 수 있습니다. 아래 그림은 배열을 통해 최소 힙을 표현한 예시입니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/sorting/heap-sort/fig1.png\" alt=\"배열을 이용하여 최소힙 표현\">\n    <figcaption>배열을 이용하여 최소힙 표현.</figcaption>\n</figure>\n<p>일반적으로 <code class=\"language-text\">A[i]</code>의 자식은 왼쪽, 오른쪽 각각 <code class=\"language-text\">A[2i + 1]</code>, <code class=\"language-text\">A[2i + 2]</code>가 됩니다. 또한, <code class=\"language-text\">A[i]</code>의 부모는 <code class=\"language-text\">A[⌊(i-1)/2⌋]</code>가 됩니다. 이렇게 배열의 인덱스를 이용하여 부모·자식 간의 관계를 간단하게 계산할 수 있으므로 따로 포인터 등을 이용하여 구현할 필요가 없는 것이죠!</p>\n<p>이제 정렬하고자 하는 <code class=\"language-text\">n</code>개의 원소를 가진 배열 <code class=\"language-text\">A[0 ⋯ n-1]</code>이 있다고 해봅시다. 위 그림과 같이 이 배열을 complete binary tree로 해석할 수 있지만, 각각의 값들이 힙 성질을 만족하지 않고 제멋대로 들어 있다고 한다면, 이 배열이 힙 성질을 만족하도록 요소들을 재배치해서 힙으로 만들어야 합니다. 이 과정을 그림으로 나타내면 다음과 같습니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/sorting/heap-sort/fig2.png\" alt=\"heapify 프로세스 1\">\n    <figcaption>heapify 프로세스 1.</figcaption>\n</figure>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/sorting/heap-sort/fig3.png\" alt=\"heapify 프로세스 2\">\n    <figcaption>heapify 프로세스 2.</figcaption>\n</figure>\n<ul>\n<li><strong>(a)</strong>: 초기에 주어진 배열로, 배열의 원소들이 아무렇게나 들어있는 상태입니다.</li>\n<li><strong>(b)</strong>: 맨 뒤에서부터 시작하여, (최소)힙 성질을 만족하지 않는 첫 번째 원소 <code class=\"language-text\">A[2]</code>를 체크합니다. 부모와 자식의 값이 힙 성질을 만족하지 않으므로 <code class=\"language-text\">A[2]</code>와 <code class=\"language-text\">A[5]</code>를 스왑합니다.</li>\n<li><strong>(c)</strong>: 힙 성질을 만족하지 않는 두 번째 원소인 <code class=\"language-text\">A[1]</code>을 체크합니다. 두 자식 <code class=\"language-text\">A[3]</code>, <code class=\"language-text\">A[4]</code>중 작은 값인 6보다 크므로 이 둘을 스왑합니다.</li>\n<li><strong>(d)</strong>: 힙 성질을 만족하지 않는 세 번째 원소인 <code class=\"language-text\">A[0]</code>을 체크하여 두 자식 중 작은 값인 3과 스왑합니다</li>\n<li><strong>(e)</strong>: 방금 교환해서 <code class=\"language-text\">A[2]</code>로 내려온 7이 자식의 값 4보다 크므로 둘을 스왑합니다.</li>\n</ul>\n<hr />\n<p>아래 수도 코드는 배열 <code class=\"language-text\">A[0 ⋯ n-1]</code>을 입력으로 받아 힙을 만드는 알고리즘입니다. <code class=\"language-text\">heapify(A, k, n)</code>은 <code class=\"language-text\">k</code> 밑에 있는 두 서브 트리가 힙 성질을 만족하는 상태에서 <code class=\"language-text\">k</code>를 루트로 하는 트리가 힙 성질을 만족하도록 수정하는 함수입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>    <span class=\"token comment\">// A[0 ⋯ n-1]을 힙으로 만듦.</span>\n  <span class=\"token keyword\">for</span> i from <span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> down to <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// A[k]를 루트로 하는 트리를 힙 성질을 만족하도록 수정한다.</span>\n<span class=\"token comment\">// A[k]의 두 자식을 루트로 하는 서브 트리는 힙 성질을 만족한다.</span>\n<span class=\"token comment\">// n은 최대 인덱스를 나타낸다 (전체 배열의 크기).</span>\n<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> k<span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  left <span class=\"token operator\">=</span> <span class=\"token number\">2</span>k <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  right <span class=\"token operator\">=</span> <span class=\"token number\">2</span>k <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>    <span class=\"token comment\">// k가 두 자식을 가지는 경우.</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> smaller <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">else</span><span class=\"token operator\">:</span> smaller <span class=\"token operator\">=</span> right<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>    <span class=\"token comment\">// k가 왼쪽 자식만 가지는 경우.</span>\n    smaller <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">else</span><span class=\"token operator\">:</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// k가 리프 노드이므로 종료.</span>\n\n  <span class=\"token comment\">// 재귀적 조정. 즉, k와 smaller를 바꾼 다음</span>\n  <span class=\"token comment\">// smaller를 루트로 했을 때에도 힙 성질을 만족하는지 체크.</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>smaller<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>smaller<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> smaller<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>leaf는 그 자체로 힙 성질을 만족하므로, <code class=\"language-text\">buildHeap()</code>은 leaf가 아닌 노드 중 맨 뒤에서부터 루트로 삼아 <code class=\"language-text\">heapify()</code>를 수행합니다. 즉, 위 코드에서 <code class=\"language-text\">⌊n/2⌋</code>는 leaf가 아닌 노드 중 맨 마지막 노드의 인덱스를 나타냅니다.</p>\n<p><code class=\"language-text\">A[⌊n/2⌋]</code>부터 <code class=\"language-text\">A[0]</code>까지 차례로 루트로 삼아 총 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">⌊</mo><mfrac><mi>n</mi><mn>2</mn></mfrac><mo stretchy=\"false\">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">⌊\\frac{n}{2}⌋ + 1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.095em;vertical-align:-0.345em;\"></span><span class=\"mopen\">⌊</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.695392em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">n</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">⌋</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>번의 <code class=\"language-text\">heapify()</code>를 수행하고 나면 <code class=\"language-text\">A[0 ⋯ n-1]</code>는 힙 성질을 만족하게 됩니다.</p>\n<hr />\n<p><code class=\"language-text\">buildHeap</code>의 수행시간을 살펴봅시다. 우선, <code class=\"language-text\">heapify(A, k, n)</code>함수는 <code class=\"language-text\">k</code>를 루트로 하는 트리의 높이가 시간을 좌우하는데, 어떠한 이진 트리도 높이가 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">log_{2}n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mord mathdefault\">n</span></span></span></span>을 넘지 않으므로 <code class=\"language-text\">heapify</code>를 한 번 수행하는데 <code class=\"language-text\">O(logn)</code>이 소요됩니다. 따라서 <code class=\"language-text\">buildHeap</code>에서 <code class=\"language-text\">heapify</code>를 호출하는 횟수는 <code class=\"language-text\">⌊n/2⌋</code>이므로, 전체적으로 <code class=\"language-text\">O(nlogn)</code>이 소요된다고 할 수 있습니다.</p>\n<p>하지만 이것은 다소 과하게 잡은 상한인데, 모든 <code class=\"language-text\">heapify</code>가 <code class=\"language-text\">O(logn)</code>만큼 걸린다고 보는 것은 과하다고 할 수 있습니다. 그 이유는, 맨 처음에 호출되는 <code class=\"language-text\">heapify</code>의 트리의 높이는 1이고, 이렇게 높이가 1인 트리가 여러 개 존재합니다. 그다음 레벨로(즉, 위로) 올라가면 높이가 2인 트리들을 만나게 되는데, 높이가 2인 트리의 개수는 높이가 1인 트리의 개수보다 적습니다. 이런 식으로 위로 올라갈수록 높이가 높은 트리의 수가 줄어들게 되는데, 이를 합산하면 <code class=\"language-text\">O(nlogn)</code>이 아닌 <code class=\"language-text\">Θ(n)</code>이 됩니다.</p>\n<h3 id=\"정렬\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC\" aria-label=\"정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>정렬</h3>\n<p><code class=\"language-text\">heapify</code>를 통해 힙이 완성되었다면 이를 기반으로 정렬을 수행할 차례입니다. 루트 노드를 맨 마지막 노드와 스왑하고, 힙의 크기를 1만큼 줄여 <code class=\"language-text\">heapify</code>를 실행하는 과정을 반복하면 정렬된 배열을 얻을 수 있습니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/sorting/heap-sort/fig4.png\" alt=\"heapify 프로세스 1\">\n    <figcaption>힙 정렬 프로세스 1.</figcaption>\n</figure>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/sorting/heap-sort/fig5.png\" alt=\"heapify 프로세스 2\">\n    <figcaption>힙 정렬 프로세스 2.</figcaption>\n</figure>\n<ul>\n<li><strong>(a)</strong>: <code class=\"language-text\">heapify</code>를 통해 만들어진 배열입니다.</li>\n<li><strong>(b)</strong>: root와 맨 마지막 원소를 스왑합니다.</li>\n<li><strong>(c) ~ (d)</strong>: heap의 크기를 하나 줄이고, 줄어든 heap에 대해 <code class=\"language-text\">heapify</code>를 수행합니다.</li>\n<li><strong>(e)</strong>: <strong>(b)</strong>에서와 같이, root와 맨 마지막 원소를 스왑합니다.</li>\n<li><strong>(f)</strong>: <strong>(c) ~ (d)</strong>에서와 같이, heap의 크기를 하나 줄이고, 줄어든 heap에 대해 <code class=\"language-text\">heapify</code>를 수행합니다.</li>\n<li><strong>(g)</strong>: 위 과정들을 반복하면 최종적으로 정렬된 배열을 얻을 수 있습니다.</li>\n</ul>\n<p>최종적인 힙 정렬에 대한 수도코드는 다음과 같습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>   <span class=\"token comment\">// A[0 ⋯ n-1]을 정렬한다.</span>\n  <span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> i from n <span class=\"token operator\">-</span> <span class=\"token number\">1</span> down to <span class=\"token number\">0</span><span class=\"token operator\">:</span>\n    <span class=\"token function\">swap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>힙 정렬의 수행 시간을 살펴보자면 우선, <code class=\"language-text\">buildHeap</code>은 <code class=\"language-text\">Θ(n)</code>만큼의 시간이 걸립니다. <code class=\"language-text\">heapSort</code>의 for루프는 <code class=\"language-text\">n-1</code>번 순환하고, 각 순환에서 시간을 좌우하는 <code class=\"language-text\">heapify</code>는 <code class=\"language-text\">O(logn)</code>이 걸리므로 힙 정렬의 총 수행시간은 <code class=\"language-text\">O(nlogn)</code>이 됩니다.</p>\n<h2 id=\"자바스크립트-구현\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B5%AC%ED%98%84\" aria-label=\"자바스크립트 구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>자바스크립트 구현</h2>\n<p>min heap을 이용한 내림차순 정렬:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> left <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> root <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">let</span> right <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> root <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">let</span> smaller <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> smaller <span class=\"token operator\">=</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> left <span class=\"token operator\">:</span> right<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> smaller <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>smaller<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>smaller<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>smaller<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> smaller<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [ 9, 8, 7, 6, 4, 3 ]</span></code></pre></div>\n<p>max heap을 이용한 오름차순 정렬:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">buildHeap</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> root<span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> left <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> root <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">let</span> right <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> root <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">let</span> larger <span class=\"token operator\">=</span> root<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>right <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> larger <span class=\"token operator\">=</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>left<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>right<span class=\"token punctuation\">]</span> <span class=\"token operator\">?</span> left <span class=\"token operator\">:</span> right<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>left <span class=\"token operator\">&lt;</span> n<span class=\"token punctuation\">)</span> larger <span class=\"token operator\">=</span> left<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">else</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>larger<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>larger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>root<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">[</span>larger<span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token function\">heapify</span><span class=\"token punctuation\">(</span><span class=\"token constant\">A</span><span class=\"token punctuation\">,</span> larger<span class=\"token punctuation\">,</span> n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token number\">9</span><span class=\"token punctuation\">,</span> <span class=\"token number\">4</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">heapSort</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// [ 3, 4, 6, 7, 8, 9 ]</span></code></pre></div>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>REFERENCE</h2>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=13241308\" target=\"_blank\" rel=\"noreferrer noopener\">쉽게 배우는 알고리즘 - 문병로</a></li>\n</ul>","frontmatter":{"title":"힙 정렬","date":"May 31, 2022","category":"Algorithms"}}},"pageContext":{"slug":"/algorithms/sorting/heap-sort/","previous":{"fields":{"slug":"/algorithms/sorting/quick-sort/"},"frontmatter":{"title":"퀵 정렬"}},"next":null}},"staticQueryHashes":[]}