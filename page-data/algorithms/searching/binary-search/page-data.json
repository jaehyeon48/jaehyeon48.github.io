{"componentChunkName":"component---src-templates-blog-post-js","path":"/algorithms/searching/binary-search/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"e65b0f94-350b-5992-b35f-d9c3fd9fb074","excerpt":"이진 탐색이란? 어떤 그룹 내에 존재하는 요소를 찾고자 할 때, 가장 일반적인 방법은 해당 그룹의 요소를 하나하나 살펴보는 것입니다. 이를 선형 탐색(linear search)라고 하는데, 이러한 알고리즘은 의 시간복잡도를 갖습니다. 이때 그룹 내의 요소들이 일정한 순서로 정렬되어 있다면 이진 탐색(binary search…","html":"<h2 id=\"이진-탐색이란\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89%EC%9D%B4%EB%9E%80\" aria-label=\"이진 탐색이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>이진 탐색이란?</h2>\n<p>어떤 그룹 내에 존재하는 요소를 찾고자 할 때, 가장 일반적인 방법은 해당 그룹의 요소를 하나하나 살펴보는 것입니다. 이를 선형 탐색(linear search)라고 하는데, 이러한 알고리즘은 <code class=\"language-text\">O(n)</code>의 시간복잡도를 갖습니다.</p>\n<p>이때 그룹 내의 요소들이 일정한 순서로 <em>정렬</em>되어 있다면 <strong>이진 탐색(binary search)</strong> 기법을 활용할 수 있습니다. 이진 탐색의 기본 아이디어는 일정 범위에 대해, 범위의 중간 부분에 찾고자 하는 요소가 있는지 확인하고 만약 없다면 현재 살펴보고 있는 요소를 기준으로 검색 범위를 절반씩 줄여나가는 것입니다.</p>\n<p>숫자가 저장된 배열을 예로 들면 다음과 같습니다. (<a href=\"https://blog.penjee.com/binary-vs-linear-search-animated-gifs/\" target=\"_blank\" rel=\"noreferrer noopener\">이미지 출처</a>):</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/searching/binary-search/linear_vs_binary_search_avg_case.gif\" alt=\"linear vs. binary search comparison in average case\">\n    <figcaption>선형 탐색 vs. 이진 탐색 - 일반적인 경우</figcaption>\n</figure>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/searching/binary-search/linear_vs_binary_search_best_case.gif\" alt=\"linear vs. binary search comparison in average case\">\n    <figcaption>선형 탐색 vs. 이진 탐색 - 최선의 경우</figcaption>\n</figure>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/algorithms/searching/binary-search/linear_vs_binary_search_worst_case.gif\" alt=\"linear vs. binary search comparison in average case\">\n    <figcaption>선형 탐색 vs. 이진 탐색 - 최악의 경우</figcaption>\n</figure>\n<p>이처럼 현재 살펴보고 있는 요소와 우리가 찾고자 하는 요소가 같은지를 검사할 때마다 탐색 범위를 절반씩 줄여나가기 때문에 일반적으로 선형 탐색보다 성능이 훨씬 뛰어납니다. 이진 탐색의 시간 복잡도는 <code class=\"language-text\">O(log n)</code> 입니다.</p>\n<h2 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>구현</h2>\n<p>📌 배열의 모든 요소가 숫자이고, 오름차순으로 정렬된 배열을 예시로 들겠습니다.</p>\n<h3 id=\"탐색-범위\" style=\"position:relative;\"><a href=\"#%ED%83%90%EC%83%89-%EB%B2%94%EC%9C%84\" aria-label=\"탐색 범위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>탐색 범위</h3>\n<p>이진 탐색은 일정 범위를 설정한 뒤 범위를 계속 좁혀나가는 방식으로 원하는 값을 찾아나간다고 볼 수 있습니다. 왼쪽 경계를 <code class=\"language-text\">lo</code>, 오른쪽 경계를 <code class=\"language-text\">hi</code>라고 한다면, 일반적인 상황에서 초기 범위는 배열 전체가 될 것입니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> lo <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> hi <span class=\"token operator\">=</span> arr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3 id=\"mid\" style=\"position:relative;\"><a href=\"#mid\" aria-label=\"mid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>mid</h3>\n<p>이렇게 찾고자 하는 범위가 설정되면, 해당 범위의 중간에 오는 요소를 살펴봅니다. 일반적으로 중간 요소의 인덱스를 다음과 같이 구할 수 있을 것입니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> mid <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>lo <span class=\"token operator\">+</span> hi<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 범위안에 요소가 짝수개 있는 경우, 중간 값 후보 2개 중 왼쪽 요소를 선택</span>\n<span class=\"token keyword\">const</span> mid <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>lo <span class=\"token operator\">+</span> hi <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 범위안에 요소가 짝수개 있는 경우, 중간 값 후보 2개 중 오른쪽 요소를 선택</span></code></pre></div>\n<p>하지만 중간 요소의 인덱스를 위와 같이 구하게 되면, 인덱스가 매우 클 때 오버플로우가 발생할 수 있습니다. 이를 방지하기 위해 아래와 같은 방법을 사용할 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 훨씬 낫긴 합니다만 여전히 오버플로우가 발생할 가능성이 있습니다.</span>\n<span class=\"token keyword\">const</span> mid <span class=\"token operator\">=</span> lo <span class=\"token operator\">+</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">floor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>hi <span class=\"token operator\">-</span> lo<span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 가장 좋은 방법입니다만 한눈에 이해하기 어려울 수 있습니다.</span>\n<span class=\"token keyword\">const</span> mid <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>lo <span class=\"token operator\">+</span> hi<span class=\"token punctuation\">)</span> <span class=\"token operator\">>>></span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>(물론 자바스크립트에선 정확하게 표현할 수 있는 정수값이 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>53</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{53}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">5</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>인데 반해, 배열의 최대 길이가 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{32}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>이므로 오버플로우가 발생할 가능성은 없다고 할 수 있을 것 같습니다.)</p>\n<h3 id=\"범위-줄여나가기\" style=\"position:relative;\"><a href=\"#%EB%B2%94%EC%9C%84-%EC%A4%84%EC%97%AC%EB%82%98%EA%B0%80%EA%B8%B0\" aria-label=\"범위 줄여나가기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>범위 줄여나가기</h3>\n<p>범위의 중간 인덱스를 구했으면 해당 인덱스의 요소와 우리가 찾고자 하는 요소를 비교할 차례입니다. 오름차순으로 정렬된 배열이라고 가정하고, 중간 요소를 <code class=\"language-text\">mid</code>, 찾고자 하는 요소를 <code class=\"language-text\">target</code>이라 한다면 다음과 같이 범위를 줄여나갈 수 있습니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// mid === target인 경우 우리가 찾고자 하는 요소를 찾은 것이므로</span>\n<span class=\"token comment\">// 해당 인덱스를 반환하고 알고리즘을 종료하면 됩니다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> target<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> mid<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// mid &lt; target인 경우 중간 요소를 포함하여 왼쪽에 있는 요소들은 살펴볼 필요가 없게 됩니다.</span>\n<span class=\"token comment\">// 따라서 이 경우 왼쪽 경계를 mid + 1 인덱스로 당깁니다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">&lt;</span> target<span class=\"token punctuation\">)</span> lo <span class=\"token operator\">=</span> mid <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// mid > target인 경우 중간 요소를 포함하여 오른쪽에 있는 요소들은 살펴볼 필요가 없게 됩니다.</span>\n<span class=\"token comment\">// 따라서 이 경우 오른쪽 경계를 mid - 1 인덱스로 당깁니다.</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>arr<span class=\"token punctuation\">[</span>mid<span class=\"token punctuation\">]</span> <span class=\"token operator\">></span> target<span class=\"token punctuation\">)</span> hi <span class=\"token operator\">=</span> mid <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 방법을 사용하여 범위를 절반씩 줄여나갈 수 있습니다. 내림차순의 경우 위와 반대로 하면 되겠죠.</p>\n<h3 id=\"언제까지-탐색\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C%EA%B9%8C%EC%A7%80-%ED%83%90%EC%83%89\" aria-label=\"언제까지 탐색 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>언제까지 탐색?</h3>\n<p>그럼 도대체 언제까지 탐색을 해나가야 할까요? 바로 범위의 크기가 1, 즉 <code class=\"language-text\">lo === hi</code>가 될때까지 탐색을 해나가면 됩니다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>lo <span class=\"token operator\">&lt;=</span> hi<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>계속해서 범위를 줄여나가다가 <code class=\"language-text\">lo > hi</code>가 되는 순간 탐색을 마치고 값을 찾지 못했다는 의미로 <code class=\"language-text\">-1</code> 등을 반환할 수 있습니다. 왼쪽 경계가 오른쪽 경계보다 더 커졌다는 말은 최초에 주어진 범위를 모두 탐색하였으나 값을 찾지 못했다는 뜻이니까요!</p>\n<h2 id=\"구현-코드\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C\" aria-label=\"구현 코드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>구현 코드</h2>\n<p><a href=\"https://github.com/jaehyeon48/ds-and-algo/tree/main/src/algorithms/searching/binarySearch\" target=\"_blank\" rel=\"noreferrer noopener\">구현 코드 보러가기</a></p>","frontmatter":{"title":"이진 탐색","date":"January 05, 2022","category":"Algorithms"}}},"pageContext":{"slug":"/algorithms/searching/binary-search/","previous":{"fields":{"slug":"/algorithms/leetcode/33/"},"frontmatter":{"title":"LeetCode No.33"}},"next":{"fields":{"slug":"/computer-architecture/unicode-and-character-sets/"},"frontmatter":{"title":"유니코드와 Character Set에 관하여"}}}},"staticQueryHashes":[]}