{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/limiting-scope-exposure-2/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"583c15d2-1499-5815-9405-e59cc866676a","excerpt":"1부 보러가기 var, 그리고 let 앞서 1부 마지막에 살펴본 코드에서  부분을 유심히 살펴보자. 왜 으로 선언하지 않고 로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical…","html":"<p><a href=\"../limiting_scope_exposure_1\">1부 보러가기</a></p>\n<hr class=\"custom-hr\">\n<h2 id=\"var-그리고-let\" style=\"position:relative;\"><a href=\"#var-%EA%B7%B8%EB%A6%AC%EA%B3%A0-let\" aria-label=\"var 그리고 let permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>var, 그리고 let</h2>\n<p>앞서 1부 마지막에 살펴본 코드에서 <code class=\"language-text\">var bucket</code> 부분을 유심히 살펴보자. 왜 <code class=\"language-text\">let</code>으로 선언하지 않고 <code class=\"language-text\">var</code>로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical)이유가 존재한다.</p>\n<p>일단 <code class=\"language-text\">var</code> 변수는 자바스크립트 초창기 시절부터 항상 함수 스코프를 가지는, 즉 “함수 전체에 속하는” 변수였다. 어디에서 선언되건 관계없이 <code class=\"language-text\">var</code>는 가장 가까운 함수 스코프(없으면 글로벌 스코프) 에 속하게 된다. 만약 다음과 같이 블록 안에 <code class=\"language-text\">var</code>가 선언되더라도 <code class=\"language-text\">var</code>는 블록 스코프가 아니라 함수 스코프이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n    <span class=\"token keyword\">var</span> b <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token comment\">// 블록 스코프에 속하는 것이 아니라 함수 스코프에 속함</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> b\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">func</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// 100</span></code></pre></div>\n<p>그럼 왜 <code class=\"language-text\">let</code> 대신 <code class=\"language-text\">var</code>를 사용한걸까? 일단 한눈에 보기에도 <code class=\"language-text\">var</code>는 <code class=\"language-text\">let</code>과 구별되기도 하고, <code class=\"language-text\">var</code> 자체가 주는 의미가 “이 변수는 함수 스코프임” 이기 때문이다. 물론 <code class=\"language-text\">let</code>을 함수 스코프 내에 선언하여 사용할 수도 있지만, 블록 내에 있는 다른 <code class=\"language-text\">let</code> 변수들과 잘 구별되지 않으므로 함수 전체에서 사용하는 <code class=\"language-text\">let</code>인지 혹은 특정 블록 내에서 사용하는 <code class=\"language-text\">let</code>인지 구별이 잘 되지 않을 수 있다.</p>\n<p>다시말해, 내 생각(원문 저자)엔 <code class=\"language-text\">let</code>보다 <code class=\"language-text\">var</code>가 “함수 전체에서 사용되는 변수”라는 의미를 더 잘 나타내므로 각자의 목적에 맞게 두 변수를 적절히 사용하는 것이 좋아보인다. 즉, “함수 스코프”라는 것을 나타내고 싶을땐 <code class=\"language-text\">var</code>를, “블록 스코프”라는 것을 나타내고 싶을땐 <code class=\"language-text\">let</code>을 사용하는게 적절할 것 같다.</p>\n<table>\n<thead>\n<tr>\n<th>⚠️ 경고</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code class=\"language-text\">var</code>와 <code class=\"language-text\">let</code>을 같이 사용하라는 내 생각은 분명 논쟁의 소지가 다분하다. 보통 “var는 오류가 많아. let을 사용해!” 라던가, 혹은 “var는 절대로 사용하면 안된다. 반드시 let을 써라”와 같은 말을 들어봤을 수도 있다. 물론 이러한 주장도 일리는 있다. 하지만 이 주장들도 내 주장과 마찬가지로 어디까지나 “주장”일 뿐이다. <code class=\"language-text\">var</code>는 고장나거나(broken), 혹은 deprecated 된 녀석이 아니다. 자바스크립트 초창기부터 아주 잘 작동해왔으며, 아마 앞으로도 (자바스크립트가 없어질때까지) 그럴것이다!</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"그럼-let은\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%9F%BC-let%EC%9D%80\" aria-label=\"그럼 let은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>그럼 let은?</h2>\n<p><code class=\"language-text\">var</code>를 사용할지, 혹은 <code class=\"language-text\">let</code>을 사용할지를 결정하는 것은 다음 물음을 통해 그 해답을 얻을 수 있다. “이 변수를 가장 최소한으로 노출시키는 스코프가 어디일까?”</p>\n<p>이 질문에 대한 답을 찾으면 해당 변수가 블록 스코프인지 혹은 함수 스코프인지 결정이 날 것이다. 만약 처음에는 블록 스코프라고 생각해서 <code class=\"language-text\">let</code>을 사용했다가, 나중에 살펴보니까 실은 함수 스코프인 경우 <code class=\"language-text\">var</code>로 변경하는 경우가 생길 수도 있다.</p>\n<h2 id=\"trycatch\" style=\"position:relative;\"><a href=\"#trycatch\" aria-label=\"trycatch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>try…catch!</h2>\n<p>앞서 <code class=\"language-text\">var</code>와 함수의 매개변수들은 함수 스코프임을, <code class=\"language-text\">let</code> (그리고 <code class=\"language-text\">const</code>)는 블록 스코프임을 암시한다는 것을 살펴보았다. 하지만 여기에 한가지 예외 상황이 있는데, 바로 <code class=\"language-text\">catch</code> 구문이다.</p>\n<p><code class=\"language-text\">try...catch</code>문이 처음으로 등장했던 ES3 (1999년) 부터, <code class=\"language-text\">catch</code>는 블록 스코프 기능을 가지고 있었다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doesntExist</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ReferenceError: doesntExist is not defined</span>\n\n  <span class=\"token keyword\">let</span> onlyHere <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n  <span class=\"token keyword\">var</span> outerVariable <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>outerVariable<span class=\"token punctuation\">)</span> <span class=\"token comment\">// true</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token comment\">// ReferenceError: error is not defined</span></code></pre></div>\n<p>위 코드에서 <code class=\"language-text\">catch</code>문에 의해 선언된 <code class=\"language-text\">error</code>변수는 <code class=\"language-text\">catch</code>블록에 속하는 블록 스코프 변수이다. 또한 또 다른 블록 스코프 변수 (<code class=\"language-text\">let</code>, <code class=\"language-text\">const</code>)를 <code class=\"language-text\">catch</code> 블록 내에 포함할 수도 있다. 하지만 함수 스코프인 <code class=\"language-text\">var</code>는 <code class=\"language-text\">catch</code>블록에 귀속되지 않고 함수 스코프 방식(여기서는 글로벌 스코프)으로 동작한다.</p>\n<p>ES2019 부터는 <code class=\"language-text\">catch</code>문에 변수를 선언하지 않을 수도 있다 (즉, <code class=\"language-text\">error</code> 변수 없이 <code class=\"language-text\">catch</code>를 사용). 만약 이렇게 하면 <code class=\"language-text\">catch</code> 블록은 “블록” 이지만 “스코프”가 아니게 된다. 따라서 <code class=\"language-text\">error</code> 변수를 굳이 사용할 필요가 없다면 변수를 생략해도 된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doSomething</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">doAnotherOne</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"블록-내에서-함수-선언하기-fib\" style=\"position:relative;\"><a href=\"#%EB%B8%94%EB%A1%9D-%EB%82%B4%EC%97%90%EC%84%9C-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%ED%95%98%EA%B8%B0-fib\" aria-label=\"블록 내에서 함수 선언하기 fib permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>블록 내에서 함수 선언하기 (FiB)</h2>\n<p>이제껏 우리는 <code class=\"language-text\">var</code>가 함수 스코프, <code class=\"language-text\">let</code>(그리고 <code class=\"language-text\">const</code>)는 블록 스코프라는 것을 살펴보았다. 그렇다면 블록 내에 존재하는 함수 선언은 어떻게 처리될까? 이 문제를 Function Declarations in Blocks (Fib)라고 한다. 우리는 흔히 함수 선언이 <code class=\"language-text\">var</code>와 유사하다고 생각한다. 그럼 함수 선언도 <code class=\"language-text\">var</code>와 같이 함수 스코프일까?</p>\n<p>그럴 수도 있고, 아닐 수도 있다. 하이고… 골이 땡긴다 🤦</p>\n<p>한번 천천히 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'정말 실행되나?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>위 코드를 실행하면 어떤 결과가 나올까?</p>\n<ol>\n<li><code class=\"language-text\">ask</code> identifier가 <code class=\"language-text\">if</code> 블록 내부에 존재하므로 블록 밖인 글로벌 스코프에서 <code class=\"language-text\">ask()</code>를 호출하면 <code class=\"language-text\">ReferenceError</code>가 발생할 것 이다.</li>\n<li><code class=\"language-text\">ask</code>라는 identifer가 존재는 하지만 <code class=\"language-text\">undefined</code>이므로 (왜냐면 <code class=\"language-text\">if</code>문이 실행되지 않았기 때문에!) <code class=\"language-text\">ask()</code>를 호출하면 <code class=\"language-text\">TypeError</code>가 발생할 것이다.</li>\n<li><code class=\"language-text\">ask()</code>가 정상적으로 동작하여 결과가 출력될 것이다.</li>\n</ol>\n<p>이 때 정말 정말 혼란스러운 일이 발생한다. 위 코드의 결과는 자바스크립트 런타임(실행환경)에 따라 다를 수 있다! 이와 같은 상황은 자바스크립트에서 legacy로 인해 예측 불가능한 결과가 나오는 몇 안되는 상황 중 하나이다.</p>\n<p>자바스크립트 스펙을 살펴보면 블록 내부에 존재하는 함수 선언은 블록 스코프이어야 한다고 되어있다. 따라서, 따지고 보면 1번이 정답이다. 하지만 브라우저(엔진)들은 거의 대부분 2번 방식으로 동작할 것이다. 즉, 함수의 identifier가 블록 외부로 노출이 되지만 자동적으로 초기화 되지는 않기 때문에 <code class=\"language-text\">undefined</code>로 남아있게 된다.</p>\n<p>그렇다면 도대체 왜 브라우저(엔진)들은 스펙대로 동작하지 않고 자기 멋대로(?) 동작하는 걸까?? 그 이유는, 브라우저들은 ES6에서 블록 스코프에 대한 개념이 생기기 전부터 이미 FiB에 관해 특정한 방식으로 동작해왔기 때문이다. 만약 스펙대로 동작하고자 기존에 동작하던 방식을 바꿔버리면 웹사이트들이 정상적으로 동작하지 못하게 될 수 있기 때문에 스펙과 다르게 동작하는 것이다.</p>\n<br/>\n<p>함수 선언을 블록 내부에 하는 경우 중 한 예시는 다음 코드와 같이 특정 조건에 따라 함수를 다르게 정의하는 경우이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Array<span class=\"token punctuation\">.</span>isArray <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Array]'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이와 같은 방법으로 코딩하는 이유는, 만약 함수 내부에서 <code class=\"language-text\">if</code>문을 사용하여 동작을 다르게 정의하면 매번 함수를 호출할 때마다 불필요하게 체킹을 해야 하므로 성능상의 패널티가 존재하기 때문이다.</p>\n<table>\n<thead>\n<tr>\n<th>⚠️ 경고</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>FiB의 예측 불허한 특성 이외에, 위 코드와 같이 분기문을 통해 여러 버전의 함수를 만들게 되면 디버깅이 (매우) 힘들어지는 단점이 있다. 예를 들어, <code class=\"language-text\">isArray()</code> 함수에 버그가 발생하여 해당 버그를 고쳐야할 때 우선 어느 버전의 <code class=\"language-text\">isArray()</code>에 문제가 생겼는지 살펴봐야한다. 가끔 분기 조건을 잘못 체크하여 엉뚱한 버전을 고치는 경우가 발생할 수도 있다. 따라서 하나의 함수에 대해 분기문을 통해 여러 버전을 만드는 경우, 디버깅이 매우 힘들어 질 수 있다는 점을 분명히 염두해야 한다.</td>\n</tr>\n</tbody>\n</table>\n<br/>\n<p>앞서 살펴본 예시 외에도 FiB에 대한 여러가지 이례적인 케이스들이 도사리고 있다. 이러한 케이스들도 물론 자바스크립트 실행환경에 따라 다르게 동작한다. 예를 들면:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'이거 호출?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'아니면 이거 호출?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'그것도 아니면 이것들 중 하나?'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">ask</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'아 혹시 이건가?'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>함수 호이스팅을 고려해 본다면 <code class=\"language-text\">아 혹시 이건가?</code>를 출력하는 제일 마지막 <code class=\"language-text\">ask()</code> 함수가 <code class=\"language-text\">ask();</code> 출력 바로 위에 호이스팅 되어 이 함수가 실행될 것이라 예측할 수도 있다. 진짜 그럴까?</p>\n<p>아니다 (하… 🤦‍♂️)</p>\n<p>이러한 이상한(?) 케이스들을 전부 소개할 생각도 없고, 왜 이런식으로 동작하는지 설명할 생각은 더더욱 없다. 내 생각(원문 저자)엔 이러한 경우들은 그냥 미스테리한 legacy 동작들이다.</p>\n<p>적어도 내가 생각하기로는, 이렇게 이상하게 동작하는 FiB를 피하는 가장 실용적인 해결책은 <strong>그냥 FiB를 사용하지 않는것</strong>이다. 즉, 블록안에서 함수 선언을 하지말고 항상 가장 바깥 함수 스코프(만약 여러 스코프가 중첩된 경우 그 중 가장 바깥) 혹은 글로벌 스코프에다 함수를 선언하는 것이 예측 불가능한 상황들을 피할 수 있는 방법인 것 같다.</p>\n<p>따라서 앞에서 살펴본 두 버전의 <code class=\"language-text\">isArray</code>를 선언하는 방법은 다음과 같이 할 수 있을 것 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Array<span class=\"token punctuation\">.</span>isArray <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token string\">'[object Array]'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아 물론이다. 이렇게 하면 다소 성능이 저하될 수는 있다. 하지만 보다 전체적인 관점에서 봤을 때 이렇게 하는 것이 더 좋을 것이다.</p>\n<p>만약 위와 같이 코딩함으로 인해 발생하는 성능 저하가 애플리케이션에 치명적이라면, 다음과 같이 코딩할 수도 있을 것이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">isArray</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Array<span class=\"token punctuation\">.</span><span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// override the definition, if you must</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> Array<span class=\"token punctuation\">.</span>isArray <span class=\"token operator\">===</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function-variable function\">isArray</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">isArray</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">a</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">===</span> <span class=\"token string\">'[object Array]'</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 유심히 살펴봐야 할 것은, <code class=\"language-text\">if</code>문 내부에서 함수 선언문 말고 함수 표현식을 사용했다는 점이다. 이렇게 “함수 표현식”을 블록 안에 사용하는 것은 괜찮다. 우리가 앞에서 피하고자 했던 FiB는 블록 내부에 함수 표현식이 아니라 함수 선언문을 사용하는 것이었다.</p>\n<p>만약 FiB 스타일로 코딩을 해서 테스팅 했을 때 정상적으로 돌아간다고 쳐도, FiB 스타일로부터 얻는 이점보다 추후에 FiB의 예측불가능한 특성으로 인한 단점이 더 커질 것이다. 따라서 되도록이면 FiB 스타일을 사용하지 말자.</p>","frontmatter":{"title":"자바스크립트 변수 노출 최소화 하기 Part2","date":"August 20, 2020","category":"JavaScript"}}},"pageContext":{"slug":"/javascript/limiting-scope-exposure-2/","previous":{"fields":{"slug":"/javascript/hoisting/"},"frontmatter":{"title":"자바스크립트 호이스팅"}},"next":{"fields":{"slug":"/javascript/closure-1/"},"frontmatter":{"title":"자바스크립트 클로저 Part1"}}}},"staticQueryHashes":[]}