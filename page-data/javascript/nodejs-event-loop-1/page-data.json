{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/nodejs-event-loop-1/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"07ef7a8c-8a4a-524b-a27f-87774ac4c54c","excerpt":"2부 보러가기 이벤트 루프란? 이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation들을 커널에 맡기는 방식으로 진행하는데, 대부분의 현대 운영체제들은 멀티 스레드이므로 백그라운드에서 여러 operation들을 동시에 실행시키는 것이 가능하다. 이렇게 백그라운드에서 operation을 처리하다가 해당 작업을 완료하면 커널이 Node.js…","html":"<p><a href=\"../nodejs_event_loop_2/\">2부 보러가기</a></p>\n<hr class=\"custom-hr\">\n<h2 id=\"이벤트-루프란\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84%EB%9E%80\" aria-label=\"이벤트 루프란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>이벤트 루프란?</h2>\n<p>이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation들을 커널에 맡기는 방식으로 진행하는데, 대부분의 현대 운영체제들은 멀티 스레드이므로 백그라운드에서 여러 operation들을 동시에 실행시키는 것이 가능하다.</p>\n<p>이렇게 백그라운드에서 operation을 처리하다가 해당 작업을 완료하면 커널이 Node.js에게 작업이 완료되었다고 알리고, 알림을 받은 Node.js는 적절한 핸들러(콜백)를 <code class=\"language-text\">poll queue</code> 에 등록하여 이 콜백을 (추후에) 실행한다. 더 자세한 사항들은 잠시 후에 살펴보자.</p>\n<h2 id=\"이벤트-루프-살펴보기\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"이벤트 루프 살펴보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>이벤트 루프 살펴보기</h2>\n<p>Node.js를 실행하게 되면 이벤트 루프를 초기화하고 (개발자가 작성한) 자바스크립트 파일을 실행한다. 이벤트 루프의 전체적인 흐름을 그림으로 나타내면 다음과 같다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop1.png\" alt=\"event loop example 1\" style=\"width:721px; height: 550px\">\n    <figcaption>출처: https://www.voidcanvas.com/nodejs-event-loop/</figcaption>\n</figure>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop2.png\" alt=\"event loop example 2\" style=\"width:798px; height: 500px\">\n    <figcaption>출처: https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810</figcaption>\n</figure>\n<br/>\n<p>이벤트 루프의 각 단계를 <code class=\"language-text\">phase</code> 라고 하며, 각각의 phase마다 콜백을 실행할 FIFO 구조의 큐를 가지고 있어서 이벤트 루프가 각 phase에 진입하면 해당 phase에서 수행해야 할 operation들을 수행한 후 해당 phase 큐에 있는 모든 콜백 (혹은 일정한 수의 콜백)을 실행한다.</p>\n<p>모든 콜백 (혹은 limit을 넘지않는 수의 콜백)을 처리하고 나면 이벤트 루프는 다음 phase로 이동하여 위 동작들을 반복한다. 이 때, 어떤 phase에서 다음 phase로 넘어가는 과정을 <code class=\"language-text\">tick</code> 이라고 한다.</p>\n<p>위 그림 중 첫 번째 그림은 이벤트 루프를 libuv의 관점에서 본 것이고, 두 번째 그림은 자바스크립트의 관점에서 본 것이라 할 수 있다. 위 두 관점을 하나로 합쳐 다음 그림으로 표현할 수 있다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nodejs_event_loop3.png\" alt=\"event loop example 3\">\n    <figcaption>출처: https://blog.insiderattack.net/handling-io-nodejs-event-loop-part-4-418062f917d1</figcaption>\n</figure>\n<h2 id=\"phase-overview\" style=\"position:relative;\"><a href=\"#phase-overview\" aria-label=\"phase overview permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Phase Overview</h2>\n<p>각 phase들이 무엇인지 간략하게 살펴보면 다음과 같다:</p>\n<ul>\n<li><code class=\"language-text\">**Timer**</code> : <code class=\"language-text\">setTimeout()</code> 과 <code class=\"language-text\">setInterval()</code> 에 의해 등록된 콜백들을 실행한다.</li>\n<li><code class=\"language-text\">**Pending I/O callbacks**</code> : 이벤트 루프의 이전 iteration에서 실행되지 못한 콜백들을 실행한다.</li>\n<li><code class=\"language-text\">**Idle, prepare**</code> : 이벤트 루프와 직접적인 관련은 없고, Node.js의 내부 관리를 위해 존재한다.</li>\n<li><code class=\"language-text\">**Poll**</code> : 새로운 I/O 이벤트를 받아오고, I/O와 연관된 콜백들을 실행한다. <code class=\"language-text\">close</code> 이벤트에 대한 콜백, 타이머, <code class=\"language-text\">setImmediate()</code> 와 관련된 콜백을 제외한 사실상 대부분의 콜백이 이 phase에서 실행된다. 필요하다면 Node가 이 phase에서 block될 수 있다.</li>\n<li><code class=\"language-text\">**Check**</code> : <code class=\"language-text\">setImmediate()</code> 에 의해 등록된 콜백들을 실행한다.</li>\n<li><code class=\"language-text\">**Close callbacks**</code> : <code class=\"language-text\">close</code> 이벤트에 대한 콜백들이 실행된다. (e.g. <code class=\"language-text\">socket.on('close', cb);</code>)</li>\n</ul>\n<h2 id=\"phase-자세히-살펴보기\" style=\"position:relative;\"><a href=\"#phase-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"phase 자세히 살펴보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Phase 자세히 살펴보기</h2>\n<ul>\n<li>우선, 이벤트 루프가 구현된 코드는 다음과 같다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// UNIX 버전 기준. Windows 버전도 전체적인 구조는 동일하다.</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L369</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/master/deps/uv/src/win/core.c#L596</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">uv_run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">,</span> uv_run_mode mode<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> timeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> r<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">int</span> ran_pending<span class=\"token punctuation\">;</span>\n\n  r <span class=\"token operator\">=</span> <span class=\"token function\">uv__loop_alive</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>r<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">uv__update_time</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>r <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> loop<span class=\"token operator\">-></span>stop_flag <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">uv__update_time</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uv__run_timers</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ran_pending <span class=\"token operator\">=</span> <span class=\"token function\">uv__run_pending</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uv__run_idle</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uv__run_prepare</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    timeout <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>mode <span class=\"token operator\">==</span> UV_RUN_ONCE <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>ran_pending<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span> mode <span class=\"token operator\">==</span> UV_RUN_DEFAULT<span class=\"token punctuation\">)</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token function\">uv_backend_timeout</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">uv__io_poll</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">,</span> timeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/* Run one final update on the provider_idle_time in case uv__io_poll\n     * returned because the timeout expired, but no events were received. This\n     * call will be ignored if the provider_entry_time was either never set (if\n     * the timeout == 0) or was already updated b/c an event was received.\n     */</span>\n    <span class=\"token function\">uv__metrics_update_idle_time</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">uv__run_check</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uv__run_closing_handles</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mode <span class=\"token operator\">==</span> UV_RUN_ONCE<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">/* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */</span>\n      <span class=\"token function\">uv__update_time</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">uv__run_timers</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    r <span class=\"token operator\">=</span> <span class=\"token function\">uv__loop_alive</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mode <span class=\"token operator\">==</span> UV_RUN_ONCE <span class=\"token operator\">||</span> mode <span class=\"token operator\">==</span> UV_RUN_NOWAIT<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loop<span class=\"token operator\">-></span>stop_flag <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    loop<span class=\"token operator\">-></span>stop_flag <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> r<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<ul>\n<li>\n<p>각 메소드 들을 하나씩 순서대로 살펴보면 다음과 같다. phase와 관련된 메소드의 코드는 각각의 phase에 대해 알아볼 때 살펴보자.</p>\n<ol>\n<li><code class=\"language-text\">**uv__loop_alive()**</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// UNIX 버전</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L357</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">uv__loop_alive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">uv__has_active_handles</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n         <span class=\"token function\">uv__has_active_reqs</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n         loop<span class=\"token operator\">-></span>closing_handles <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// Windows 버전</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/core.c#L584</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">uv__loop_alive</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">uv__has_active_handles</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n         <span class=\"token function\">uv__has_active_reqs</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">||</span>\n         loop<span class=\"token operator\">-></span>endgame_handles <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p> 다음 세 조건 중 하나라도 만족하면 <code class=\"language-text\">true</code> 를, 모두 만족하지 못하면 <code class=\"language-text\">false</code> 를 반환한다.</p>\n<ul>\n<li>현재 active한 핸들러(콜백)가 있는가?</li>\n<li>현재 active한 요청(operation)이 있는가?</li>\n<li>closing 핸들러 (close 이벤트 핸들러)가 있는가?</li>\n<li>이벤트 루프의 iteration마다 <code class=\"language-text\">uv__loop_alive()</code> 를 호출하여 리턴값이 <code class=\"language-text\">true</code> 일 경우에만 계속해서 이벤트 루프를 돌린다.</li>\n</ul>\n<br/>\n<ol start=\"2\">\n<li><code class=\"language-text\">**uv_update_time()**</code></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">uv_update_time</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">uint64_t</span> new_time <span class=\"token operator\">=</span> <span class=\"token function\">uv__hrtime</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">assert</span><span class=\"token punctuation\">(</span>new_time <span class=\"token operator\">>=</span> loop<span class=\"token operator\">-></span>time<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  loop<span class=\"token operator\">-></span>time <span class=\"token operator\">=</span> new_time<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">uint64_t</span> <span class=\"token function\">uv__hrtime</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_clocktype_t</span> type<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">timespec</span> ts<span class=\"token punctuation\">;</span>\n  <span class=\"token function\">clock_gettime</span><span class=\"token punctuation\">(</span>CLOCK_MONOTONIC<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>ts<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uint64_t</span><span class=\"token punctuation\">)</span> ts<span class=\"token punctuation\">.</span>tv_sec<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> NANOSEC <span class=\"token operator\">+</span> ts<span class=\"token punctuation\">.</span>tv_nsec<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>내부적으로 시스템 콜을 호출하여 현재 루프의 시간을 (ms의 정확도로) 업데이트 한다.</li>\n</ul>\n<br/>\n<ol start=\"3\">\n<li><code class=\"language-text\">**uv__run_timers()**</code> : Timer phase</li>\n<li><code class=\"language-text\">**uv__run_pending()**</code> : Pending I/O phase</li>\n<li><code class=\"language-text\">**uv__run_idle() &amp; uv__run_prepare()**</code> : idle &#x26; prepare phase</li>\n<li><code class=\"language-text\">**uv__io_poll()**</code> : poll phase</li>\n<li><code class=\"language-text\">**uv__run_check**</code> : check phase</li>\n<li><code class=\"language-text\">**uv__run_closing_handles()</code>** : close phase</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"timer-phase\" style=\"position:relative;\"><a href=\"#timer-phase\" aria-label=\"timer phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Timer phase</h3>\n<p>이벤트 루프가 <code class=\"language-text\">Timer phase</code> 에 진입하면 타이머 큐에 콜백들이 있는지를 살펴보고, 있으면 해당 콜백들을 실행한다. 사실, 편의상 타이머 “큐”라고 했지만 타이머 phase의 큐는 “queue” 자료구조가 아니라 “min-heap” 자료구조이다. 힙에는 타이머들이 각각의 타이머가 만료되는 시간을 기준으로 저장되며, 이벤트 루프가 이 힙에 있는 타이머를 하나씩 살펴보면서 실행한다.</p>\n<p>코드를 통해 조금 더 자세히 말하자면 다음과 같다. 일단 Timer phase는 내부적으로 <code class=\"language-text\">uv__run_timers()</code> 로 구현되어있다. 앞서 min-heap에 저장한 작업들 중 <code class=\"language-text\">uv__update_time()</code> 을 통해 계산한 현재 (iteration의) 시간과 각각의 타이머가 만료되는 시간을 비교하여 만료된 타이머의 콜백들을 실행한다. 다시말해, 만료되지 않은 타이머(즉, 아직 실행하면 안되고 더 나중에 실행해야하는 콜백의 타이머)를 발견할 때까지 계속해서 타이머를 체크해 나간다. 그러다 만료되지 않은 타이머를 발견하면 즉시 타이머 체크를 종료하고 다음 phase로 넘어간다.</p>\n<p>이 때, Timer phase에는 system-dependent한 limit이 존재하는데, 이로 인해 만약 만료된 타이머들이 남아있다고 하더라도 Timer phase를 수행한 시간이 limit을 넘게 되면 남아있는 만료된 타이머들(의 콜백)을 실행하지 않고 다음 phase로 넘어간다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/timer.c#L163</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">uv__run_timers</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_node</span><span class=\"token operator\">*</span> heap_node<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">uv_timer_t</span><span class=\"token operator\">*</span> handle<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    heap_node <span class=\"token operator\">=</span> <span class=\"token function\">heap_min</span><span class=\"token punctuation\">(</span><span class=\"token function\">timer_heap</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>heap_node <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    handle <span class=\"token operator\">=</span> <span class=\"token function\">container_of</span><span class=\"token punctuation\">(</span>heap_node<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uv_timer_t</span><span class=\"token punctuation\">,</span> heap_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handle<span class=\"token operator\">-></span>timeout <span class=\"token operator\">></span> loop<span class=\"token operator\">-></span>time<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">uv_timer_stop</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">uv_timer_again</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    handle<span class=\"token operator\">-></span><span class=\"token function\">timer_cb</span><span class=\"token punctuation\">(</span>handle<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<br/>\n<blockquote>\n<p>Node.js의 타이머는 “정확히” 명시된 시간 이후에 실행되지 않는다.</p>\n</blockquote>\n<p>다시말해, <code class=\"language-text\">setTimeout()</code> 혹은 <code class=\"language-text\">setInterval()</code> 에 지정해주는 delay(timer)는 콜백이 <strong>정확히</strong> 얼마 뒤에 실행되는지를 나타내는 것이 아니라, 콜백이 <strong>적어도</strong> 해당 delay 이후에 실행된다는 것을 나타낸다. 이는 현재 시간을 계산하고, 현재 시간과 타이머의 시간을 비교하는 작업이 CPU-intensive한 작업이라 다소 시간이 걸리기 때문이며 또한 현재 Node.js의 콜스택 상태 등에 영향을 받기 때문이다.</p>\n<p>예를 들어 <code class=\"language-text\">setTimeout(cb, 100)</code> 에서 delay <code class=\"language-text\">100</code> 이 나타내는 의미는 콜백 <code class=\"language-text\">cb</code> 가 “정확히 100ms 이후에 실행된다”는 것이 아니라, “적어도 100ms 이후에” 혹은 “최소한 100ms 있다가” 실행된다는 의미이다. 따라서 해당 <code class=\"language-text\">setTimeout()</code> 을 실행시킨 후 정확히 100ms 이후에 <code class=\"language-text\">cb</code> 가 실행되는지는 알 수 없다 (정확히 100ms 이후에 실행될 수도 있고, 100ms보다 더 뒤에 실행될 수도 있다).</p>\n<br/>\n<blockquote>\n<p>타이머의 최소값은 1ms이다.</p>\n</blockquote>\n<p>한 가지 흥미로운 사실은, 만약 <code class=\"language-text\">setTimeout(cb, 0);</code> 과 같이 사용한다면 내부적으로 타이머 <code class=\"language-text\">0ms</code> 가 <code class=\"language-text\">1ms</code> 로 변환된다는 것이다.</p>\n<p>그 이유는 크롬에서 위와 같이 동작하기 때문인데, Node.js 에서도 크롬과 동일한 방식으로 동작하게 하기 위해 위와 같이 작동한다. 크롬의 V8 코드를 보면 다음과 같이 짜여있음을 알 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token comment\">// https://chromium.googlesource.com/chromium/blink/+/refs/heads/main/Source/core/frame/DOMTimer.cpp#93</span>\n\n<span class=\"token keyword\">double</span> intervalMilliseconds <span class=\"token operator\">=</span> std<span class=\"token double-colon punctuation\">::</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>oneMillisecond<span class=\"token punctuation\">,</span> interval <span class=\"token operator\">*</span> oneMillisecond<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>즉, 주어진 딜레이 값과 <code class=\"language-text\">1ms</code> 중에 더 큰 값을 타이머로 세팅하는 것을 볼 수 있다. 따라서 사실상 default 타이머는 <code class=\"language-text\">1ms</code> 라고 할 수 있다.</p>\n<h3 id=\"pending-io-phase\" style=\"position:relative;\"><a href=\"#pending-io-phase\" aria-label=\"pending io phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Pending I/O phase</h3>\n<p>타이머 phase 이후, 이벤트 루프는 Pending I/O phase에 진입하여 이전에 처리되지 못하고 연기(pending)된 콜백들을 실행한다. 이러한 콜백들은 <code class=\"language-text\">pending_queue</code> 에 저장되어 있다.</p>\n<p>이렇게 “연기”된 콜백들이 존재하는 이유는, 이벤트 루프가 각 phase를 실행할 때 해당 phase의 큐에 있는 모든 작업을 처리하는 것이 아니라 (limit 등에 의해) 일정량의 작업만 처리하고 다음으로 넘어가기 때문이다. 만약 모든 작업을 처리하게 된다면 이벤트 루프가 특정 phase에서 block될 수 있을 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L806</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/req-inl.h#L141</span>\n<span class=\"token comment\">// UNIX 버전</span>\n<span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">uv__run_pending</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  QUEUE<span class=\"token operator\">*</span> q<span class=\"token punctuation\">;</span>\n  QUEUE pq<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">uv__io_t</span><span class=\"token operator\">*</span> w<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-></span>pending_queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">QUEUE_MOVE</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-></span>pending_queue<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>pq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    q <span class=\"token operator\">=</span> <span class=\"token function\">QUEUE_HEAD</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>pq<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">QUEUE_REMOVE</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">QUEUE_INIT</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    w <span class=\"token operator\">=</span> <span class=\"token function\">QUEUE_DATA</span><span class=\"token punctuation\">(</span>q<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uv__io_t</span><span class=\"token punctuation\">,</span> pending_queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    w<span class=\"token operator\">-></span><span class=\"token function\">cb</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">,</span> w<span class=\"token punctuation\">,</span> POLLOUT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Pending I/O phase의 메소드는 <code class=\"language-text\">pending_queue</code> 가 비어있으면 0을 리턴하고 종료한다. 만약 <code class=\"language-text\">pending_queue</code> 에 콜백들이 있으면 해당 콜백들을 실행하고 1을 리턴한다.</p>\n<h3 id=\"idle-prepare-phase\" style=\"position:relative;\"><a href=\"#idle-prepare-phase\" aria-label=\"idle prepare phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Idle, Prepare phase</h3>\n<p>사실 이름을 잘못 지었다(?). 이름은 <code class=\"language-text\">Idle phase</code>이지만 매 tick마다 실행된다. <code class=\"language-text\">Prepare phase</code> 도 마찬가지로 polling을 시작하기 전마다 실행된다.</p>\n<p>어쨌든 종합해보자면, 이 두 phase는 Node.js의 내부 동작을 위해 존재하는 phase이다. 따라서 이 글에서는 다루지 않겠다.</p>\n<br/>\n<p>> 2부에 계속…</p>","frontmatter":{"title":"Node.js의 이벤트 루프 Part1","date":"August 19, 2020","category":"javascript"}}},"pageContext":{"slug":"/javascript/nodejs-event-loop-1/","previous":{"fields":{"slug":"/javascript/limiting-scope-exposure-1/"},"frontmatter":{"title":"자바스크립트 변수 노출 최소화 하기 Part1"}},"next":{"fields":{"slug":"/javascript/hoisting/"},"frontmatter":{"title":"자바스크립트 호이스팅"}}}},"staticQueryHashes":[]}