{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/closure_1/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"a89435ff-b32c-5390-9566-9cfbce3ee2da","excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 2편 보러가기 3편 보러가기 이 글 에서 살펴본 POLE 원칙에 의하면, identifier…","html":"<p>이 글은 아래의 원문을 번역/요약한 글입니다.</p>\n<p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md\">You Don’t Know JS Yet/Chapter 7: Using Closures</a></p>\n<p><a href=\"../closure_2\">2편 보러가기</a></p>\n<p><a href=\"../closure_3\">3편 보러가기</a></p>\n<hr class=\"custom-hr\">\n<p><a href=\"../limiting_scope_exposure_1\">이 글</a> 에서 살펴본 POLE 원칙에 의하면, identifier의 불필요한 노출을 최소화 하기 위해 함수/블록 스코프를 적절히 활용하는 것이 좋다. 이렇게 하면 코드의 가독성이 더 좋아지고 유지보수 또한 더 쉬워질뿐만 아니라 이름 충돌과 같은 여러 문제들도 피할 수 있게 된다.</p>\n<p><strong>클로저</strong>는 이와 같은 방식에 기반을 두고 있다. 즉, 계속해서 사용할 변수들을 바깥의 더 큰 스코프에 놔두기 보다는 더 작은 내부 스코프에 “캡슐화(encapsulate)” 하여 해당 변수를 숨김과 동시에, 내부 함수에서는 계속해서 해당 변수들에 참조할 수 있게 하는 것이다. <strong>함수들은 클로저를 통해 참조하고 있는 바깥 변수들을 “기억”한다.</strong></p>\n<p>위 링크에 있는 글에서도 이미 클로저를 사용한 적이 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">hideTheCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> cache <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> factorial<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ****************</span>\n\n    <span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>x <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 외부 스코프에 존재하는 \"cache\"를 참조하고 있음 -> 클로저!!</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>x <span class=\"token keyword\">in</span> cache<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> cache<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> cache<span class=\"token punctuation\">[</span>x<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아마 여태껏 자바스크립트를 사용해오면서 위와 같은 코드를 본 적이 있거나, 혹은 작성해본 경험이 있을 것이다. 혹시 비동기를 사용하면서 콜백을 사용할 때 콜백 함수에서 외부 스코프에 있는 변수를 참조한 적이 있는가? 그게 바로 클로저이다!</p>\n<p>클로저는 여태껏 프로그래밍 세계에서 발명된 가장 중요한 특성 중 하나이다. 클로저는 함수형 프로그래밍, 모듈 패턴, 심지어는 객체 지향과 같은 주요 패러다임의 발판이다. 따라서 자바스크립트를 완전히 마스터하고, 주요 디자인 패턴들을 사용하기 위해선 반드시 클로저를 이해해야 한다.</p>\n<p>다음 내용으로 넘어가기 전에 반드시 각 개념들을 충분한 시간을 들여 숙지한 다음 넘어가길 바란다.</p>\n<h2 id=\"클로저-살펴보기\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"클로저 살펴보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>클로저 살펴보기</h2>\n<p>클로저는 사실 <a href=\"https://en.wikipedia.org/wiki/Lambda_calculus\">Lambda calculus</a>에서 사용된 개념이다. 하지만 여기선 클로저를 설명하기 위해 수학적 공식이나 기호등을 사용하지는 않을 것이다. 대신 좀 더 실용적인 부분에 초점을 맞출 것이다. 우선, 만약 자바스크립트에 클로저가 없었다면 프로그램이 어떤 방식으로 동작했을지에 대해 살펴보고 추후에 다른 시각으로 클로저를 이리 저리 살펴볼 예정이다.</p>\n<br/>\n<p>클로저는 오로지 함수에 관한 것이다. 함수 이외의 것에는 클로저라는 것이 적용되지 않는다. 일반적인 객체에는 클로저가 없으며, 클래스에도 클로저가 없다 (클래스의 메소드에는 존재할 수 있다!). 다시 말하지만, <strong>오직 함수만이 클로저를 갖는다</strong>.</p>\n<p>클로저를 관찰(observe)하기 위해선 함수를 반드시 원래 함수가 선언된 스코프와 다른 스코프 (a different branch of the scope chain)에서 호출되어야 한다. 함수가 선언된 스코프와 동일한 스코프 내에서 해당 함수를 호출한다면 클로저를 관찰할 수 없게 된다. 관찰적 관점/정의에 의하면 이는 클로저가 아니다.</p>\n<p>다음 예시의 코드를 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">lookupStudent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">studentID</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">var</span> students <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Kyle'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token number\">73</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Suzy'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token number\">112</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Frank'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">{</span> id<span class=\"token operator\">:</span> <span class=\"token number\">6</span><span class=\"token punctuation\">,</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Sarah'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">greetStudent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">greeting</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> student <span class=\"token operator\">=</span> students<span class=\"token punctuation\">.</span><span class=\"token function\">find</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">student</span> <span class=\"token operator\">=></span> student<span class=\"token punctuation\">.</span>id <span class=\"token operator\">===</span> studentID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>greeting<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>student<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">var</span> chosenStudents <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token function\">lookupStudent</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token function\">lookupStudent</span><span class=\"token punctuation\">(</span><span class=\"token number\">112</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// accessing the function's name:</span>\nchosenStudents<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// greetStudent</span>\n\nchosenStudents<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Hello, Sarah!</span>\n\nchosenStudents<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Howdy'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// Howdy, Frank!</span></code></pre></div>\n<br/>\n<p>우선 위 코드에서 주목해야할 점은, <code class=\"language-text\">lookupStudent()</code> 함수 내부에서 <code class=\"language-text\">greetStudent()</code> 함수를 선언하여 리턴하고 있다는 점이다. 그 후 <code class=\"language-text\">lookupStudent()</code> 함수는 두 번 호출되어 각각의 독립적인 <code class=\"language-text\">greetStudent()</code> 함수 인스턴스가 <code class=\"language-text\">chosenStudents</code> 배열에 저장된다. 각 <code class=\"language-text\">greetStudent()</code> 함수의 인스턴스가 배열에 저장된 것인지를 확인하기 위해 <code class=\"language-text\">.name</code> 함수 속성을 이용하여 체킹하고 있음을 알 수 있다.</p>\n<p>이 때 얼핏 보기엔 각 <code class=\"language-text\">lookupStudent()</code> 함수 호출이 끝나면 이 함수의 모든 내부 변수들은 가비지 컬렉터에 의해 사라지고, 리턴되는 <code class=\"language-text\">greetStudent()</code> 함수만 계속해서 보존되는 것 같다. 하지만 이 부분을 유심히 살펴볼 필요가 있다.</p>\n<p><code class=\"language-text\">greetStudent()</code> 함수를 잘 살펴보면, 매개 변수로 <code class=\"language-text\">greeting</code> 이라는 변수를 받을 뿐만 아니라, <code class=\"language-text\">lookupStudent()</code> 함수의 스코프 내에 존재하는 <code class=\"language-text\">students</code> 배열과 <code class=\"language-text\">studentID</code> 변수를 참조하고 있음을 알 수 있다. 이처럼 내부 함수가 <strong>자신이 선언되었을 때의 환경(정확히는 Lexical environment)인 스코프를 “기억”하여 자신이 선언된 스코프 이외의 스코프에서 호출되어도 여전히 자기가 기억하고 있는 스코프를 참조할 수 있도록 하는 것을 클로저</strong>라고 한다.</p>\n<p>이 때 클로저에 의해 참조되는 외부 변수를 <strong>자유 변수(Free variable)</strong>라고 한다. 여기서는 <code class=\"language-text\">students</code>와 <code class=\"language-text\">studentID</code>가 자유 변수이다. 또, 학술적으로 말하자면 각 <code class=\"language-text\">greetStudent()</code> 함수가 자유 변수 <code class=\"language-text\">students</code>, <code class=\"language-text\">studentID</code>를 “에워 싼다(close over)“라고 한다.</p>\n<p>그렇다면 위 코드에서 클로저는 무슨 역할을 하고 있는 걸까?</p>\n<p>클로저는 <code class=\"language-text\">greetStudent()</code> 함수의 외부 스코프가 종료(즉, 외부 함수인 <code class=\"language-text\">lookupStudent()</code>가 리턴되면서 종료되는 것)된 이후에도 <code class=\"language-text\">greetStudent()</code>로 하여금 계속해서 외부 변수(<code class=\"language-text\">students</code>, <code class=\"language-text\">studentID</code>)에 참조할 수 있게 해준다. <code class=\"language-text\">students</code>, <code class=\"language-text\">studentID</code>는 가비지 컬렉트 되지 않고 계속해서 메모리에 존재하며, 추후 <code class=\"language-text\">greetStudent()</code> 함수의 인스턴스가 실행될 때에도 이 두 변수들은 계속해서 값을 지닌채 남아있게 된다.</p>\n<p>만약 자바스크립트에 클로저가 없었다면 <code class=\"language-text\">lookupStudent()</code> 함수가 종료(리턴)되자 마자 이 함수의 스코프가 사라지고 <code class=\"language-text\">students</code>와 <code class=\"language-text\">studentID</code>는 가비지 컬렉트 되어 메모리에서 사라지게 될 것이다. 이 상태에서 나중에 <code class=\"language-text\">greetStudent()</code> 함수 인스턴스 중 하나를 호출하면 어떤 일이 벌어질까?</p>\n<p>클로저라는 것이 없다면, <code class=\"language-text\">greetStudent()</code> 함수 인스턴스에서 <code class=\"language-text\">lookupStudent()</code> 함수의 스코프 영역에 접근하려고 시도하지만 해당 스코프는 더 이상 존재하지 않으므로, 아마 <code class=\"language-text\">students</code>와 <code class=\"language-text\">studentID</code>에 접근하려고 하는 순간 <code class=\"language-text\">ReferenceError</code>가 발생할 것이다.</p>\n<p>하지만 실제로는 어떠한 에러도 발생하지 않는다. <code class=\"language-text\">chosenStudents[0](\"Hello\");</code> 코드가 정상적으로 동작하여 <code class=\"language-text\">'Hello, Sarah!'</code> 라는 결과를 출력한다는 것은 <code class=\"language-text\">lookupStudent()</code> 함수가 종료된 이후에도 <code class=\"language-text\">greetStudent()</code> 함수가 정상적으로 <code class=\"language-text\">students</code>와 <code class=\"language-text\">studentID</code> 변수에 참조할 수 있다는 증거이다. 이 모든것은 결국 클로저가 있기에 가능한 일이다.</p>\n<br/>\n<p>사실, 위에서 우리가 간과한 부분이 하나 있다. 바로 화살표 <code class=\"language-text\">=></code> 함수도 “함수”이기 때문에 자신만의 스코프를 생성한다는 것이다. 즉, 엄밀히 따지고 보면 <code class=\"language-text\">greetStudent()</code> 함수 내부에서 <code class=\"language-text\">students</code> 배열의 <code class=\"language-text\">.find()</code> 메소드의 콜백 함수로 화살표 함수를 넘기고 있고, 이 화살표 함수에서 <code class=\"language-text\">studentID</code>를 참조하므로 실은 <code class=\"language-text\">greetStudent()</code> 함수에서 <code class=\"language-text\">studentID</code>를 “에워싸는” 것이 아니라, 화살표 함수에서 <code class=\"language-text\">studentID</code>를 “에워싼다”.</p>\n<p>사실 여전히 모든 코드가 정상적으로 동작하기 때문에 이와 같은 부분이 그렇게 중요한 것은 아니다. 그래도 화살표 함수 역시 “함수”이기 때문에 클로저를 생성한다는 사실을 간과하지는 말자.</p>\n<h2 id=\"클로저를-이용한-덧셈\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%A7%EC%85%88\" aria-label=\"클로저를 이용한 덧셈 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>클로저를 이용한 덧셈</h2>\n<p>이제 가장 보편적인 클로저 예시 중 하나를 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">addTo</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">num2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> num1 <span class=\"token operator\">+</span> num2<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> add10To <span class=\"token operator\">=</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> add42To <span class=\"token operator\">=</span> <span class=\"token function\">adder</span><span class=\"token punctuation\">(</span><span class=\"token number\">42</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">add10To</span><span class=\"token punctuation\">(</span><span class=\"token number\">15</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 25</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">add42To</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 51</span></code></pre></div>\n<p><code class=\"language-text\">adder()</code> 함수 내부에 있는 <code class=\"language-text\">addTo()</code> 함수의 각각의 인스턴스는 각자의 <code class=\"language-text\">num1</code> 변수(값은 각각 <code class=\"language-text\">10</code>과 <code class=\"language-text\">42</code>)를 “에워싸고” 있기 때문에 <code class=\"language-text\">adder()</code> 함수가 종료된다고 해서 <code class=\"language-text\">num1</code> 변수가 사라지지는 않는다.</p>\n<p>이후에 <code class=\"language-text\">add10To(15);</code> 과 같이 <code class=\"language-text\">addTo()</code> 함수의 인스턴스를 호출하여도 <code class=\"language-text\">addTo()</code> 함수 인스턴스가 에워싸고 있는 <code class=\"language-text\">num1</code> 변수는 그대로 자신의 값(이 경우 <code class=\"language-text\">10</code>)을 유지한다. 따라서 연산 결과는 <code class=\"language-text\">10 + 15 = 25</code>가 되어 정상적으로 <code class=\"language-text\">25</code>를 출력하게 된다.</p>\n<p>위 예시에서 간과하고 넘어가기 쉬운 부분을 다시 한번 짚고 넘어가자. <strong>클로저는 하나의 함수 선언(lexical definition)이 아니라, 함수의 각 인스턴스와 연관된 개념</strong>이다. 위 코드에서 외부 함수 <code class=\"language-text\">adder()</code> 내부에 있는 <code class=\"language-text\">addTo</code> 함수의 선언이 하나만 존재하기 때문에 클로저도 하나만 존재하는 것으로 착각하기 쉽다.</p>\n<p>하지만 실제로 매번 <code class=\"language-text\">adder()</code> 함수가 호출될 때마다 새로운, 독립적인 <code class=\"language-text\">addTo()</code> 함수 인스턴스가 생성되고, 각 함수 인스턴스마다 새로운 클로저가 생성된다. 따라서 내부 함수의 각 인스턴스(예시에서는 <code class=\"language-text\">add10To</code>와 <code class=\"language-text\">add42To</code>로 이름이 붙여짐)는 각자의 독립적인 클로저를 갖는다.</p>\n<h2 id=\"클로저는-스냅샷이-아니다\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%A1%9C%EC%A0%80%EB%8A%94-%EC%8A%A4%EB%83%85%EC%83%B7%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4\" aria-label=\"클로저는 스냅샷이 아니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>클로저는 스냅샷이 아니다</h2>\n<p>앞서 살펴본 두 예제에서 우리는 클로저 안에 들어있는 변수의 “값을 읽어 오기만” 했다. 이를 통해 클로저라는 것이 어떤 특정 순간의 변수의 값을 “캡쳐”하는 것이라고 오해할 수도 있다. 이는 전혀 사실이 아니다.</p>\n<p>클로저는 “값”에 대한 참조를 유지하는 일종의 스냅샷이 아니라, <strong>“변수” 그 자체에 대한 살아있는 링크(live link)를 유지하는 것</strong>이다. 단순히 클로저 내에 있는 변수의 값을 읽는 것 뿐만 아니라, 해당 변수의 값을 변경할 수도 있다! 어떤 함수가 클로저를 통해 변수를 에워 싼다는 것은 해당 함수가 변수를 어디서든 계속해서 “사용”할 수 있다는 소리이다. 이것이 클로저가 여러 프로그래밍 분야에서 널리 사용되는 이유이다. 클로저는 그 만큼 강력한 기능을 제공하기 때문이다.</p>\n<p>다음은 위 예시에 대해 각 함수의 인스턴스와 스코프에 대한 링크를 그림으로 묘사한 것이다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/visualizing_closures.png\" alt=\"Visualizing Closures\">\n    <figcaption>출처: https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch7.md</figcaption>\n</figure>\n<p>위 그림에서 볼 수 있듯, <code class=\"language-text\">adder()</code> 함수를 호출할 때마다 <code class=\"language-text\">num1</code> 변수를 가지는 새로운 파란색 스코프가 생성되고, <code class=\"language-text\">addTo()</code> 함수의 인스턴스(초록색 스코프) 또한 생성된다. 각 함수의 인스턴스(<code class=\"language-text\">addTo10()</code>과 <code class=\"language-text\">addTo42()</code>)가 빨간색 글로벌 스코프 내에 존재하고, 빨간색 스코프 내에서 호출된다는 점도 알아두자.</p>\n<br/>\n<p>이제 클로저에 의해 에워 싸인 변수가 업데이트 되는 예시를 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">makeCounter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getCurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        count <span class=\"token operator\">=</span> count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> hits <span class=\"token operator\">=</span> <span class=\"token function\">makeCounter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\n\n<span class=\"token comment\">// ...</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<p><code class=\"language-text\">count</code> 변수는 내부 함수 <code class=\"language-text\">getCurrent()</code>에 의해 에워 싸이기 때문에 가비지 컬렉트의 대상이 아니다. 그리고 <code class=\"language-text\">hits()</code> 함수를 호출할 때마다 이 함수에서 <code class=\"language-text\">count</code> 변수에 접근하여 값을 1만큼 증가시킨 후 증가된 값을 반환한다.</p>\n<p>클로저를 생성하기 위해 일반적으로 함수(스코프)를 이용하여 내부 함수를 감싸는 경우가 많은데, 굳이 함수(스코프)를 사용할 필요는 없다. 단지 외부의 “스코프”가 내부 함수를 감싸기만 하면 된다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> hits<span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">{</span> <span class=\"token comment\">// 블록 스코프 이용</span>\n    <span class=\"token keyword\">let</span> count <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function-variable function\">hits</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">getCurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        count <span class=\"token operator\">=</span> count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> count<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 2</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">hits</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3</span></code></pre></div>\n<br/>\n<p>대부분의 (초보) 개발자들이 클로저를 <strong>변수 중심</strong>이 아니라 값 중심으로 생각하는 경향이 있기 때문에 다음과 같이 클로저를 이용하여 변수의 값을 “캡쳐”하려고 하는 실수를 종종 저지르곤 한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">greeting</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 클로저라는 것은 'Frank'라는 값(문자열)이 아니라 </span>\n    <span class=\"token comment\">// studentName 변수 그 자체를 에워 싸는것임.</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>studentName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// ...</span>\n\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\n<span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'Hello, Suzy!'</span></code></pre></div>\n<p><code class=\"language-text\">greeting()</code>(a.k.a <code class=\"language-text\">hello()</code>) 이라는 함수를 정의할 때 클로저가 <code class=\"language-text\">studentName</code>이 당시에 가지고 있던 값(<code class=\"language-text\">'Frank'</code>)를 저장할 것이라고 잘못 생각하는 경우가 있다. 하지만 실제로 <code class=\"language-text\">greeting()</code>은 <code class=\"language-text\">'Frank'</code> 라는 “값”이 아니라 <code class=\"language-text\">studentName</code>이라는 “변수”를 저장한다. 따라서 나중에 <code class=\"language-text\">greeting()</code>을 호출할 때, 호출할 당시의 <code class=\"language-text\">studentName</code> 변수의 값이 출력된다.</p>\n<h2 id=\"루프문에서의-클로저\" style=\"position:relative;\"><a href=\"#%EB%A3%A8%ED%94%84%EB%AC%B8%EC%97%90%EC%84%9C%EC%9D%98-%ED%81%B4%EB%A1%9C%EC%A0%80\" aria-label=\"루프문에서의 클로저 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>루프문에서의 클로저</h2>\n<p>위와 같은 실수는 루프문 내부에서 함수를 정의할 때도 발생한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keeps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    keeps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">keepI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// i를 에워쌈 (close over)</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3 -> ???</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3 -> ????</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 3 -> ❓</span></code></pre></div>\n<table>\n<thead>\n<tr>\n<th>참고</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>보통 위와 같은 클로저 예시는 주로 루프문 내부에서 <code class=\"language-text\">setTimeout()</code> 혹은 이벤트 핸들러를 이용하는 경우가 많다. 하지만 나(원문 저자)는 예시를 좀 더 단순화 하기 위해 배열에 함수를 저장하는 방식을 사용했다. 하지만 이렇게 하든 <code class=\"language-text\">setTimeout()</code>등을 사용하든 근본적인 클로저의 원리는 동일하다.</td>\n</tr>\n</tbody>\n</table>\n<p>아마 <code class=\"language-text\">keeps[0]</code>에 저장된 함수(인스턴스)가 생성될 때 <code class=\"language-text\">i</code>의 값이 <code class=\"language-text\">0</code>이었으므로 <code class=\"language-text\">keeps[0]();</code>의 결과가 <code class=\"language-text\">0</code>이 나올거라고 예상했을지도 모르겠다. 하지만 이는 앞서 말했듯이 클로저를 변수 중심이 아니라 값 중심으로 생각했기 때문에 발생한 잘못된 예측이다. <code class=\"language-text\">for</code>문의 구조 때문에 각 iteration 마다 독립적인 (새로운) <code class=\"language-text\">i</code>가 존재한다고 생각했을 수도 있다. 하지만 여기선 <code class=\"language-text\">i</code>가 <code class=\"language-text\">var</code>로 선언되었기 때문에 <code class=\"language-text\">i</code>는 오직 (<code class=\"language-text\">for</code> 블록 스코프가 아니라 글로벌 스코프에) 하나만 존재한다.</p>\n<p>따라서 <code class=\"language-text\">for</code>문을 다 돌고 나서 함수를 실행할 때 <code class=\"language-text\">3</code>이 나오는 이유는 프로그램 내에 오직 하나만 존재하는 <code class=\"language-text\">i</code>의 값이 3이기 때문이다. 물론 <code class=\"language-text\">keeps</code> 배열에 저장된 각각의 <code class=\"language-text\">keepI</code> 함수 인스턴스는 서로 독립적인 클로저를 갖고 있지만, 이 독립적인 클로저들이 모두 같은 <code class=\"language-text\">i</code>를 저장하고(에워싸고) 있다. 그림으로 묘사하면 다음과 같다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_1.png\" alt=\"Using Closure in loop example 1\">\n</figure>\n<p>그럼 위 코드를 우리가 원하는 결과가 나오게끔 하려면 어떻게 해야할 까? 다음과 같이 각 iteration 마다 새로운 변수를 생성하는 방법이 있을 것이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keeps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// i의 값을 복사하는 변수를 매 iteration 마다 생성</span>\n    <span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// `keeps[i]` 에서는 i 변수를 에워싸는 것이 아니므로 이런식으로</span>\n    <span class=\"token comment\">// 작성해도 괜찮음</span>\n    keeps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">keepEachJ</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// i가 아니라 j를 에워쌈</span>\n        <span class=\"token keyword\">return</span> j<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 0</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 2</span></code></pre></div>\n<p>여기선 각각의 내부 함수 인스턴스가 <code class=\"language-text\">i</code>와는 완전 별개인 새로운 변수 <code class=\"language-text\">j</code>를 에워싸고 있기 때문에 우리가 원하는 결과가 정상적으로 출력됨을 알 수 있다.</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_2.png\" alt=\"Using Closure in loop example 2\">\n</figure>\n<p>물론 더 깔끔한 방법이 있다. <a href=\"/javascript/hoisting/#%EB%A3%A8%ED%94%84%EB%AC%B8\">여기</a>서 살펴본 것과 같이 <code class=\"language-text\">let</code>을 사용하면 각 iteration 마다 개별적인 <code class=\"language-text\">i</code>가 생성되므로 위 문제를 더욱 간단하게 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keeps <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 각 iteration 마다 자동적으로 새로운</span>\n    <span class=\"token comment\">// i가 생성됨</span>\n    keeps<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token function\">keepEachI</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> i<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 0</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>keeps<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">// 2</span></code></pre></div>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/closure/closure_in_loop_3.png\" alt=\"Using Closure in loop example 3\">\n</figure>\n<p>> 2편에 계속…</p>","frontmatter":{"title":"자바스크립트 클로저 Part1","date":"August 21, 2020","category":"javascript"}}},"pageContext":{"slug":"/javascript/closure_1/","previous":{"fields":{"slug":"/javascript/limiting_scope_exposure_2/"},"frontmatter":{"title":"자바스크립트 변수 노출 최소화 하기 Part2"}},"next":{"fields":{"slug":"/javascript/closure_3/"},"frontmatter":{"title":"자바스크립트 클로저 Part3"}}}},"staticQueryHashes":[]}