{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/nodejs-event-loop-2/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"bceaa0c3-9053-5c12-88a3-588e5e21da5d","excerpt":"1부 보러가기 Poll phase Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase에 진입하면 우선  를 살펴보고, 해당 큐에 파일 읽기 콜백, TCP…","html":"<p><a href=\"../nodejs_event_loop_1/\">1부 보러가기</a></p>\n<hr class=\"custom-hr\">\n<h3 id=\"poll-phase\" style=\"position:relative;\"><a href=\"#poll-phase\" aria-label=\"poll phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Poll phase</h3>\n<p>Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase에 진입하면 우선 <code class=\"language-text\">watcher_queue</code> 를 살펴보고, 해당 큐에 파일 읽기 콜백, TCP 통신 콜백등과 같은 작업들이 존재한다면 해당 작업들을 수행한다.</p>\n<p>이 때 더이상 실행할 콜백이 없는 상태에 이르게 되면 <code class=\"language-text\">pending_queue</code>, <code class=\"language-text\">check_queue</code> (<code class=\"language-text\">setImmediate</code> 의 콜백들이 저장됨), <code class=\"language-text\">closing_callbacks_queue</code> (<code class=\"language-text\">close</code> 이벤트 콜백들이 저장됨)에 저장된 작업들이 있는지 살펴본다. 만약 해야 할 작업이 있다면 즉시 Poll phase를 종료하고 다음 phase로 넘어간다. 만약 해야 할 작업이 없다면 Poll phase에서 일정 시간동안 대기한다.</p>\n<p>그럼 과연 얼마나 대기하는지를 코드를 통해 살펴보자. 우선 Poll phase의 메소드인 <code class=\"language-text\">uv__poll</code> (UNIX는 <code class=\"language-text\">uv__io_poll</code>) 의 인자 목록을 살펴보면 다음과 같다 (메소드 전체는 너무 길기때문에 생략한다).</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">void</span> <span class=\"token function\">uv__io_poll</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> timeout<span class=\"token punctuation\">)</span></code></pre></div>\n<p>첫 번째 인자로 이벤트 루프를, 두 번째 인자로 “대기 시간”을 받는 것을 알 수 있다. 이렇게 Poll phase는 인자로 얼마만큼의 시간동안 대기할 것인가를 받아서 해당 시간만큼 대기한다.</p>\n<p>만약 <code class=\"language-text\">timeout</code> 값이 0이면 polling을 건너뛰고 바로 다음 phase인 Check phase로 넘어간다. <code class=\"language-text\">timeout</code> 값은 다음 과정을 통해 계산된다:</p>\n<ul>\n<li>만약 이벤트 루프가 현재 <code class=\"language-text\">UV_RUN_DEFAULT</code> 모드로 동작한다면 <code class=\"language-text\">timeout</code> 은 <code class=\"language-text\">uv_backend_timeout</code> 메소드를 통해 계산된다.</li>\n<li>만약 이벤트 루프가 현재 <code class=\"language-text\">UV_RUN_ONCE</code> 모드로 동작하고 <code class=\"language-text\">uv_run_pending</code> 의 리턴값이 0 (즉, <code class=\"language-text\">pending_queue</code> 가 비어있는 경우) 이면 <code class=\"language-text\">timeout</code> 은 <code class=\"language-text\">uv_backend_timeout</code> 메소드를 통해 계산된다.</li>\n<li>이외의 경우, <code class=\"language-text\">timeout</code> 은 0이다.</li>\n</ul>\n<p>이벤트 루프의 모드에 관한 자세한 내용은 <a href=\"http://docs.libuv.org/en/v1.x/loop.html#c.uv_run\" target=\"_blank\" rel=\"noreferrer noopener\">http://docs.libuv.org/en/v1.x/loop.html#c.uv_run</a> 를 참고하길 바란다.</p>\n<br/>\n<p><code class=\"language-text\">uv_backend_timeout</code> 메소드의 코드를 살펴보면 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/nodejs/node/blob/c61870c376e2f5b0dbaa939972c46745e21cdbdd/deps/uv/src/unix/core.c#L337</span>\n<span class=\"token comment\">// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/win/core.c#L398</span>\n<span class=\"token comment\">// UNIX 버전</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">uv_backend_timeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loop<span class=\"token operator\">-></span>stop_flag <span class=\"token operator\">!=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">uv__has_active_handles</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">uv__has_active_reqs</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-></span>idle_handles<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token function\">QUEUE_EMPTY</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>loop<span class=\"token operator\">-></span>pending_queue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loop<span class=\"token operator\">-></span>closing_handles<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">uv__next_timeout</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서 볼 수 있듯, 다음 중 하나에 해당되는 경우 <code class=\"language-text\">timeout</code> 은 0이다.</p>\n<ul>\n<li>루프의 <code class=\"language-text\">stop_flag</code> 가 0이 아닌경우 (즉, 루프를 종료해야 하는 경우).</li>\n<li>현재 active한 핸들러(콜백)가 없고, 현재 active한 요청(operation)이 없는 경우.</li>\n<li>실행되기를 기다리는 idle한 핸들러가 있는 경우.</li>\n<li><code class=\"language-text\">pending_queue</code> 에서 대기 중인(pending) I/O 콜백이 있는 경우 (즉, 이미 대기 중인 I/O 동작이 있으므로 새로운 I/O 동작을 기다릴 필요가 없음).</li>\n<li><code class=\"language-text\">close</code> 이벤트 핸들러가 있는 경우.</li>\n</ul>\n<p>위 다섯개의 상황을 제외한 나머지 경우, <code class=\"language-text\">uv__next_timeout</code> 을 호출하여 <code class=\"language-text\">timeout</code> 을 계산한다. 코드는 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"c\"><pre class=\"language-c\"><code class=\"language-c\"><span class=\"token comment\">// https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/deps/uv/src/timer.c#L142</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">uv__next_timeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">uv_loop_t</span><span class=\"token operator\">*</span> loop<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">struct</span> <span class=\"token class-name\">heap_node</span><span class=\"token operator\">*</span> heap_node<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> <span class=\"token class-name\">uv_timer_t</span><span class=\"token operator\">*</span> handle<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">uint64_t</span> diff<span class=\"token punctuation\">;</span>\n\n  heap_node <span class=\"token operator\">=</span> <span class=\"token function\">heap_min</span><span class=\"token punctuation\">(</span><span class=\"token function\">timer_heap</span><span class=\"token punctuation\">(</span>loop<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>heap_node <span class=\"token operator\">==</span> <span class=\"token constant\">NULL</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/* block indefinitely */</span>\n\n  handle <span class=\"token operator\">=</span> <span class=\"token function\">container_of</span><span class=\"token punctuation\">(</span>heap_node<span class=\"token punctuation\">,</span> <span class=\"token class-name\">uv_timer_t</span><span class=\"token punctuation\">,</span> heap_node<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>handle<span class=\"token operator\">-></span>timeout <span class=\"token operator\">&lt;=</span> loop<span class=\"token operator\">-></span>time<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n  diff <span class=\"token operator\">=</span> handle<span class=\"token operator\">-></span>timeout <span class=\"token operator\">-</span> loop<span class=\"token operator\">-></span>time<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>diff <span class=\"token operator\">></span> INT_MAX<span class=\"token punctuation\">)</span>\n    diff <span class=\"token operator\">=</span> INT_MAX<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span><span class=\"token punctuation\">)</span> diff<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">uv__next_timeout</code> 은 현재 시간(iteration을 시작할 때 계산한 시간)을 기준으로 가장 가까운 타이머와의 차이를 반환한다. 즉, 이 경우 이벤트 루프가 Poll phase에서 가장 빨리 만료되는 타이머를 실행할 수 있는 시간이 될때까지만 기다리다가 다음 phase로 넘어간다.</p>\n<p>이 때 만약 타이머가 없다면 <code class=\"language-text\">-1</code> 을 리턴하는데, 이로인해 이벤트 루프가 Poll phase에서 무한히 기다리게 된다.</p>\n<br/>\n<ul>\n<li>\n<p>종합해보자면, 이벤트 루프는 Poll phase에서</p>\n<ol>\n<li>Check phase 혹은 Close phase에 실행할 콜백이 있으면 Poll phase에서 기다리지 않는다.</li>\n<li>만약 Check phase 와 Close phase에 실행할 콜백이 없으면 타이머를 살펴보고, 타이머가 있으면 해당 타이머를 실행할 수 있을 때까지 Poll phase에서 기다렸다가 다음 phase로 넘어간다.</li>\n<li>만약 타이머도 없으면 일이 생길때 까지 Poll phase에서 대기한다.</li>\n</ol>\n</li>\n</ul>\n<p>I/O 폴링이 수행되는 방식은 OS별로 차이가 있다. Windows의 경우, IOCP(Input Output Completion Port)의 <code class=\"language-text\">GetQueuedCompletionStatus</code> 를 이용하고, Linux의 경우 <code class=\"language-text\">epoll_wait</code> 을, macOS의 경우 <code class=\"language-text\">kqueue</code> 를 이용한다.</p>\n<h3 id=\"check-phase\" style=\"position:relative;\"><a href=\"#check-phase\" aria-label=\"check phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Check phase</h3>\n<p>Check phase의 동작 방식은 Timer phase와 비슷하다고 할 수 있다. 하지만 타이머 콜백(<code class=\"language-text\">setTimeout()</code>, <code class=\"language-text\">setInterval()</code>) 들이 언제 실행되는지 보장되지 않는 반면, <code class=\"language-text\">setImmediate</code> 의 콜백들은 I/O phase 바로 다음에 처리되는 것이 보장된다.</p>\n<br/>\n<blockquote>\n<p>setTimeout vs. setImmediate</p>\n</blockquote>\n<p>이 글의 첫 부분에서 봤던 이벤트 루프의 흐름에서 볼 수 있듯이, 루프의 iteration이 시작되고 우선 Timer phase에 진입하여 타이머 관련 콜백들을 처리하고, 그 다음에 I/O phase 를 거쳐 Check phase에 진입하므로 다음 코드의 결과를 쉽게 예측할 수 있을 것이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setImmediate'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>언뜻 보기엔 <code class=\"language-text\">setTimeout</code> 이 먼저 실행되고 그 다음 <code class=\"language-text\">setImmediate</code> 가 실행되는 것처럼 보인다. 하지만 위 코드의 결과는 <strong>예측할 수 없다!</strong> 😱 위 코드를 여러번 실행해보면 서로 다른 결과가 나오는것을 확인할 수 있다.</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_1.png\" alt=\"setTimeout vs. setImmediate\">\n    <figcaption>setTimeout vs. setImmediate</figcaption>\n</figure>\n<p>이러한 결과가 나오는 이유는, Timer phase에서 살펴본 것과 같이 <code class=\"language-text\">setTimeout</code> 의 default 딜레이 값은 0이 아니라 1이기 때문이다. 즉, 만약 0보다 작은 값을 딜레이로 주게 되면 Node.js가 자동적으로 딜레이를 1로 변경해버린다.</p>\n<p>따라서, 이벤트 루프가 현재 시간을 계산할 때, CPU가 얼마나 바쁜지에 따라 시간을 계산하는데 걸리는 시간이 <code class=\"language-text\">1ms</code> 를 초과할 수도, 그렇지 않을 수도 있다. 만약 <code class=\"language-text\">1ms</code> 보다 빠르게 시간을 계산했다면 <code class=\"language-text\">setImmediate</code> 가 먼저 실행될 것이고, 시간을 계산하는데 <code class=\"language-text\">1ms</code> 보다 더 걸렸다면 <code class=\"language-text\">setTimeout</code> 이 실행될 것이다.</p>\n<p>하지만 다음과 같은 상황에서는 <strong>무조건</strong> <code class=\"language-text\">setImmediate</code> 의 콜백이 <code class=\"language-text\">setTimeout</code> 콜백보다 먼저 실행된다고 할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span>__dirname<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setImmediate'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>그 이유는 우선, 프로그램이 시작되면 <code class=\"language-text\">fs.readFile()</code> 을 이용하여 파일을 비동기적으로 읽는다. 파일 읽기가 완료되면 <code class=\"language-text\">pending_queue</code> 에 콜백이 저장되어 추후에 실행되는데, 이 때 <code class=\"language-text\">setTimeout</code> 과 <code class=\"language-text\">setImmediate</code> 이 순차적으로 실행되고, 각각의 콜백이 Timer phase의 큐와 Check phase의 큐에 저장된다.</p>\n<ul>\n<li>I/O phase 를 지나 Poll phase에 진입했을 때, immediate 콜백과 타이머 콜백이 있으므로 곧장 Check phase로 가서 <code class=\"language-text\">setImmediate</code> 의 콜백을 실행한다. → “setImmediate” 출력.</li>\n<li>그 다음 루프 iteration에서 Timer phase에 진입하여 만료된 타이머의 콜백을 실행한다 → “setTimeout” 출력.</li>\n</ul>\n<h3 id=\"close-phase\" style=\"position:relative;\"><a href=\"#close-phase\" aria-label=\"close phase permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Close phase</h3>\n<p><code class=\"language-text\">'close'</code> 이벤트, 혹은 <code class=\"language-text\">socket.destroy()</code> 와 같은 <code class=\"language-text\">destroy</code> 타입에 대한 콜백들을 실행한다. 이벤트 루프가 Close phase를 마치고 나면 <code class=\"language-text\">uv__loop_alive</code> 를 이용하여 iteration을 더 돌아야 하는지 판단한다.</p>\n<h2 id=\"nexttickqueue--microtaskqueue\" style=\"position:relative;\"><a href=\"#nexttickqueue--microtaskqueue\" aria-label=\"nexttickqueue  microtaskqueue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>nextTickQueue &#x26; microTaskQueue</h2>\n<p><code class=\"language-text\">process.nextTick()</code> 의 콜백들이 저장되는 <code class=\"language-text\">nextTickQueue</code> 와, <code class=\"language-text\">Promise</code> 등의 콜백이 저장되는 <code class=\"language-text\">microTaskQueue</code> 는 사실 이벤트 루프의 일부가 아니다.</p>\n<p>Node.js v11.0.0 이전에는 각 tick마다, 즉 어떤 phase에서 다음 phase로 넘어갈 때 (→ “C++/JavaScript 경계를 넘을 때” 라고 하기도 한다) 해당 큐에 저장된 모든 콜백들을 처리하는 방식으로 동작했다. 이 때 <code class=\"language-text\">nextTickQueue</code> 가 <code class=\"language-text\">microTaskQueue</code> 보다 높은 우선순위를 갖는다.</p>\n<p>하지만 Node.js v11.0.0 부터는 동작 방식이 약간 바뀌었는데, 기존 방식처럼 각 tick마다 두 개의 큐를 실행하는 것을 바탕으로 각 타이머 콜백(<code class=\"language-text\">setImmediate</code> &#x26; <code class=\"language-text\">setInterval</code>) 과 immediate 콜백 사이에 <code class=\"language-text\">nextTick</code> 콜백와 <code class=\"language-text\">microTask</code> 콜백이 실행된다. 다음 코드를 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout2'</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise resolve'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'timeout4'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Node.js v11.0.0 이후 버전에서 실행한 결과는 다음과 같다:</li>\n</ul>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nextTickQueue_1.png\" alt=\"code result after v11.0.0\">\n</figure>\n<ul>\n<li>Node.js v11.0.0 이전 버전에서 실행한 결과는 다음과 같다:</li>\n</ul>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/nextTickQueue_2.png\" alt=\"code result before v11.0.0 \">\n</figure>\n<p>위 결과에서 볼 수 있듯, v11.0.0 이전에는 매 tick마다 <code class=\"language-text\">nextTick</code> 콜백과 <code class=\"language-text\">microTask</code> 콜백들이 실행됐으나, v11.0.0 이후에는 타이머 콜백, (위 코드에는 없지만) immediate 콜백 마다 <code class=\"language-text\">nextTick</code> 콜백과 <code class=\"language-text\">microTask</code> 콜백을 실행함을 알 수 있다.</p>\n<p>이렇게 동작이 변경된 이유는, 크롬 브라우저와의 호환성 때문인데, 브라우저에서는 v11.0.0 이후 버전에서와 같이 동작하기 때문이다.</p>\n<p>물론 <code class=\"language-text\">setImmediate</code> 에 대해 실험해 봐도 위와 동일한 로직으로 동작함을 알 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate1'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate2'</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise resolve'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate3'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'immediate4'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Node.js v11.0.0 이후 버전:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_2.png\" alt=\"code result after v11.0.0\">\n</figure>\n<p>Node.js v11.0.0 이전 버전:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/nodejs_event_loop/setImmediate_3.png\" alt=\"code result before v11.0.0 \">\n</figure>\n<h2 id=\"references\" style=\"position:relative;\"><a href=\"#references\" aria-label=\"references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>REFERENCES</h2>\n<p><a href=\"http://docs.libuv.org/en/v1.x/guide/basics.html#event-loops\" target=\"_blank\" rel=\"noreferrer noopener\">Basics of libuv - libuv documentation</a></p>\n<p><a href=\"http://docs.libuv.org/en/v1.x/design.html#the-i-o-loop\" target=\"_blank\" rel=\"noreferrer noopener\">Design overview - libuv documentation</a></p>\n<p><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/\" target=\"_blank\" rel=\"noreferrer noopener\">The Node.js Event Loop, Timers, and process.nextTick()</a></p>\n<p><a href=\"https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810\" target=\"_blank\" rel=\"noreferrer noopener\">Event Loop and the Big Picture Series</a></p>\n<p><a href=\"https://www.voidcanvas.com/nodejs-event-loop/\" target=\"_blank\" rel=\"noreferrer noopener\">Node.js event loop workflow &#x26; lifecycle in low level</a></p>","frontmatter":{"title":"Node.js의 이벤트 루프 Part2","date":"August 19, 2020","category":"JavaScript"}}},"pageContext":{"slug":"/javascript/nodejs-event-loop-2/","previous":null,"next":{"fields":{"slug":"/javascript/limiting-scope-exposure-1/"},"frontmatter":{"title":"자바스크립트 변수 노출 최소화 하기 Part1"}}}},"staticQueryHashes":[]}