{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/hoisting/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"911d3537-6c19-544a-8543-d395d09a5944","excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables…","html":"<p>이 글은 아래의 원문을 번역/요약한 글입니다.</p>\n<p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch5.md\">You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables</a></p>\n<hr class=\"custom-hr\">\n<h2 id=\"언제-변수를-사용할-수-있을까\" style=\"position:relative;\"><a href=\"#%EC%96%B8%EC%A0%9C-%EB%B3%80%EC%88%98%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"언제 변수를 사용할 수 있을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>언제 변수를 사용할 수 있을까?</h2>\n<p>스코프 내에 있는 변수는 어느순간 부터 사용 가능한 걸까? 변수가 선언(생성)된 시점부터 사용할 수 있지 않을까?? 꼭 그렇지만은 않다. 다음 코드를 생각해보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello!</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hello!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>아마 이런식의 코드를 작성해본 경험이 있을 것이다. 이 코드는 아주 잘 작동한다 하지만 이런방식의 코드가 어떻게, 혹은 왜 동작하는지 생각해본적이 있는가? 위 코드에서, 함수 <code class=\"language-text\">greeting()</code> 은 분명 3번째 줄에 선언되었는데 어째서 1번째 줄에서 해당 함수를 호출할 수 있는걸까?</p>\n<p>자바스크립트 코드가 컴파일되는 과정에서 모든 identifier들은 각자가 속한 스코프에 “등록”된다 (사실 자바스크립트는 인터프리터 언어라기 보다 컴파일 언어에 더 가깝다!). 특히, 어떤 스코프에 진입(enter)했을 때 해당 스코프의 모든 identifier들이 스코프의 시작 부분에 “생성”된다. </p>\n<p>이렇게 변수들이 스코프 (한참) 아래에 선언되어 있음에도 불구하고 해당 스코프에 진입하자 마자 스코프의 모든 변수들에 접근할 수 있게 되는 현상을 <strong>호이스팅(hoisting)</strong> 이라고 한다.</p>\n<br/>\n<p>하지만 호이스팅만으로는 위 질문에 대한 답을 할 수 없다. 스코프 시작 부분에서 <code class=\"language-text\">greeting</code> 이라는 identifier를 “볼 수 있지만”, 어떻게 함수를 “호출”까지 할 수 있게 되는걸까? 다시말해, 어떻게 스코프가 시작할 때 <code class=\"language-text\">greeting</code> 이라는 identifier가 값(여기서는 함수 레퍼런스)을 가질 수 있게 되는 것일까?</p>\n<p>이 질문에 대답은 <strong>함수 호이스팅(function hoisting)</strong>으로 설명할 수 있다. 즉, <code class=\"language-text\">function</code> 키워드로 선언된 (“함수를 formal하게 선언한다” 라고함) 함수의 identifier가 자동적으로 스코프의 상단에 등록될 때, 이 identifier는 자동적으로 자신의 함수 레퍼런스로 초기화된다. 이렇게 자동적으로 자신의 함수 레퍼런스로 초기화 됨으로 인해 (<code class=\"language-text\">function</code> 키워드로 선언된) 함수를 스코프 내의 어디에서나 호출할 수 있는 것이다.</p>\n<p>참고로, 함수 호이스팅과 <code class=\"language-text\">var</code> 변수의 호이스팅은 함수 스코프 단위로 일어나고, <code class=\"language-text\">let</code> 과 <code class=\"language-text\">const</code> 변수의 호이스팅은 블록 스코프 단위로 일어난다.</p>\n<h2 id=\"함수-호이스팅-함수-선언문-vs-함수-표현식\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8%EB%AC%B8-vs-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9D\" aria-label=\"함수 호이스팅 함수 선언문 vs 함수 표현식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 호이스팅: 함수 선언문 vs. 함수 표현식</h2>\n<p>위에서 살펴봤듯이, 함수 호이스팅은 오직 “함수 선언”(<code class=\"language-text\">function</code> 키워드를 이용한 함수 선언)에만 적용된다. 함수 표현식(function expression)에는 적용되지 않는다. 다음 코드를 보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// TypeError: greeting is not a function</span>\n\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">greeting</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hi'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 <code class=\"language-text\">TypeError</code> 가 발생했다는 점에 주목해보자. <code class=\"language-text\">TypeError</code> 는 어떤 값에 대해 허용되지 않는 동작을 수행했다는 의미이다. 자바스크립트 실행 환경에 따라 <code class=\"language-text\">'undefined' is not a function</code> 과 같은 메시지가 나올 수도 있다.</p>\n<p>중요한 것은 에러의 종류가 <code class=\"language-text\">ReferenceError</code> 가 아니라 <code class=\"language-text\">TypeError</code> 라는 점이다. 즉, 스코프 내에서 <code class=\"language-text\">greeting</code> 이라는 identifier를 못찾았다는 것이 아니라, <code class=\"language-text\">greeting</code> 이라는 identifier는 찾았지만 해당 순간에 함수를 가리키고(reference) 있지 않았다는 뜻이다. 함수가 아닌 것에다 함수 호출을 했으니 <code class=\"language-text\">TypeError</code> 가 발생한 것이다.</p>\n<p>그렇다면 그 순간에 <code class=\"language-text\">greeting</code> 은 어떤 값을 저장하고 있었을까? <code class=\"language-text\">var</code> 변수의 경우, 호이스팅 될 때 자동적으로 <code class=\"language-text\">undefined</code> 로 초기화된다. 그러다 자신이 원래 선언된 위치로 오게 되면 비로소 원래의 값으로 할당되는 것이다. 위 코드의 경우, 3번째 줄이 되어서야 <code class=\"language-text\">greeting</code> 변수가 함수를 가리키게 된다.</p>\n<br>\n<p>종합해보면 이렇다. 함수 선언(function declaration)은 스코프 맨 위로 hoist 될 때 자동적으로 원래 가리키고 있던 함수로 초기화된다. <code class=\"language-text\">var</code> 변수는 hosit될 때 자동적으로 <code class=\"language-text\">undefined</code> 로 초기화 된다. 함수 표현(function expression)의 경우, 프로그램 실행 때 원래 선언된 위치에서 변수가 함수 표현을 reference 하게 된다.</p>\n<h2 id=\"변수-호이스팅\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98-%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85\" aria-label=\"변수 호이스팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수 호이스팅</h2>\n<p>이번에는 변수 호이스팅에 대해 좀 더 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Hello</span>\n\n<span class=\"token keyword\">var</span> greeting <span class=\"token operator\">=</span> <span class=\"token string\">'Howdy!'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">greeting</code> 변수가 4번째 줄에 선언되었음에도 불구하고 1번째 줄에서 정상적으로 값을 할당하고 있는데, 그 이유는</p>\n<ul>\n<li><code class=\"language-text\">greeting</code> 이라는 identifier가 hoist 되었기 때문이고,</li>\n<li>해당 스코프의 최상단에서 자동적으로 <code class=\"language-text\">undefined</code> 로 할당되었기 때문이다.</li>\n</ul>\n<h3 id=\"비유\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EC%9C%A0\" aria-label=\"비유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비유</h3>\n<p>호이스팅을 설명하는 글에서 주로 사용하는 비유는 “들어올린다”(lift)는 것이다. 즉, 무거운 물건을 들어올리듯이 identifier들을 스코프의 최상단으로 들어올린다는 것이다. 어떤 경우, 자바스크립트 엔진이 다음 코드와 같이 실제로 소스 코드를 변경하여 identifier를 재배치 한다고 하는 글도 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> greeting<span class=\"token punctuation\">;</span>\ngreeting <span class=\"token operator\">=</span> <span class=\"token string\">'Hello'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>greeting<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Hello</span>\ngreeting <span class=\"token operator\">=</span> <span class=\"token string\">'Howdy'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한, 함수 호이스팅의 경우 프로그램 실행 전에 엔진이 함수 선언부 전체를 hoist 한다고 주장하는 경우도 있다. 거기다 함수 선언문이 먼저 호이스팅 되고 그 다음에 변수가 호이스팅 된다고 주장한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 호이스팅 전</span>\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Hi, Suzy!</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hi, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>studentName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 호이스팅 후</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hi, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>studentName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span>\n\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">greeting</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Hi, Suzy!</span></code></pre></div>\n<p>이러한 비유는 호이스팅을 비교적 쉽게 설명할 수 있다는 장점이 있지만, 사실 이는 정확한 표현이 아니다. <strong>자바스크립트는 코드를 재배열하지 않는다!</strong> 단지 코드를 실행하기 전에 코드를 분석(parse) 해서 스코프 내의 identifier를 찾아놓을 뿐이다.</p>\n<p>즉, 호이스팅 이라는 것은 runtime과 관련된 것이 아니라 compile-time과 관련된 작업이다. 프로그램 실행(runtime)때 엔진이 코드를 바꿔서 실행하는 것이 아니라, 컴파일(compile-time)때 코드를 분석하여 스코프 내에 있는 identifier들을 찾아 정리해놓는 것이다.</p>\n<h2 id=\"재할당\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%ED%95%A0%EB%8B%B9\" aria-label=\"재할당 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재할당?</h2>\n<p>만약 다음과 같이 어떤 스코프 내에서 동일한 변수가 두 번 이상 선언되면 어떻게 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Frank</span>\n\n<span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ?</span></code></pre></div>\n<p>두 번째 <code class=\"language-text\">var studentName</code> 이 해당 변수를 “재선언(re-declared)” 했으므로 <code class=\"language-text\">undefined</code> 를 출력하는 것이 맞을까? 아니다. 사실 “재선언” 이라는 것은 존재하지 않는다. 앞서 살펴본 호이스팅에 빗대어 살펴보자면 위 코드는 다음과 같다고 할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span> <span class=\"token comment\">// no-op</span>\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Frank</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Frank</span></code></pre></div>\n<p>호이스팅 이라는 것이 실제로는 스코프의 시작 부분에 변수들을 등록하는 것이므로, 위와 같이 두 번째 선언문은 사실상 의미없는 no-op(no-operation) 문장이다.</p>\n<p>또한 한 가지 알아둬야할 것이,  <code class=\"language-text\">var studentName;</code> 문장은 <code class=\"language-text\">var studentName = undefined;</code> 와 동일한 문장이 아니다! 다음 코드를 통해 이와 같은 사실을 알 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Frank</span>\n\n<span class=\"token keyword\">var</span> studentName<span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 여전히 Frank</span>\n\n<span class=\"token keyword\">var</span> studentName <span class=\"token operator\">=</span> <span class=\"token keyword\">undefined</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 명시적으로 undefined로 초기화</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined</span></code></pre></div>\n<p><code class=\"language-text\">let</code> 혹은 <code class=\"language-text\">const</code> 의 경우는 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드를 실행하면 즉시 <code class=\"language-text\">SyntaxError</code> 가 발생하는 것을 볼 수 있다. 그 이유는 <code class=\"language-text\">let</code> (그리고 <code class=\"language-text\">const</code>) 의 경우 재선언이 불가능하기 때문이다.</p>\n<p>물론, 다음과 같은 경우도 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// OR</span>\n<span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><code class=\"language-text\">const</code> 의 경우 규칙이 더 엄격하다. <code class=\"language-text\">let</code> 과 같이 재선언이 불가능함은 물론, <code class=\"language-text\">const</code> 변수는 선언할 때 <strong>무조건</strong> 초기화 해야한다. 그리고 초기화한 후 값을 재할당 하는 것이 불가능하다.</p>\n<p>즉, 다음과 같은 코드는 불가능하다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> myVariable<span class=\"token punctuation\">;</span> <span class=\"token comment\">// SyntaxError -> 무조건 선언과 동시에 초기화 해야함</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Frank</span>\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span> <span class=\"token comment\">// TypeError -> 재할당 불가</span></code></pre></div>\n<p><code class=\"language-text\">const</code> 변수에 재할당을 할 때 발생한 에러가 <code class=\"language-text\">SyntexError</code> 가 아니라 <code class=\"language-text\">TypeError</code> 라는 점에 주목해보자. 이 두 개의 에러간에는 미묘한 차이가 있는데, <code class=\"language-text\">SyntaxError</code> 는 프로그램을 미처 실행하기도 전에 발생한 에러이고, <code class=\"language-text\">TypeError</code> 는 프로그램 실행 도중에 발생한 에러이다. 위 코드에서 보면 재할당 하기전의 <code class=\"language-text\">console.log(studentName);</code> 문장에서 정상적으로 <code class=\"language-text\">Frank</code> 가 출력됨을 알 수 있다. 만약 <code class=\"language-text\">SyntaxError</code> 였다면 프로그램이 실행조차 되지 않아 <code class=\"language-text\">Frank</code> 가 출력되지 못했을 것이다.</p>\n<h2 id=\"루프문\" style=\"position:relative;\"><a href=\"#%EB%A3%A8%ED%94%84%EB%AC%B8\" aria-label=\"루프문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>루프문</h2>\n<p>이제까지 살펴본 바로는, 변수를 “재선언” 하는 것은 바람직하지 않은 것 같다. 그렇다면 루프문에선 어떨까? 다음 코드를 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keepGoing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서 while문 안에 있는 <code class=\"language-text\">value</code> 변수는 계속해서 “재선언” 되는 것일까? 그렇다면 에러가 발생하는 걸까?</p>\n<p>정답은 “재선언 되지 않는다” 이다. 스코프에 관련된 규칙들은 <strong>스코프 인스턴스에 개별적</strong>으로 적용된다. 다시말해, 실행중에 매 순간 스코프에 진입(enter)할 때마다 모든것이 리셋된다.</p>\n<p>루프문의 경우, <strong>각 iteration은 각자의 스코프 인스턴스를 갖는다</strong>. 위 코드의 경우, while문 각각의 iteration은 서로 별개의 “스코프 인스턴스”이고, 각 스코프 인스턴스에서 <code class=\"language-text\">value</code> 변수는 오직 한 번만 선언된다. 따라서 각 스코프 인스턴스 별로 한 번만 선언되므로 재선언이 발생하지 않는 것이고, 그에 따라 어떠한 에러도 발생하지 않는 것이다.</p>\n<br/>\n<p>그렇다면 <code class=\"language-text\">var</code> 의 경우는 어떨까? 위 코드에서 다음과 같이 <code class=\"language-text\">value</code> 가 <code class=\"language-text\">var</code> 로 선언되면 어떤 일이 발생하는 걸까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keepGoing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> value <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">var</code> 변수는 재선언을 허용하므로 여기서는 <code class=\"language-text\">value</code> 변수가 계속해서 재선언 되는 것일까?</p>\n<p>아니다.  <code class=\"language-text\">var</code> 변수는 “함수 스코프”로 취급되므로 위 코드에서 변수 <code class=\"language-text\">value</code> 는 글로벌 스코프에 오직 한 번만 선언되고, 값만 계속해서 재할당 되는 것이다. 위 코드에서 while문 바로 아래에 <code class=\"language-text\">console.log()</code> 를 이용하여 <code class=\"language-text\">value</code> 가 글로벌 스코프로 선언되었음을 확인할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keepGoing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 0.5보다 큰값</span></code></pre></div>\n<p>만약 여기서 <code class=\"language-text\">value</code> 가 <code class=\"language-text\">let</code> 으로 선언되었다면 <code class=\"language-text\">ReferenceError</code> 가 발생할 것이다.</p>\n<br/>\n<p>그렇다면 <code class=\"language-text\">for</code> 루프에서는 어떨까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// 0: 0</span>\n<span class=\"token comment\">// 1: 10</span>\n<span class=\"token comment\">// 2: 20</span></code></pre></div>\n<p>여기서도 마찬가지로, <code class=\"language-text\">for</code> 루프의 각 iteration 마다 별개의 스코프 인스턴스가 존재하고, <code class=\"language-text\">value</code> 변수는 각 스코프 인스턴스 내에서 오직 한 번만 선언된다.</p>\n<p>그렇다면 <code class=\"language-text\">i</code> 는 어떤가? (<code class=\"language-text\">i</code> 도 변수이다!) <code class=\"language-text\">i</code> 는 “재선언” 되는 것일까? 이 물음에 대한 해답을 찾기 위해 우선 <code class=\"language-text\">i</code> 가 어떤 스코프에 속해있는지를 살펴보자. 언뜻 보기엔 <code class=\"language-text\">for</code> 루프의 바깥 스코프(위 코드의 경우, 글로벌 스코프)에 속해있는것 같지만 아니다. <code class=\"language-text\">i</code> 는 <code class=\"language-text\">value</code> 와 같이 <code class=\"language-text\">for</code> 루프의 스코프에 속해있다.</p>\n<p>좀 더 쉽게 이해하기 위해, 위 코드가 내부적으로 다음과 같이 변환된다고 생각할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 물론 실제로 이렇게 변환되는 것은 아니다.</span>\n<span class=\"token keyword\">let</span> $$i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> $$i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> $$i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> $$i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 코드를 보면 <code class=\"language-text\">i</code> 가 어느 스코프에 속하는지 좀 더 명확해보인다. 즉, <code class=\"language-text\">i</code> 도 <code class=\"language-text\">value</code> 와 마찬가지로 각 iteration의 스코프 인스턴스에 속하여 오직 한 번만 선언된다.</p>\n<p>다음과 같은 <code class=\"language-text\">for</code> 루프의 형태도 논리는 동일하다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> key <span class=\"token keyword\">in</span> someObj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> student <span class=\"token keyword\">of</span> students<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> <span class=\"token comment\">/* ... */</span> <span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서도 변수(<code class=\"language-text\">key</code> , <code class=\"language-text\">student</code>) 는 <code class=\"language-text\">for</code> 루프의 각 iteration 스코프 인스턴스에 속한다. 따라서 이 경우에도 재선언은 일어나지 않는다.</p>\n<br/>\n<p>그럼 이제 <code class=\"language-text\">const</code> 의 경우도 한번 살펴보자. 사실 <code class=\"language-text\">const</code> 도 앞서 살펴본 경우와 동일하게 동작한다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>keepGoing<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> value <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>value <span class=\"token operator\">></span> <span class=\"token number\">0.5</span><span class=\"token punctuation\">)</span> keepGoing <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">for</code> 루프의 경우도 마찬가지다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> key <span class=\"token keyword\">in</span> someObj<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> student <span class=\"token keyword\">of</span> students<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>하지만 문제가 하나 있다. 다음을 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 첫 번째 iteration 이후 에러 발생!!</span>\n\t<span class=\"token comment\">// TypeError: Assignment to constant variable.</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>왜 에러가 발생하는 것일까? 앞에서 <code class=\"language-text\">let</code> 을 통해 살펴보았을 때는 <code class=\"language-text\">i</code> 가 각 iteration 스코프마다 선언되므로 전혀 문제가 없었다!</p>\n<p>하지만 위 코드를 다음과 같이 확장해보면 문제를 금방 파악할 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> $$i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">;</span> $$i <span class=\"token operator\">&lt;</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> $$i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> i <span class=\"token operator\">=</span> $$i<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> i <span class=\"token operator\">*</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>i<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">: </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 보면 알 수 있겠지만, 여기서도 <code class=\"language-text\">i</code> 가 각 iteration 스코프 마다 선언되는 것은 맞다. 이는 재선언이 아니므로 전혀 문제되지 않는다.</p>\n<p>진짜 문제는, 가상의 <code class=\"language-text\">$$i</code> 의 값이 변한다는 점이다. 즉, <code class=\"language-text\">$$i++</code> 표현식에서 <code class=\"language-text\">const</code> 타입의 <code class=\"language-text\">$$i</code> 값을 바꾸고 있기 때문에 에러가 발생하는 것이다.</p>\n<p>물론 위 코드는 어디까지나 이해를 돕기 위해 만들어낸 <strong>가상의</strong> 코드이다. 실제로 자바스크립트 엔진이 <code class=\"language-text\">$$i</code> 를 <code class=\"language-text\">let</code> 변수로 선언할 수도 있다. 하지만 이렇게 하면 <code class=\"language-text\">const</code> 를 <code class=\"language-text\">for</code> 루프에서 사용할 때 예외적인 상황이 발생하는 것이므로 그리 바람직할 것 같지는 않다.</p>\n<h2 id=\"tdz-temporal-dead-zone\" style=\"position:relative;\"><a href=\"#tdz-temporal-dead-zone\" aria-label=\"tdz temporal dead zone permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDZ, Temporal Dead Zone</h2>\n<p>앞서 우리는 <code class=\"language-text\">var</code> 변수가 스코프의 최상단 부분으로 호이스팅 될 때 자동적으로 <code class=\"language-text\">undefined</code> 로 초기화 된다는 사실을 살펴보았다.</p>\n<p>하지만 <code class=\"language-text\">let</code> 과 <code class=\"language-text\">const</code> 의 경우는 조금 다르다. 다음을 살펴보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위 코드를 실행하면 <code class=\"language-text\">ReferenceError: Cannot access 'studentName' before initialization</code> 와 같은 에러가 발생한다. 에러 메시지를 살펴보면, <code class=\"language-text\">studentName</code> 이라는 변수가 (첫째 줄에) 존재하기는 하나, 아직 초기화 되지 않아 사용할 수 없다는 의미이다.</p>\n<p>그럼 다음과 같이 초기화 해주면 될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> studentName<span class=\"token punctuation\">;</span></code></pre></div>\n<p>여전히 동일한 에러가 발생한다. 뭐가 문제일까? 초기화 되지 않은(uninitialized) 변수를 어떻게 초기화(initialize)할 수 있을까?</p>\n<p><code class=\"language-text\">let</code> 과 <code class=\"language-text\">const</code> 의 경우, 해당 변수를 “초기화”하는 <strong>유일한 방법</strong>은 <strong>변수를 선언할 때 초기화</strong> 하는 방법밖에 없다. 즉,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Suzy</span>\n\n<span class=\"token comment\">// 혹은</span>\n<span class=\"token keyword\">let</span> studentName<span class=\"token punctuation\">;</span>\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Suzy</span></code></pre></div>\n<p>스코프에 진입하여 변수가 자동적으로 초기화 될 때까지 해당 변수를 사용할 수 없는 <strong>기간</strong>을 TDZ라고 한다. 즉, TDZ란 변수가 존재는 하지만 아직 초기화 되지 않아서 사용할 수 없는 구간이라 할 수 있다. 변수가 원래 선언된 위치에 도달해서야 비로소 해당 변수를 사용할 수 있게 되는 것이다. 다음 코드에 대해 TDZ를 그림으로 나타내면 아래와 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> pi <span class=\"token operator\">=</span> <span class=\"token number\">3.14</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>pi<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/javascript/hoisting/tdz.png\" alt=\"TDZ example\">\n    <figcaption>TDZ 예시</figcaption>\n</figure>\n<p>사실 <code class=\"language-text\">var</code> 도 TDZ가 존재하지만, TDZ의 크기가 0이라서 눈에 보이지는 않는다.</p>\n<br/>\n<p>한편, TDZ는 “위치”가 아니라 “시간”과 관련된 개념이다. 다음 코드를 보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">askQuestion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\n\n<span class=\"token keyword\">let</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">askQuestion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>studentName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, do you know?</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위치적으로 <code class=\"language-text\">studentName</code> 을 참조하는 <code class=\"language-text\">console.log</code> 가 <code class=\"language-text\">let studentName = 'Suzy';</code> 선언문보다 뒤에 존재하지만, 시간적으로 봤을 때 <code class=\"language-text\">askQuestion()</code> 함수 호출이 <code class=\"language-text\">studentName</code> 의 초기화 보다 먼저 일어나기 때문에 TDZ 에러가 발생한 것이다.</p>\n<p>혹자는 다음과 같이 호이스팅이 일어나기 때문에 에러가 발생하지 않는 것 아니냐고 물을 수도 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">askQuestion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>studentName<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">, do you know?</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">let</span> studentName<span class=\"token punctuation\">;</span>\n<span class=\"token function\">askQuestion</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined, do you know?</span>\n\nstudentName <span class=\"token operator\">=</span> <span class=\"token string\">'Suzy'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>앞서도 언급했지만 “호이스팅” 이라는 것은 개념적인 것이다. 즉, <strong>실제로는 자바스크립트를 컴파일 하는 과정에서 identifier들을 스코프의 맨 윗부분에 등록하는 과정을 호이스팅</strong> 이라고 부르는 것이다. 실제로 위 코드와 같은 일이 일어나는 것이 아니다.</p>\n<p>그럼 어떻게 TDZ 에러를 피할 수 있을 까? 한 가지 방법은, 항상 <code class=\"language-text\">let</code> 과 <code class=\"language-text\">const</code> 변수 선언문을 스코프 맨 윗부분에 작성하는 것이다. 이렇게 하면 TDZ의 크기(length)를 0으로 만들어 TDZ 에러를 예방할 수 있다.</p>\n<h2 id=\"tdz-좀-더-살펴보기\" style=\"position:relative;\"><a href=\"#tdz-%EC%A2%80-%EB%8D%94-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"tdz 좀 더 살펴보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TDZ 좀 더 살펴보기</h2>\n<p><a href=\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/apA.md#whats-the-deal-with-tdz\">원문</a></p>\n<p>우선 TDZ가 생겨난 배경부터 살펴보자. 사실 TDZ는 <code class=\"language-text\">const</code>로 인해 생겨난 개념이다.</p>\n<p>초기에 ES6를 개발할 때, TC39 멤버들은 <code class=\"language-text\">const</code>(와 <code class=\"language-text\">let</code>)가 블록의 최상단으로 호이스팅 되어야 하는지 결정했어야 했고, 결국 <code class=\"language-text\">var</code>와 같이 호이스팅 되도록 설계했다. </p>\n<p>근데 왜 <code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>는 <code class=\"language-text\">var</code>와는 달리 자동적으로 (<code class=\"language-text\">undefined</code>로) 초기화되지 않는걸까? 다음 코드를 통해 그 이유를 알 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 어떤 값이 출력될까?</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>studentName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n\n    <span class=\"token keyword\">const</span> studentName <span class=\"token operator\">=</span> <span class=\"token string\">'Frank'</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>만약 위 코드에서 <code class=\"language-text\">studentName</code> 변수가 블록 최상단으로 호이스팅될 뿐만 아니라, 자동적으로 <code class=\"language-text\">undefined</code>로 초기화된다고 가정해보자. 그렇게 되면 <code class=\"language-text\">const studentName = 'Frank';</code>문장을 기준으로, <code class=\"language-text\">studentName</code>이 윗 부분에선 <code class=\"language-text\">undefined</code>의 값을 가질 것이고, 변수 선언문 부터는 <code class=\"language-text\">'Frank'</code>라는 값을 가질 것이다.</p>\n<p>하지만 생각해보면 이상하지 않은가? <strong>상수(constant)</strong>가 서로 다른 두 개의 값을 가지는 것은 말이 안되는 것 같다! 바로 여기서 문제가 발생한 것이다. 즉, <code class=\"language-text\">const</code> 변수는 오직 최초에 초기화된 값 하나만 가질 수 있으므로 호이스팅 되면서 자동적으로 <code class=\"language-text\">undefined</code>로 초기화 되는것은 말이 안된다. 하지만 호이스팅은 일어나므로 <code class=\"language-text\">const</code> 선언문이 어디에 있건 관계없이 변수 전역에서 해당 <code class=\"language-text\">const</code> 변수를 “볼 수 있어야 한다(visible)“. 그럼 해당 변수가 존재하기 시작하는 시점인 스코프의 최상단으로부터 변수가 초기화되는 시점(변수의 선언문이 존재하는 위치) 까지의 “기간(period of time)“은 어떻게 처리해야할까?</p>\n<p>우리는 이러한 “기간”을 ”<strong>dead zone</strong>“이라고 부르기로 했다. 따라서 호이스팅은 일어나지만 값이 자동적으로 초기화 되지 않음으로 인해 발생하는 혼란일 방지하고자 TDZ에 있는 변수를 참조하게 되면 TDZ에러를 발생시킨다.</p>\n<h3 id=\"그렇다면-let은\" style=\"position:relative;\"><a href=\"#%EA%B7%B8%EB%A0%87%EB%8B%A4%EB%A9%B4-let%EC%9D%80\" aria-label=\"그렇다면 let은 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>그렇다면 let은?</h3>\n<p>TDZ가 <code class=\"language-text\">const</code>때문에 생겨난 것은 알겠다. 그럼 <code class=\"language-text\">let</code>은 왜 <code class=\"language-text\">const</code>와 같이 동작하는 걸까? <code class=\"language-text\">let</code>은 여러 값을 가져도 괜찮잖아?</p>\n<p>그러게 말이다. 하지만 TC39에서 “일관성”을 위해 <code class=\"language-text\">let</code>도 <code class=\"language-text\">const</code>와 동일하게 TDZ를 적용시켰다. 하지만 내 생각(원문 저자)엔 “일관성”을 유지하고자 그러한 결정을 내린것이라면 차라리 <code class=\"language-text\">let</code>으로 하여금 <code class=\"language-text\">var</code>와 같이 동작하도록 했으면 어땠을까 싶다. 분명 <code class=\"language-text\">let</code>은 <code class=\"language-text\">const</code>보다는 <code class=\"language-text\">var</code>에 더 가까운 편이니까.</p>\n<p>TDZ에 관한 추가적인 학습은 다음 링크를 참고하길 바란다:</p>\n<p><a href=\"https://dmitripavlutin.com/javascript-variables-and-temporal-dead-zone/\">Don’t Use JavaScript Variables Without Knowing Temporal Dead Zone</a></p>","frontmatter":{"title":"자바스크립트 호이스팅","date":"August 19, 2020","category":"javascript"}}},"pageContext":{"slug":"/javascript/hoisting/","previous":{"fields":{"slug":"/javascript/nodejs_event_loop_1/"},"frontmatter":{"title":"Node.js의 이벤트 루프 Part1"}},"next":{"fields":{"slug":"/javascript/limiting_scope_exposure_2/"},"frontmatter":{"title":"자바스크립트 변수 노출 최소화 하기 Part2"}}}},"staticQueryHashes":[]}