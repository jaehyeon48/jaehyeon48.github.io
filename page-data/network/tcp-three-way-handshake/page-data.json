{"componentChunkName":"component---src-templates-blog-post-js","path":"/network/tcp-three-way-handshake/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"1e6ee60a-e04e-518f-a475-33250ac661ed","excerpt":"TCP는 연결 지향(connection-oriented) 프로토콜이므로 TCP를 이용하여 데이터를 주고받기 위해선 먼저 클라이언트와 서버 간에 논리적인 연결이 수립되어야 합니다. 이 포스트에서는 어떠한 절차를 거쳐 TCP 연결을 맺는지, 그리고 어떠한 절차를 거쳐 TCP 연결을 끊는지 살펴보겠습니다. TCP 3-way handshake 우선, TCP 3-way handshake 과정을 그림으로 살펴보면 아래와 같습니다: 클라이언트가 서버로 를 보냅니다. 는 헤더의  필드의 비트가…","html":"<p>TCP는 연결 지향(connection-oriented) 프로토콜이므로 TCP를 이용하여 데이터를 주고받기 위해선 먼저 클라이언트와 서버 간에 논리적인 연결이 수립되어야 합니다. 이 포스트에서는 어떠한 절차를 거쳐 TCP 연결을 맺는지, 그리고 어떠한 절차를 거쳐 TCP 연결을 끊는지 살펴보겠습니다.</p>\n<h2 id=\"tcp-3-way-handshake\" style=\"position:relative;\"><a href=\"#tcp-3-way-handshake\" aria-label=\"tcp 3 way handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>TCP 3-way handshake</h2>\n<p>우선, TCP 3-way handshake 과정을 그림으로 살펴보면 아래와 같습니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/network/tcp-three-way-handshake/tcp_3_way_handshake.png\" alt=\"TCP 3-way handshake\">\n  <figcaption>TCP 3-way handshake.</figcaption>\n</figure>\n<ol>\n<li>클라이언트가 서버로 <code class=\"language-text\">SYN 세그먼트</code>를 보냅니다. <code class=\"language-text\">SYN 세그먼트</code>는 헤더의 <code class=\"language-text\">SYN</code> 필드의 비트가 1로 설정된 세그먼트로, 애플리케이션의 데이터는 포함되지 않습니다. 이때, 클라이언트의 seq 초기값(client_isn)으로 사용할 난수(random number)가 <code class=\"language-text\">SYN 세그먼트</code> 헤더의 sequence number 필드에 포함됩니다. <code class=\"language-text\">SYN 세그먼트</code>를 보낸 클라이언트는 <code class=\"language-text\">SYN_SENT</code> 상태가 됩니다.</li>\n<li><code class=\"language-text\">SYN 세그먼트</code>를 받은 서버는 <code class=\"language-text\">SYN_RCVD</code> 상태가 되고, 해당 클라이언트와의 TCP 통신에서 사용할 버퍼 및 변수(e.g. 윈도우 크기)등을 초기화합니다. 그런 다음, 클라이언트의 <code class=\"language-text\">SYN 세그먼트</code> 에 대한 응답으로 헤더의 <code class=\"language-text\">SYN</code>과 <code class=\"language-text\">ACK</code> 필드의 비트가 1로 설정된 <code class=\"language-text\">SYNACK 세그먼트</code>를 클라이언트에 전송하는데, <code class=\"language-text\">SYNACK 세그먼트</code> 헤더의 acknowledgement number 필드에 클라이언트로부터 받은 seq 값에 대한 응답인 ack 값(client_isn + 1)과, 서버의 seq 초기값(server_isn)으로 사용할 난수를 sequence number 필드에 담아 전송합니다. <code class=\"language-text\">SYN 세그먼트</code>와 마찬가지로 <code class=\"language-text\">SYNACK 세그먼트</code>에도 애플리케이션의 데이터는 포함되지 않습니다.</li>\n<li><code class=\"language-text\">SYNACK 세그먼트</code> 를 받은 클라이언트는 해당 서버와의 TCP 통신에서 사용할 버퍼와 변수를 초기화하고, <code class=\"language-text\">SYNACK 세그먼트</code>를 통해 받은 값(server_isn)에 1을 더한 값을 ack 값으로 해서 <code class=\"language-text\">ACK 세그먼트</code>에 포함하여 서버에 전송합니다. 클라이언트의 상태가 <code class=\"language-text\">ESTABLISHED</code>로 바뀌고, 이제부터는 TCP 연결이 생성된 상태이므로 <code class=\"language-text\">ACK 세그먼트</code>를 서버에 전송할 때 애플리케이션의 데이터도 포함하여 전송할 수 있습니다. <code class=\"language-text\">ACK 세그먼트</code>의 <code class=\"language-text\">SYN</code> 필드는 0, <code class=\"language-text\">ACK</code> 필드는 1로 세팅됩니다.</li>\n<li>클라이언트로부터 <code class=\"language-text\">ACK 세그먼트</code>를 받은 서버는 <code class=\"language-text\">ESTABLISHED</code> 상태가 되고 클라이언트와 맺은 TCP 연결을 통해 데이터를 주고 받을 수 있게 됩니다.</li>\n</ol>\n<h3 id=\"tcp-2-way-handshake-대신-3-way-handshake를-사용하는-이유\" style=\"position:relative;\"><a href=\"#tcp-2-way-handshake-%EB%8C%80%EC%8B%A0-3-way-handshake%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0\" aria-label=\"tcp 2 way handshake 대신 3 way handshake를 사용하는 이유 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>TCP 2-way handshake 대신 3-way handshake를 사용하는 이유?</h3>\n<p>기본적으로, TCP는 양방향 통신(bi-directional)이고, seq 및 ack number를 통해 데이터를 올바르게 주고받았는지 체크합니다. 이때 만약 3-way 대신 2-way로 진행하게 된다면, 클라이언트는 자신의 존재를 알리고(SYN) 그에 대한 서버의 응답(SYNACK)을 받을 수 있지만 서버는 자신의 존재를 알린 뒤(SYNACK) 이에 대한 클라이언트의 응답을 받지 못하게 되므로 TCP를 통해 데이터를 reliable 하게 보낼 수 있는지 판단하지 못하게 됩니다 (즉, 클라이언트가 자신의 존재를 제대로 알았는지 확인하지 못함). 따라서 3-way handshake를 통해 양측 모두 자신의 존재를 알리고 이에 대한 확답을 받은 뒤 통신을 수행하게 됩니다.</p>\n<h2 id=\"tcp-4-way-handshake\" style=\"position:relative;\"><a href=\"#tcp-4-way-handshake\" aria-label=\"tcp 4 way handshake permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>TCP 4-way handshake</h2>\n<p>TCP 연결을 종료할 때도 3-way handshake와 비슷하게 4-way handshake 방식을 사용하여 연결을 종료합니다. TCP 연결을 맺은 클라이언트 혹은 서버 누구라도 연결을 종료할 수 있습니다.</p>\n<p>TCP 4-way handshake 과정을 그림으로 살펴보면 아래와 같습니다. 여기선 클라이언트가 먼저 연결 종료 요청을 보냈다고 가정해보겠습니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/network/tcp-three-way-handshake/tcp_4_way_handshake.png\" alt=\"TCP 4-way handshake\">\n  <figcaption>TCP 4-way handshake.</figcaption>\n</figure>\n<ol>\n<li>클라이언트가 TCP 연결 종료를 위해 <code class=\"language-text\">FIN</code> 헤더 필드가 1로 세팅된 <code class=\"language-text\">FIN 세그먼트</code>를 서버에 보내고, <code class=\"language-text\">FIN_WAIT_1</code> 상태가 됩니다.</li>\n<li>클라이언트로부터 <code class=\"language-text\">FIN 세그먼트</code>를 받은 서버는 <code class=\"language-text\">ACK 세그먼트</code>를 보내 응답하고 <code class=\"language-text\">CLOSE_WAIT</code> 상태가 됩니다. 서버로부터 <code class=\"language-text\">ACK 세그먼트</code>를 받은 클라이언트는 <code class=\"language-text\">FIN_WAIT_2</code> 상태가 됩니다.</li>\n<li>이후 서버에서 연결을 종료할 준비가 완료되면(이전에 수행되고 있던 통신이 완전히 끝나면) <code class=\"language-text\">FIN 세그먼트</code>를 보내고 서버는 <code class=\"language-text\">LAST_ACK</code> 상태가 됩니다.</li>\n<li>서버로부터 <code class=\"language-text\">FIN 세그먼트</code>를 받은 클라이언트는 서버에게 <code class=\"language-text\">ACK 세그먼트</code>를 보내 응답하고 <code class=\"language-text\">TIME_WAIT</code> 상태가 됩니다.</li>\n<li>클라이언트로부터 <code class=\"language-text\">ACK 세그먼트</code>를 받은 서버는 <code class=\"language-text\">CLOSED</code> 상태가 됩니다.</li>\n<li><code class=\"language-text\">ACK 세그먼트</code>를 보낸 클라이언트는 일정 시간(기본값은 240초) 기다린 후 연결을 종료합니다. 이때 일정 시간을 기다렸다가 종료하는 이유는, <code class=\"language-text\">ACK 세그먼트</code>가 유실될 경우를 대비해서 기다리는 것인데, 만약 <code class=\"language-text\">ACK 세그먼트</code>를 보낸 다음 바로 연결을 종료해버리면 클라이언트가 보낸 <code class=\"language-text\">ACK 세그먼트</code>가 유실될 경우 서버에선 <code class=\"language-text\">FIN 세그먼트</code>가 유실된 줄 알고 <code class=\"language-text\">FIN 세그먼트</code>를 재전송하게 됩니다. 하지만 이미 클라이언트는 연결을 종료해버렸기 때문에 재전송된 <code class=\"language-text\">FIN 세그먼트</code>는 버려지게 되는데, 이에 따라 서버에서는 클라이언트로부터 <code class=\"language-text\">ACK 세그먼트</code>가 오질 않으니 <code class=\"language-text\">FIN 세그먼트</code>가 유실된 줄 알고 계속해서 <code class=\"language-text\">FIN 세그먼트</code>를 재전송하는 현상이 발생할 수 있습니다. 따라서 이러한 현상을 방지하고자 <code class=\"language-text\">ACK 세그먼트</code>를 보낸 뒤 일정 시간 기다렸다가 최종적으로 TCP 연결을 종료하게 됩니다.</li>\n<li>TCP 연결이 완전히 종료되면 TCP 통신을 위해 할당되었던 모든 자원의 할당 해제가 이뤄집니다.</li>\n</ol>","frontmatter":{"title":"TCP 3-way & 4-way handshake","date":"May 19, 2022","category":"network"}}},"pageContext":{"slug":"/network/tcp-three-way-handshake/","previous":{"fields":{"slug":"/web/frontend-state-management-paradigm/"},"frontmatter":{"title":"프론트엔드 생태계의 상태 관리 패러다임 변화"}},"next":{"fields":{"slug":"/network/dns/"},"frontmatter":{"title":"DNS란 무엇일까"}}}},"staticQueryHashes":[]}