{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-as-a-ui-runtime/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"0553134f-feb3-542d-afb1-5215bbde1876","excerpt":"이 포스트는 React as a UI Runtime를 번역/요약한 글입니다. 호스트 트리 (Host Tree) 각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다. React 프로그램은 시간에 따라 변할 수도 있는 트리를 출력한다. 이 트리를 “호스트 트리” 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 외부 호스트 환경의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API…","html":"<p>이 포스트는 <a href=\"https://overreacted.io/react-as-a-ui-runtime/\">React as a UI Runtime</a>를 번역/요약한 글입니다.</p>\n<hr class=\"custom-hr\">\n<h2 id=\"호스트-트리-host-tree\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%8A%B8%EB%A6%AC-host-tree\" aria-label=\"호스트 트리 host tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 트리 (Host Tree)</h2>\n<ul>\n<li>각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다.</li>\n<li>React 프로그램은 시간에 따라 변할 수도 있는 <strong>트리</strong>를 출력한다. 이 트리를 <strong>“호스트 트리”</strong> 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 <em>외부 호스트 환경</em>의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API가 있고, React는 그 위에 존재하는 레이어이다.</li>\n<li>매우 추상적으로 말하자면, React는 외부 상호작용·네트워크 응답·타이머와 같은 외부 이벤트에 대해 반응하는 복잡한 호스트 트리를 예측 가능한 방식으로 조작할 수 있는 프로그램을 만드는 데 도움을 준다.</li>\n<li>\n<p>React는 다음의 두 원칙에 근거하고 있다:</p>\n<ul>\n<li><strong>안정성</strong>: 호스트 트리는 비교적 안정적이며, 대부분의 업데이트는 트리 전체의 구조를 뜯어고치진 않는다. 만약 모든 상호작용하는 요소들이 매 순간 완전히 바뀌게 된다면 “아니, 버튼이 어디로 간 거야?” 혹은, “화면이 왜 이래?”와 같이 앱을 사용하기 어려울 것이다.</li>\n<li><strong>규칙성</strong>: 호스트 트리는 무작위 형태가 아닌, 일관된 모습과 동작을 지닌 (버튼, 리스트, 아바타와 같은) UI 패턴 으로 나눌 수 있다.</li>\n</ul>\n</li>\n<li>이러한 원칙들은 대부분의 UI에 해당하지만, <a href=\"https://www.youtube.com/watch?v=Uzx9ArZ7MUU\">3D 파이프 스크린 세이버</a>와 같이 일정한 “패턴”이 없는 경우엔 별 도움이 안 된다.</li>\n</ul>\n<h2 id=\"호스트-객체-host-instances\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4-host-instances\" aria-label=\"호스트 객체 host instances permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 객체 (Host Instances)</h2>\n<ul>\n<li>호스트 트리는 <strong>호스트 객체</strong>라고 불리는 노드들로 구성된다. DOM 환경에서 <code class=\"language-text\">document.createElement('div')</code>를 했을 때 생성되는 객체(DOM 노드)와 흡사하다고 할 수 있다.</li>\n<li>호스트 객체는 <code class=\"language-text\">domNode.className</code> 혹은 <code class=\"language-text\">view.tintColor</code>와 같은 고유한 프로퍼티를 가지고 있으며, 다른 호스트 객체를 자식으로 가질 수도 있다.</li>\n<li>또한 DOM의 <code class=\"language-text\">appendChild</code>, <code class=\"language-text\">removeChild</code>와 같이, 호스트 객체를 조작할 수 있는 API도 존재한다. 일반적인 React 앱에선 (React가 대신 처리해 주기 때문에) 이러한 API를 호출할 일이 없을 것이다.</li>\n</ul>\n<h2 id=\"렌더러-renderers\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%9F%AC-renderers\" aria-label=\"렌더러 renderers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더러 (Renderers)</h2>\n<ul>\n<li><strong>렌더러</strong>는 React로 하여금 특정 호스트 환경과 소통하고, (해당 환경에 있는) 호스트 객체들을 관리하도록 한다. React DOM, React Native와 같은 것들이 렌더러이다. 또한 <a href=\"https://github.com/facebook/react/tree/main/packages/react-reconciler\">나만의 렌더러를 직접 만들 수도 있다.</a></li>\n<li>\n<p>React 렌더러에는 두 가지 동작 모드가 존재한다:</p>\n<ul>\n<li><strong>변경(mutating) 모드</strong>: 대부분의 렌더러들은 변경 모드를 사용하도록 만들어졌다. 이 모드는 DOM이 동작하는 방식인데, 노드를 만들 수 있고, 프로퍼티를 설정할 수 있고, 추후에 자식을 추가하거나 제거할 수도 있다. 호스트 객체들은 가변(mutable)이다.</li>\n<li><strong>지속(persistent) 모드:</strong>: 지속 모드는 <code class=\"language-text\">appendChild()</code>와 같은 메소드를 제공하지 않는 호스트 환경에서 동작하는 모드이다. 이 모드에선 부모의 트리를 복제하여 최상위 자식을 대체하는 방식으로 동작한다. 호스트 트리의 불변성 덕분에 멀티 스레딩을 쉽게할 수 있다. <a href=\"https://reactnative.dev/blog/2018/06/14/state-of-react-native-2018\">React Fabric</a>은 이를 활용한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"react-요소-react-element\" style=\"position:relative;\"><a href=\"#react-%EC%9A%94%EC%86%8C-react-element\" aria-label=\"react 요소 react element permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 요소 (React Element)</h2>\n<ul>\n<li>(DOM 노드와 같은) 호스트 객체는 호스트 환경에서 가장 작은 구성 요소이다. React에선 React 요소가 가장 작은 구성 요소이다.</li>\n<li>React 요소는 호스트 객체를 묘사할 수 있는 일반적인 자바스크립트 객체이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;button className=\"blue\" /></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>React 요소는 어떠한 호스트 객체와도 연관되지 않는다. 다시 말하지만, React 요소는 단순히 어떤 것이 화면에 그려졌으면 하는지에 대한 정보에 불과하다.</li>\n<li>또한 호스트 객체와 같이 React 요소도 트리 구조를 형성할 수 있다 (여기선 <a href=\"https://overreacted.io/why-do-react-elements-have-typeof-property/\">몇몇 프로퍼티</a>들이 생략되어 있다):</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;dialog></span>\n<span class=\"token comment\">//   &lt;button className=\"blue\" /></span>\n<span class=\"token comment\">//   &lt;button className=\"red\" /></span>\n<span class=\"token comment\">// &lt;/dialog></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'dialog'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'red'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>하지만, React 요소에는 영구적인 고유 ID가 존재하지 않는다. 이들은 매번 새로 만들어지고 버려진다.</li>\n<li>또, React 요소들은 불변(immutable)이기 때문에, 요소의 자식이나 프로퍼티 등을 변경할 수 없다. 만약 무언가 다른 것을 (화면에) 렌더링 하고 싶다면 새로운 React 요소를 생성해야 한다.</li>\n<li>React 요소를 영화의 프레임으로 생각하면 쉽다. 각 요소들은 특정 순간에 UI가 어떠한 모습이어야 하는지를 나타내고 있고, 변하지 않는다.</li>\n</ul>\n<h2 id=\"진입점-entry-point\" style=\"position:relative;\"><a href=\"#%EC%A7%84%EC%9E%85%EC%A0%90-entry-point\" aria-label=\"진입점 entry point permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진입점 (Entry Point)</h2>\n<ul>\n<li>각 React 렌더러에는 “진입점”이 존재한다. 진입점은 우리가 React로 하여금 어떤 React 요소 트리를 컨테이너 호스트 객체 내부에 렌더링 할 수 있게 해주는 API라고 할 수 있다.</li>\n<li>예를 들면, React DOM의 진입점은 <code class=\"language-text\">ReactDOM.render</code> 이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token comment\">// 아래의 JSX는 {type: 'button', props: {className: 'blue'}}를 나타낸 것이라 할 수 있다.</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">ReactDOM.render(reactElement, domContainer)</code>라고 하는 것은 “React님, <code class=\"language-text\">domContainer</code> 호스트 트리를 <code class=\"language-text\">reactElement</code>와 같게 해주세요”라고 하는 것과 같다.</li>\n<li>React는 요소의 타입 (<code class=\"language-text\">reactElement.type</code>, 위 예시에서는 <code class=\"language-text\">'button'</code>)을 보고, ReactDOM 렌더러에게 해당 타입에 맞는 호스트 객체를 생성하고 프로퍼티를 설정하도록 요청한다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// ReactDOM 렌더러 어딘가 (간략한 버전)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createHostInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reactElement</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>reactElement<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  domNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> reactElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>className<span class=\"token punctuation\">;</span></span>  <span class=\"token keyword\">return</span> domNode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 현재 예시에 대해 React가 실질적으로 하는 동작은 다음과 같다:</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">domNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'blue'</span><span class=\"token punctuation\">;</span></span>\ndomContainer<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>domNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>만약 React 요소에 자식 요소가 존재한다면 (<code class=\"language-text\">reactElement.props.children</code>), React는 첫 번째 렌더링 때 재귀적으로 해당 자식 요소들을 생성한다.</li>\n</ul>\n<h2 id=\"재조정-reconciliation\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%A1%B0%EC%A0%95-reconciliation\" aria-label=\"재조정 reconciliation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재조정 (Reconciliation)</h2>\n<ul>\n<li>동일한 컨테이너에 대해 <code class=\"language-text\">ReactDOM.render()</code>를 두 번 호출하면 어떻게 될까?</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span></span>  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ... 이후</span>\n\n<span class=\"token comment\">// 현재의 \"버튼\" 호스트 객체를 대체해야할 까, 아니면</span>\n<span class=\"token comment\">// 단순히 기존 호스트 객체의 프로퍼티를 업데이트 해야할까?</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>red<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span></span>  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>다시 말하자면, React의 역할은 호스트 트리와 현재 주어진 React 요소 트리를 같게 만드는 것이다. 새로운 정보를 바탕으로 호스트 객체에 어떤 작업을 해야 하는지를 알아내는 과정을 <a href=\"https://reactjs.org/docs/reconciliation.html\">reconciliation</a> 이라고 한다.</li>\n<li>재조정에는 두 가지 방법이 존재한다. 단순히 기존의 트리를 날려버리고 새로운 트리를 처음부터 다시 만드는 방법이 있을 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> domContainer <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 트리 초기화</span>\ndomContainer<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 새로운 호스트 트리를 생성</span>\n<span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ndomNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span>\ndomContainer<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>domNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>하지만 DOM의 경우 위 방법은 느리다. 또한, 포커스, 선택, 스크롤 상태와 같은 정보들도 다 날아간다. 따라서 위 방법 대신 다음과 같은 방법을 사용할 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> domContainer<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 기존에 존재하는 호스트 객체를 업데이트</span>\ndomNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>즉, React는 <em>언제</em> 기존의 호스트 객체를 업데이트 할지, 그리고 언제 새로운 객체를 생성할지 결정해야 한다. 하지만 이때, React 요소들은 매번 다른데 어떻게 같은 호스트 객체를 나타낸다는 것을 어떻게 알 수 있을까?</li>\n<li>위 예제에서는 간단하다. <code class=\"language-text\">&lt;button></code>을 첫 번째 자식으로 렌더링 했고, 똑같은 위치에 <code class=\"language-text\">&lt;button></code>을 다시 렌더링 하고 싶어 하므로, 기존에 존재하는 <code class=\"language-text\">&lt;button></code> 호스트 객체를 재사용하면 된다. 이는 React가 생각하는 방식과 흡사하다.</li>\n<li><strong>직전 렌더링과 다음 렌더링 사이에, 트리상에서 같은 위치에 있는 요소들의 타입이 같으면 React는 기존에 존재하는 호스트 객체를 재사용한다</strong>. 다음 예제를 살펴보자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// let domNode = document.createElement('button');</span>\n<span class=\"token comment\">// domNode.className = 'blue';</span>\n<span class=\"token comment\">// domContainer.appendChild(domNode);</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 호스트 객체를 재사용할 수 있다! (button → button)</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// domNode.className = 'red';</span></span>ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>red<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 호스트 객체를 재사용할 수 없다.. (button → p)</span></span><span class=\"token comment\">// domContainer.removeChild(domNode);</span>\n<span class=\"token comment\">// domNode = document.createElement('p');</span>\n<span class=\"token comment\">// domNode.textContent = 'Hello';</span>\n<span class=\"token comment\">// domContainer.appendChild(domNode);</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 호스트 객체를 재사용할 수 있다! (p → p)</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// domNode.textContent = 'Goodbye';</span></span>ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Goodbye</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>자식 트리에도 동일한 휴리스틱 알고리즘이 적용된다. 예를 들어, 두 개의 <code class=\"language-text\">&lt;button></code> 요소를 자식으로 가지는 <code class=\"language-text\">&lt;dialog></code> 요소를 업데이트할 때, React는 우선 부모 요소인 <code class=\"language-text\">&lt;dialog></code>를 재사용할 수 있는지 따져보고 그다음 이러한 과정을 자식 요소인 <code class=\"language-text\">&lt;button></code>에 대해서도 동일하게 진행한다.</li>\n</ul>\n<h2 id=\"조건-conditions\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B1%B4-conditions\" aria-label=\"조건 conditions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조건 (Conditions)</h2>\n<ul>\n<li>업데이트할 때, React가 같은 타입의 호스트 객체들만 재사용한다면 조건부 컨텐츠(특정 조건을 만족하는 경우 나타나는 컨텐츠?)에 대해선 어떻게 해야할까? 다음 예제와 같이, 처음에는 input만 보여줬다가 이후 메세지도 함께 보여준다고 하자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// First render</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>dialog<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>input <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dialog<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// Next render</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>dialog<span class=\"token operator\">></span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token constant\">I</span> was just added here<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span></span>    <span class=\"token operator\">&lt;</span>input <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dialog<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>\n<p>위 예제에서 <code class=\"language-text\">&lt;input></code> 호스트 객체는 다시 생성될 것이다. React가 이전 버전의 트리와 비교하는 과정을 다음처럼 나타낼 수 있다:</p>\n<ul>\n<li><code class=\"language-text\">dialog → dialog</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n<li><code class=\"language-text\">input → p</code>: 요소의 타입이 변경되었으므로 재사용 불가능. 기존의 <code class=\"language-text\">input</code> 객체를 제거하고 새로운 <code class=\"language-text\">p</code> 호스트 객체를 생성해야함.</li>\n<li><code class=\"language-text\">(noting) → input</code>: 새로운 <code class=\"language-text\">input</code> 객체를 생성해야함.</li>\n</ul>\n</li>\n<li>따라서, 실질적으로 React가 수행한 업데이트 코드는 다음과 같을 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> oldInputNode <span class=\"token operator\">=</span> dialogNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">dialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>oldInputNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n<span class=\"token keyword\">let</span> pNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\npNode<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'I was just added here!'</span><span class=\"token punctuation\">;</span>\ndialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>pNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> newInputNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">dialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>newInputNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span></code></pre></div>\n<ul>\n<li>하지만 생각해 보면, <code class=\"language-text\">&lt;input></code>이 <code class=\"language-text\">&lt;p></code>로 바뀐 것이 아니라 단순히 이동된 것이므로 위와 같은 동작은 뭔가 아쉽다. 또, 이렇게 하면 포커스, 선택, 입력한 내용들도 다 날아가버린다.</li>\n<li>사실 이 문제엔 (곧 살펴볼) 간단한 해결책이 존재한다. 하지만 위와 같은 상황이 그리 자주 발생하지는 않는다. 왜냐면, 실제로는 <code class=\"language-text\">ReactDOM.render</code>를 직접 호출할 일이 거의 없기 때문이다. 대신, React 앱들은 주로 다음과 같이 함수들로 나뉘게 된다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> showMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">I was just added here!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dialog</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dialog</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>이 예제에선 방금 살펴본 문제가 발생하지 않는다. 왜 그런지는 다음과 같이 JSX를 객체 형태로 표시하면 더 쉽게 확인할 수 있다. <code class=\"language-text\">dialog</code>의 자식 트리를 살펴보자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> showMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> children<span class=\"token operator\">:</span> <span class=\"token string\">'I was just added here!'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> <span class=\"token string\">'dialog'</span><span class=\"token punctuation\">,</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">      children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span></span><span class=\"gatsby-highlight-code-line\">        message<span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">        <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'input'</span><span class=\"token punctuation\">,</span> props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span></span><span class=\"gatsby-highlight-code-line\">      <span class=\"token punctuation\">]</span></span>    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>\n<p>여기서, <code class=\"language-text\">showMessage</code>가 <code class=\"language-text\">true</code>이건 <code class=\"language-text\">false</code>이건 상관없이 <code class=\"language-text\">&lt;input></code>은 항상 <code class=\"language-text\">&lt;dialog></code>의 두 번째 자식이므로 그 위치가 변하지 않는다. <code class=\"language-text\">showMessage</code>가 <code class=\"language-text\">false</code>에서 <code class=\"language-text\">true</code>로 바뀌면 React는 다음과 같이 이전 버전과 비교할 것이다:</p>\n<ul>\n<li><code class=\"language-text\">dialog → dialog</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n<li><code class=\"language-text\">(null) → p</code>: 새로운 <code class=\"language-text\">p</code> 호스트 객체를 추가해야함.</li>\n<li><code class=\"language-text\">input → input</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n</ul>\n</li>\n<li>따라서, 실질적으로 React가 수행한 업데이트 코드는 다음과 같을 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// \"input\"의 상태가 그대로 유지된다!</span>\n<span class=\"token keyword\">let</span> inputNode <span class=\"token operator\">=</span> dialogNode<span class=\"token punctuation\">.</span>firstChild<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> pNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\npNode<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'I was just added here!'</span><span class=\"token punctuation\">;</span>\ndialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>pNode<span class=\"token punctuation\">,</span> inputNode<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>","frontmatter":{"title":"UI 런타임으로서의 React","date":"December 22, 2021","category":"react"}}},"pageContext":{"slug":"/react/react-as-a-ui-runtime/","previous":{"fields":{"slug":"/architecture/refactoring-list-1/"},"frontmatter":{"title":"리팩토링 방법들 Part.1"}},"next":null}},"staticQueryHashes":[]}