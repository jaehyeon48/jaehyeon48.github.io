{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-as-a-ui-runtime/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"0553134f-feb3-542d-afb1-5215bbde1876","excerpt":"이 포스트는 React as a UI Runtime를 번역/요약한 글입니다. 호스트 트리 (Host Tree) 각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다. React 프로그램은 시간에 따라 변할 수도 있는 트리를 출력한다. 이 트리를 “호스트 트리” 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 외부 호스트 환경의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API…","html":"<p>이 포스트는 <a href=\"https://overreacted.io/react-as-a-ui-runtime/\">React as a UI Runtime</a>를 번역/요약한 글입니다.</p>\n<hr class=\"custom-hr\">\n<h2 id=\"호스트-트리-host-tree\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%8A%B8%EB%A6%AC-host-tree\" aria-label=\"호스트 트리 host tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 트리 (Host Tree)</h2>\n<ul>\n<li>각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다.</li>\n<li>React 프로그램은 시간에 따라 변할 수도 있는 <strong>트리</strong>를 출력한다. 이 트리를 <strong>“호스트 트리”</strong> 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 <em>외부 호스트 환경</em>의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API가 있고, React는 그 위에 존재하는 레이어이다.</li>\n<li>매우 추상적으로 말하자면, React는 외부 상호작용·네트워크 응답·타이머와 같은 외부 이벤트에 대해 반응하는 복잡한 호스트 트리를 예측 가능한 방식으로 조작할 수 있는 프로그램을 만드는 데 도움을 준다.</li>\n<li>\n<p>React는 다음의 두 원칙에 근거하고 있다:</p>\n<ul>\n<li><strong>안정성</strong>: 호스트 트리는 비교적 안정적이며, 대부분의 업데이트는 트리 전체의 구조를 뜯어고치진 않는다. 만약 모든 상호작용하는 요소들이 매 순간 완전히 바뀌게 된다면 “아니, 버튼이 어디로 간 거야?” 혹은, “화면이 왜 이래?”와 같이 앱을 사용하기 어려울 것이다.</li>\n<li><strong>규칙성</strong>: 호스트 트리는 무작위 형태가 아닌, 일관된 모습과 동작을 지닌 (버튼, 리스트, 아바타와 같은) UI 패턴 으로 나눌 수 있다.</li>\n</ul>\n</li>\n<li>이러한 원칙들은 대부분의 UI에 해당하지만, <a href=\"https://www.youtube.com/watch?v=Uzx9ArZ7MUU\">3D 파이프 스크린 세이버</a>와 같이 일정한 “패턴”이 없는 경우엔 별 도움이 안 된다.</li>\n</ul>\n<h2 id=\"호스트-객체-host-instances\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4-host-instances\" aria-label=\"호스트 객체 host instances permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 객체 (Host Instances)</h2>\n<ul>\n<li>호스트 트리는 <strong>호스트 객체</strong>라고 불리는 노드들로 구성된다. DOM 환경에서 <code class=\"language-text\">document.createElement('div')</code>를 했을 때 생성되는 객체(DOM 노드)와 흡사하다고 할 수 있다.</li>\n<li>호스트 객체는 <code class=\"language-text\">domNode.className</code> 혹은 <code class=\"language-text\">view.tintColor</code>와 같은 고유한 프로퍼티를 가지고 있으며, 다른 호스트 객체를 자식으로 가질 수도 있다.</li>\n<li>또한 DOM의 <code class=\"language-text\">appendChild</code>, <code class=\"language-text\">removeChild</code>와 같이, 호스트 객체를 조작할 수 있는 API도 존재한다. 일반적인 React 앱에선 (React가 대신 처리해 주기 때문에) 이러한 API를 호출할 일이 없을 것이다.</li>\n</ul>\n<h2 id=\"렌더러-renderers\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%9F%AC-renderers\" aria-label=\"렌더러 renderers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더러 (Renderers)</h2>\n<ul>\n<li><strong>렌더러</strong>는 React로 하여금 특정 호스트 환경과 소통하고, (해당 환경에 있는) 호스트 객체들을 관리하도록 한다. React DOM, React Native와 같은 것들이 렌더러이다. 또한 <a href=\"https://github.com/facebook/react/tree/main/packages/react-reconciler\">나만의 렌더러를 직접 만들 수도 있다.</a></li>\n<li>\n<p>React 렌더러에는 두 가지 동작 모드가 존재한다:</p>\n<ul>\n<li><strong>변경(mutating) 모드</strong>: 대부분의 렌더러들은 변경 모드를 사용하도록 만들어졌다. 이 모드는 DOM이 동작하는 방식인데, 노드를 만들 수 있고, 프로퍼티를 설정할 수 있고, 추후에 자식을 추가하거나 제거할 수도 있다. 호스트 객체들은 가변(mutable)이다.</li>\n<li><strong>지속(persistent) 모드:</strong>: 지속 모드는 <code class=\"language-text\">appendChild()</code>와 같은 메소드를 제공하지 않는 호스트 환경에서 동작하는 모드이다. 이 모드에선 부모의 트리를 복제하여 최상위 자식을 대체하는 방식으로 동작한다. 호스트 트리의 불변성 덕분에 멀티 스레딩을 쉽게할 수 있다. <a href=\"https://reactnative.dev/blog/2018/06/14/state-of-react-native-2018\">React Fabric</a>은 이를 활용한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"react-요소-react-element\" style=\"position:relative;\"><a href=\"#react-%EC%9A%94%EC%86%8C-react-element\" aria-label=\"react 요소 react element permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 요소 (React Element)</h2>\n<ul>\n<li>(DOM 노드와 같은) 호스트 객체는 호스트 환경에서 가장 작은 구성 요소이다. React에선 React 요소가 가장 작은 구성 요소이다.</li>\n<li>React 요소는 호스트 객체를 묘사할 수 있는 일반적인 자바스크립트 객체이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;button className=\"blue\" /></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>React 요소는 어떠한 호스트 객체와도 연관되지 않는다. 다시 말하지만, React 요소는 단순히 어떤 것이 화면에 그려졌으면 하는지에 대한 정보에 불과하다.</li>\n<li>또한 호스트 객체와 같이 React 요소도 트리 구조를 형성할 수 있다 (여기선 <a href=\"https://overreacted.io/why-do-react-elements-have-typeof-property/\">몇몇 프로퍼티</a>들이 생략되어 있다):</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;dialog></span>\n<span class=\"token comment\">//   &lt;button className=\"blue\" /></span>\n<span class=\"token comment\">//   &lt;button className=\"red\" /></span>\n<span class=\"token comment\">// &lt;/dialog></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'dialog'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'red'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>하지만, React 요소에는 영구적인 고유 ID가 존재하지 않는다. 이들은 매번 새로 만들어지고 버려진다.</li>\n<li>또, React 요소들은 불변(immutable)이기 때문에, 요소의 자식이나 프로퍼티 등을 변경할 수 없다. 만약 무언가 다른 것을 (화면에) 렌더링 하고 싶다면 새로운 React 요소를 생성해야 한다.</li>\n<li>React 요소를 영화의 프레임으로 생각하면 쉽다. 각 요소들은 특정 순간에 UI가 어떠한 모습이어야 하는지를 나타내고 있고, 변하지 않는다.</li>\n</ul>\n<h2 id=\"진입점-entry-point\" style=\"position:relative;\"><a href=\"#%EC%A7%84%EC%9E%85%EC%A0%90-entry-point\" aria-label=\"진입점 entry point permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진입점 (Entry Point)</h2>\n<ul>\n<li>각 React 렌더러에는 “진입점”이 존재한다. 진입점은 우리가 React로 하여금 어떤 React 요소 트리를 컨테이너 호스트 객체 내부에 렌더링 할 수 있게 해주는 API라고 할 수 있다.</li>\n<li>예를 들면, React DOM의 진입점은 <code class=\"language-text\">ReactDOM.render</code> 이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token comment\">// 아래의 JSX는 {type: 'button', props: {className: 'blue'}}를 나타낸 것이라 할 수 있다.</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">ReactDOM.render(reactElement, domContainer)</code>라고 하는 것은 “React님, <code class=\"language-text\">domContainer</code> 호스트 트리를 <code class=\"language-text\">reactElement</code>와 같게 해주세요”라고 하는 것과 같다.</li>\n<li>React는 요소의 타입 (<code class=\"language-text\">reactElement.type</code>, 위 예시에서는 <code class=\"language-text\">'button'</code>)을 보고, ReactDOM 렌더러에게 해당 타입에 맞는 호스트 객체를 생성하고 프로퍼티를 설정하도록 요청한다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// ReactDOM 렌더러 어딘가 (간략한 버전)</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">createHostInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reactElement</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>reactElement<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span></span><span class=\"gatsby-highlight-code-line\">  domNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> reactElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>className</span>  <span class=\"token keyword\">return</span> domNode\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// 현재 예시에 대해 React가 실질적으로 하는 동작은 다음과 같다:</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span></span><span class=\"gatsby-highlight-code-line\">domNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'blue'</span></span>\ndomContainer<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>domNode<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>만약 React 요소에 자식 요소가 존재한다면 (<code class=\"language-text\">reactElement.props.children</code>), React는 첫 번째 렌더링 때 재귀적으로 해당 자식 요소들을 생성한다.</li>\n</ul>\n<h2 id=\"재조정-reconciliation\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EC%A1%B0%EC%A0%95-reconciliation\" aria-label=\"재조정 reconciliation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재조정 (Reconciliation)</h2>\n<ul>\n<li>동일한 컨테이너에 대해 <code class=\"language-text\">ReactDOM.render()</code>를 두 번 호출하면 어떻게 될까?</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span></span>  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// ... 이후</span>\n\n<span class=\"token comment\">// 현재의 \"버튼\" 호스트 객체를 대체해야할 까, 아니면</span>\n<span class=\"token comment\">// 단순히 기존 호스트 객체의 프로퍼티를 업데이트 해야할까?</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>red<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span></span>  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>다시 말하자면, React의 역할은 호스트 트리와 현재 주어진 React 요소 트리를 같게 만드는 것이다. 새로운 정보를 바탕으로 호스트 객체에 어떤 작업을 해야 하는지를 알아내는 과정을 <a href=\"https://reactjs.org/docs/reconciliation.html\">reconciliation</a> 이라고 한다.</li>\n<li>재조정에는 두 가지 방법이 존재한다. 단순히 기존의 트리를 날려버리고 새로운 트리를 처음부터 다시 만드는 방법이 있을 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> domContainer <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// 트리 초기화</span>\ndomContainer<span class=\"token punctuation\">.</span>innerHTML <span class=\"token operator\">=</span> <span class=\"token string\">''</span>\n<span class=\"token comment\">// 새로운 호스트 트리를 생성</span>\n<span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'button'</span><span class=\"token punctuation\">)</span>\ndomNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span>\ndomContainer<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>domNode<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>하지만 DOM의 경우 위 방법은 느리다. 또한, 포커스, 선택, 스크롤 상태와 같은 정보들도 다 날아간다. 따라서 위 방법 대신 다음과 같은 방법을 사용할 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> domContainer<span class=\"token punctuation\">.</span>firstChild\n<span class=\"token comment\">// 기존에 존재하는 호스트 객체를 업데이트</span>\ndomNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> <span class=\"token string\">'red'</span></code></pre></div>\n<ul>\n<li>즉, React는 <em>언제</em> 기존의 호스트 객체를 업데이트 할지, 그리고 언제 새로운 객체를 생성할지 결정해야 한다. 하지만 이때, React 요소들은 매번 다른데 어떻게 같은 호스트 객체를 나타낸다는 것을 어떻게 알 수 있을까?</li>\n<li>위 예제에서는 간단하다. <code class=\"language-text\">&lt;button></code>을 첫 번째 자식으로 렌더링 했고, 똑같은 위치에 <code class=\"language-text\">&lt;button></code>을 다시 렌더링 하고 싶어 하므로, 기존에 존재하는 <code class=\"language-text\">&lt;button></code> 호스트 객체를 재사용하면 된다. 이는 React가 생각하는 방식과 흡사하다.</li>\n<li><strong>직전 렌더링과 다음 렌더링 사이에, 트리상에서 같은 위치에 있는 요소들의 타입이 같으면 React는 기존에 존재하는 호스트 객체를 재사용한다</strong>. 다음 예제를 살펴보자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// let domNode = document.createElement('button');</span>\n<span class=\"token comment\">// domNode.className = 'blue';</span>\n<span class=\"token comment\">// domContainer.appendChild(domNode);</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 호스트 객체를 재사용할 수 있다! (button → button)</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// domNode.className = 'red';</span></span>ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>red<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">// 호스트 객체를 재사용할 수 없다.. (button → p)</span></span><span class=\"token comment\">// domContainer.removeChild(domNode);</span>\n<span class=\"token comment\">// domNode = document.createElement('p');</span>\n<span class=\"token comment\">// domNode.textContent = 'Hello';</span>\n<span class=\"token comment\">// domContainer.appendChild(domNode);</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Hello</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 호스트 객체를 재사용할 수 있다! (p → p)</span>\n<span class=\"token comment\">// domNode.textContent = 'Goodbye';</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Goodbye</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>자식 트리에도 동일한 휴리스틱 알고리즘이 적용된다. 예를 들어, 두 개의 <code class=\"language-text\">&lt;button></code> 요소를 자식으로 가지는 <code class=\"language-text\">&lt;dialog></code> 요소를 업데이트할 때, React는 우선 부모 요소인 <code class=\"language-text\">&lt;dialog></code>를 재사용할 수 있는지 따져보고 그다음 이러한 과정을 자식 요소인 <code class=\"language-text\">&lt;button></code>에 대해서도 동일하게 진행한다.</li>\n</ul>\n<h2 id=\"조건-conditions\" style=\"position:relative;\"><a href=\"#%EC%A1%B0%EA%B1%B4-conditions\" aria-label=\"조건 conditions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>조건 (Conditions)</h2>\n<ul>\n<li>업데이트할 때, React가 같은 타입의 호스트 객체들만 재사용한다면 조건부 컨텐츠(특정 조건을 만족하는 경우 나타나는 컨텐츠?)에 대해선 어떻게 해야할까? 다음 예제와 같이, 처음에는 input만 보여줬다가 이후 메세지도 함께 보여준다고 하자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// First render</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>dialog<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>input <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dialog<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Next render</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>dialog<span class=\"token operator\">></span>\n<span class=\"gatsby-highlight-code-line\">    <span class=\"token operator\">&lt;</span>p<span class=\"token operator\">></span><span class=\"token constant\">I</span> was just added here<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>p<span class=\"token operator\">></span></span>    <span class=\"token operator\">&lt;</span>input <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>dialog<span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>위 예제에서 <code class=\"language-text\">&lt;input></code> 호스트 객체는 다시 생성될 것이다. React가 이전 버전의 트리와 비교하는 과정을 다음처럼 나타낼 수 있다:</p>\n<ul>\n<li><code class=\"language-text\">dialog → dialog</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n<li><code class=\"language-text\">input → p</code>: 요소의 타입이 변경되었으므로 재사용 불가능. 기존의 <code class=\"language-text\">input</code> 객체를 제거하고 새로운 <code class=\"language-text\">p</code> 호스트 객체를 생성해야함.</li>\n<li><code class=\"language-text\">(noting) → input</code>: 새로운 <code class=\"language-text\">input</code> 객체를 생성해야함.</li>\n</ul>\n</li>\n<li>따라서, 실질적으로 React가 수행한 업데이트 코드는 다음과 같을 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> oldInputNode <span class=\"token operator\">=</span> dialogNode<span class=\"token punctuation\">.</span>firstChild</span><span class=\"gatsby-highlight-code-line\">dialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">removeChild</span><span class=\"token punctuation\">(</span>oldInputNode<span class=\"token punctuation\">)</span></span>\n<span class=\"token keyword\">let</span> pNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span>\npNode<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'I was just added here!'</span>\ndialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>pNode<span class=\"token punctuation\">)</span>\n\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">let</span> newInputNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'input'</span><span class=\"token punctuation\">)</span></span><span class=\"gatsby-highlight-code-line\">dialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">appendChild</span><span class=\"token punctuation\">(</span>newInputNode<span class=\"token punctuation\">)</span></span></code></pre></div>\n<ul>\n<li>하지만 생각해 보면, <code class=\"language-text\">&lt;input></code>이 <code class=\"language-text\">&lt;p></code>로 바뀐 것이 아니라 단순히 이동된 것이므로 위와 같은 동작은 뭔가 아쉽다. 또, 이렇게 하면 포커스, 선택, 입력한 내용들도 다 날아가버린다.</li>\n<li>사실 이 문제엔 (곧 살펴볼) 간단한 해결책이 존재한다. 하지만 위와 같은 상황이 그리 자주 발생하지는 않는다. 왜냐면, 실제로는 <code class=\"language-text\">ReactDOM.render</code>를 직접 호출할 일이 거의 없기 때문이다. 대신, React 앱들은 주로 다음과 같이 함수들로 나뉘게 된다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> showMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">I was just added here!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dialog</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dialog</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>이 예제에선 방금 살펴본 문제가 발생하지 않는다. 왜 그런지는 다음과 같이 JSX를 객체 형태로 표시하면 더 쉽게 확인할 수 있다. <code class=\"language-text\">dialog</code>의 자식 트리를 살펴보자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> showMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'p'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> children<span class=\"token operator\">:</span> <span class=\"token string\">'I was just added here!'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">{</span>\n    type<span class=\"token operator\">:</span> <span class=\"token string\">'dialog'</span><span class=\"token punctuation\">,</span>\n    props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">      children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>message<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> type<span class=\"token operator\">:</span> <span class=\"token string\">'input'</span><span class=\"token punctuation\">,</span> props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token punctuation\">}</span></span></code></pre></div>\n<ul>\n<li>\n<p>여기서, <code class=\"language-text\">showMessage</code>가 <code class=\"language-text\">true</code>이건 <code class=\"language-text\">false</code>이건 상관없이 <code class=\"language-text\">&lt;input></code>은 항상 <code class=\"language-text\">&lt;dialog></code>의 두 번째 자식이므로 그 위치가 변하지 않는다. <code class=\"language-text\">showMessage</code>가 <code class=\"language-text\">false</code>에서 <code class=\"language-text\">true</code>로 바뀌면 React는 다음과 같이 이전 버전과 비교할 것이다:</p>\n<ul>\n<li><code class=\"language-text\">dialog → dialog</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n<li><code class=\"language-text\">(null) → p</code>: 새로운 <code class=\"language-text\">p</code> 호스트 객체를 추가해야함.</li>\n<li><code class=\"language-text\">input → input</code>: 요소의 타입이 일치하므로 호스트 객체 재사용 가능.</li>\n</ul>\n</li>\n<li>따라서, 실질적으로 React가 수행한 업데이트 코드는 다음과 같을 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// \"input\"의 상태가 그대로 유지된다!</span>\n<span class=\"token keyword\">let</span> inputNode <span class=\"token operator\">=</span> dialogNode<span class=\"token punctuation\">.</span>firstChild\n<span class=\"token keyword\">let</span> pNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token string\">'p'</span><span class=\"token punctuation\">)</span>\npNode<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'I was just added here!'</span>\ndialogNode<span class=\"token punctuation\">.</span><span class=\"token function\">insertBefore</span><span class=\"token punctuation\">(</span>pNode<span class=\"token punctuation\">,</span> inputNode<span class=\"token punctuation\">)</span></code></pre></div>\n<h2 id=\"리스트-lists\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EC%8A%A4%ED%8A%B8-lists\" aria-label=\"리스트 lists permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리스트 (Lists)</h2>\n<ul>\n<li>일반적으로, 트리에서 동일한 위치에 존재하는 호스팅 객체를 재사용할지 새로 생성할지 결정하는 데엔 요소의 타입을 비교하는 것으로 충분하다. 하지만 이는 자식들의 위치가 변하지않고(static), 자식들 간의 순서가 바뀌지 않는 경우에만 유효하다. 앞선 예제에선 <code class=\"language-text\">message</code>가 “구멍(null)“이 된다고 해도 우리는 여전히 <code class=\"language-text\">input</code>이 <code class=\"language-text\">message</code> 바로 다음에 위치하고 있음을 알 수 있다.</li>\n<li>하지만 동적 리스트의 경우 그 순서가 항상 같을 거라고 예측할 수 없다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">ShoppingList</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> list <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n          You bought </span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n          Enter how many do you want: </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>위 예제의 <code class=\"language-text\">list</code>가 재정렬 되어도 같은 위치에 있는 <code class=\"language-text\">p</code>와 <code class=\"language-text\">input</code> 요소들이 같은 타입이므로 이 요소들을 이동시키지 않을 것이다. 즉, React의 관점에서 보자면 “요소들 자체”(요소의 내용)가 변경된 것이지 이들의 “위치”가 변경된 것이 아니다. 10개의 항목을 재정렬 하기 위해 React가 실행한 코드는 다음과 유사할 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pNode <span class=\"token operator\">=</span> formNode<span class=\"token punctuation\">.</span>childNodes<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n  <span class=\"token keyword\">let</span> textNode <span class=\"token operator\">=</span> pNode<span class=\"token punctuation\">.</span>firstChild\n  textNode<span class=\"token punctuation\">.</span>textContent <span class=\"token operator\">=</span> <span class=\"token string\">'You bought '</span> <span class=\"token operator\">+</span> items<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span>name\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>즉, React는 항목들의 순서를 변경한 것이 아니라 각 항목들을 업데이트하였다. 이러한 문제는 성능 이슈와 버그를 야기할 수 있는데, 예를 들어 첫 번째 항목의 <code class=\"language-text\">input</code>은 재정렬 이후에도 계속해서 첫 번째 항목의 <code class=\"language-text\">input</code>으로 남아있게 된다. 실제로는 다른 항목을 나타내는 것임에도 말이다! <a href=\"https://codesandbox.io/s/react-no-key-in-list-example-hf9yw?file=/src/index.js\">예제</a></li>\n<li>이것이 바로 배열 요소에 대해 React가 <code class=\"language-text\">key</code> 프로퍼티를 요구하는 이유이다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">ShoppingList</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> list <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">      </span><span class=\"token punctuation\">{</span>list<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">item</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n<span class=\"gatsby-highlight-code-line\">        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>productId<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">          You bought </span><span class=\"token punctuation\">{</span>item<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>br</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">          Enter how many do you want: </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>form</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">key</code>는 React로 하여금 렌더링 시에 부모 요소 내에서 해당 항목의 위치가 변경되어도 같은 요소로 간주하도록 한다. React가 <code class=\"language-text\">&lt;form></code> 내부에 있는 <code class=\"language-text\">&lt;p key=\"42\"></code> 요소를 보게 되면 직전 렌더링에서도 <code class=\"language-text\">&lt;form></code> 내부에 <code class=\"language-text\">&lt;p key=\"42\"></code>가 있었는지 살펴볼 것이다. <code class=\"language-text\">&lt;form></code>의 자식 요소들 간의 순서가 바뀌었다고 해도 정상적으로 동작하는데, React는 같은 <code class=\"language-text\">key</code>를 가지는 직전의 호스트 객체를 재사용하고 요소들의 순서를 알맞게 정렬할 것이다.</li>\n<li>이때 React는 서로 다른 부모 요소 사이에서 <code class=\"language-text\">key</code>를 비교하지 않는다. <code class=\"language-text\">key</code>는 위 예제에서의 <code class=\"language-text\">&lt;form></code>과 같이 오직 동일한 부모 요소에만 관련이 있다.</li>\n<li>그리고 <code class=\"language-text\">key</code> 프로퍼티의 값으로는 <strong>순서가 바뀌어도 동일한 항목임을 나타낼 수 있는</strong>, 즉 항목을 식별할 수 있는 고유한 값이 적절하다. <a href=\"https://codesandbox.io/s/react-list-with-proper-key-prop-example-evztx?file=/src/index.js\">예제</a></li>\n</ul>\n<h2 id=\"컴포넌트-components\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-components\" aria-label=\"컴포넌트 components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴포넌트 (Components)</h2>\n<ul>\n<li>이미 우리는 React 요소를 반환하는 함수를 본 적이 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> showMessage <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> message <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>showMessage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">I was just added here!</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>dialog</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>input</span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>dialog</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>이러한 함수를 <strong>컴포넌트</strong>라고 부르는데, 컴포넌트는 우리만의 버튼, 아바타, 댓글 등을 관리하는 도구 상자(toolbox)를 만들 수 있게 해준다.</li>\n<li>컴포넌트는 “해쉬 객체” 하나만을 인자로 갖는다. 이 해쉬 객체에는 <code class=\"language-text\">prop</code>이 존재한다. 위 예제에서 <code class=\"language-text\">showMessage</code>가 prop인데, 여기선 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#object_destructuring\">Object destructuring</a>이 사용되었다.</li>\n</ul>\n<h2 id=\"순수성purity\" style=\"position:relative;\"><a href=\"#%EC%88%9C%EC%88%98%EC%84%B1purity\" aria-label=\"순수성purity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>순수성(Purity)</h2>\n<ul>\n<li>React 컴포넌트는 전달받은 <code class=\"language-text\">prop</code>에 대해 <em>순수</em>하다고 여겨진다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Button</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 🔴 동작하지 않음!</span>\n  props<span class=\"token punctuation\">.</span>isActive <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>일반적으로 React에선 mutation이 자연스럽지 않다 (이벤트에 반응하여 UI를 자연스럽게 바꾸는 방법은 추후에 살펴보자).</li>\n<li>하지만 local mutation은 괜찮다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">FriendList</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> friends <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">let</span> items <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></span>  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> friends<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> friend <span class=\"token operator\">=</span> friends<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n<span class=\"gatsby-highlight-code-line\">    items<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Friend</span></span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">friend</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>friend<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span></span>  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>section</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>items<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>section</span><span class=\"token punctuation\">></span></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>여기선 렌더링 중에 <code class=\"language-text\">items</code>를 만들었지만 다른 어떠한 컴포넌트도 이 변수를 참조하지 않고 있기 때문에 렌더링 결과를 만들기 전까지 처리하는 과정에서 얼마든지 변형시킬 수 있다. Local mutation을 굳이 피할 이유는 없다.</li>\n<li>비슷한 맥락으로, lazy initialization 또한 (완전히 “순수” 하지는 않지만) 괜찮다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">ExpenseForm</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 다른 컴포넌트에 영향을 주지 않는다면 괜찮다:</span>\n  SuperCalculator<span class=\"token punctuation\">.</span><span class=\"token function\">initializeIfNotReady</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\">// 계속해서 렌더링...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>한 컴포넌트를 여러 번 호출하는 것이 안전하고 다른 컴포넌트의 렌더링에 영향을 미치지 않는 한, 해당 컴포넌트가 엄격한 FP의 관점에서 100% “순수” 하지는 않더라도 React는 별다른 신경을 쓰지 않는다. React에선 <a href=\"https://stackoverflow.com/questions/1077412/what-is-an-idempotent-operation\">멱등성(Idempotent)</a>이 순수성 보다 더 중요하다.</li>\n<li>다시 말해, 사용자에게 직접적으로 보여지는 side effect는 React 컴포넌트에서 허용되지 않는다. 즉, 함수 컴포넌트를 단순히 호출만 했을 때 화면에 어떤 변화가 발생하면 안 된다는 뜻이다.</li>\n</ul>\n<h2 id=\"재귀-recursion\" style=\"position:relative;\"><a href=\"#%EC%9E%AC%EA%B7%80-recursion\" aria-label=\"재귀 recursion permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>재귀 (Recursion)</h2>\n<ul>\n<li>컴포넌트는 그냥 “함수”이므로, 해당 함수 컴포넌트를 호출함으로써 한 컴포넌트들 다른 컴포넌트에서 사용할 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> reactElement <span class=\"token operator\">=</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> showMessage<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>reactElement<span class=\"token punctuation\">,</span> domContainer<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>하지만 이는 React 런타임에서 자연스러운 방법이 아니다. 대신 우리가 여태껏 본 것과 같이, 컴포넌트를 React 요소를 사용하는 방법처럼 사용하는 것이 더 자연스러운 방법이다. 다시 말해 <strong>함수 (컴포넌트)를 직접 호출하지 않고, React가 알아서 대신 호출하도록 하는 것이다</strong>:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// { type: Form, props: { showMessage: true } }</span>\n<span class=\"token keyword\">let</span> reactElement <span class=\"token operator\">=</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Form</span></span> <span class=\"token attr-name\">showMessage</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>reactElement<span class=\"token punctuation\">,</span> domContainer<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// React 어딘가에서 해당 컴포넌트가 호출될 것이다</span>\n<span class=\"token keyword\">let</span> type <span class=\"token operator\">=</span> reactElement<span class=\"token punctuation\">.</span>type <span class=\"token comment\">// Form</span>\n<span class=\"token keyword\">let</span> props <span class=\"token operator\">=</span> reactElement<span class=\"token punctuation\">.</span>props <span class=\"token comment\">// { showMessage: true }</span>\n<span class=\"token keyword\">let</span> result <span class=\"token operator\">=</span> <span class=\"token function\">type</span><span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Whatever Form returns</span></code></pre></div>\n<ul>\n<li>함수 컴포넌트의 이름은 항상 대문자로 시작한다. JSX를 번역할 때, <code class=\"language-text\">&lt;form></code> 대신 <code class=\"language-text\">&lt;Form></code>을 보게 되면 해당 객체의 타입을 문자열이 아니라 식별자로 본다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>form</span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 'form' string</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Form</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span> <span class=\"token comment\">// Form function</span></code></pre></div>\n<ul>\n<li>(컴포넌트가) 전역으로 등록되는 메커니즘 같은 건 없다. 단순히 컴포넌트의 이름을 통해 참조하는 것이다. 만약 컴포넌트가 로컬 스코프에 없다면 일반적인 자바스크립트에서 변수를 잘못 참조한 경우와 같이 에러를 보게 될 것이다.</li>\n<li>그렇다면 요소의 타입이 함수일 때 React는 어떤 일을 할까? <strong>React 요소의 타입이 함수인 경우, React는 해당 컴포넌트를 호출하여 컴포넌트가 렌더링하고자 하는 요소들이 무엇인지 알아낸다.</strong></li>\n<li>\n<p>이러한 과정은 재귀적으로 이어지며, <a href=\"https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html\">여기</a>에 더 자세히 나와있다. 요약하자면 다음과 비슷하다:</p>\n<ul>\n<li><strong>나</strong>: <code class=\"language-text\">ReactDOM.render(&lt;App />, domContainer)</code></li>\n<li><strong>React</strong>: 안녕 <code class=\"language-text\">App</code>! 무엇을 렌더링하고 싶니?</li>\n<li><code class=\"language-text\">App</code>: 나는 <code class=\"language-text\">&lt;Layout></code>안에 <code class=\"language-text\">&lt;Content></code>를 그려.</li>\n<li><strong>React</strong>: 안녕 <code class=\"language-text\">Layout</code>! 무엇을 렌더링하고 싶니?</li>\n<li><code class=\"language-text\">Layout</code>: 나는 내 자식들을 <code class=\"language-text\">&lt;div></code> 안에다 그릴거야. 내 자식이 <code class=\"language-text\">&lt;Content></code>니까 이게 <code class=\"language-text\">&lt;div></code> 안에 들어갈 것 같아.</li>\n<li><strong>React</strong>: 안녕 <code class=\"language-text\">Content</code>! 무엇을 렌더링하고 싶니?</li>\n<li><code class=\"language-text\">Content</code>: 나는 텍스트와 <code class=\"language-text\">&lt;Footer></code>를 <code class=\"language-text\">&lt;article></code> 안에 그려.</li>\n<li><strong>React</strong>: 안녕 <code class=\"language-text\">Footer</code>! 무엇을 렌더링하고 싶니?</li>\n<li><code class=\"language-text\">Footer</code>: 나는 <code class=\"language-text\">&lt;footer></code> 안에 텍스트를 적고 싶어.</li>\n<li><strong>React</strong>: 좋아. 여기있어:</li>\n</ul>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"html\"><pre class=\"language-html\"><code class=\"language-html\">// 결과:\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>article</span><span class=\"token punctuation\">></span></span>\n    Some text\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>footer</span><span class=\"token punctuation\">></span></span>some more text<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>footer</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>article</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>이것이 우리가 앞에서 재조정(reconciliation) 과정이 재귀적이라고 했던 이유이다. React가 요소 트리를 순회하는 과정에서 타입이 컴포넌트인 요소를 만나게 되면 해당 컴포넌트를 호출하고, 컴포넌트에서 반환된 요소들을 타고 내려가 계속해서 순회를 이어나간다. 결국 더 이상 순회할 요소가 없게 되면 React는 호스트 트리를 어떻게 변경해야 할지 알게 된다.</li>\n</ul>\n<h2 id=\"제어의-역전-inversion-of-control\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84-inversion-of-control\" aria-label=\"제어의 역전 inversion of control permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제어의 역전 (Inversion of Control)</h2>\n<ul>\n<li><code class=\"language-text\">Form()</code> 대신 <code class=\"language-text\">&lt;Form/></code>이라고 쓰는 것처럼, 왜 컴포넌트를 직접 호출하지 않는지에 대해 궁금할 수도 있을 것이다. 그 이유는, <strong>재귀적으로 (직접) 호출한 React 요소를 보는 것보다 React 스스로가 컴포넌트들에 대해 알고 있으면 React가 해야 할 작업을 더 잘 수행할 수 있기 때문이다.</strong></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// 🔴 (사용자가) 컴포넌트를 직접 호출하게되면 React로선</span>\n<span class=\"token comment\">// \"Layout\"과 \"Article\"이 존재하는지 알 수 없다.</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token function\">Layout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> children<span class=\"token operator\">:</span> <span class=\"token function\">Article</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// ✅ 반면, React가 컴포넌트를 호출하면 </span>\n<span class=\"token comment\">// \"Layout\"과 \"Article\"이 존재하는지 알 수 있다!</span>\nReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Article</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">,</span>\n  domContainer\n<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>\n<p>이는 <a href=\"https://en.wikipedia.org/wiki/Inversion_of_control\">제어의 역전</a>의 대표적인 예시이다. 또한, React가 컴포넌트 호출 제어권을 가지게 함으로써 생기는 몇 가지 흥미로운 이점들이 있다:</p>\n<ul>\n<li><strong>컴포넌트는 함수 이상의 역할을 하게 된다</strong>: React는 지역 상태와 같은 기능들을 컴포넌트와 묶을 수 있게 된다. 앞서 살펴본 것처럼 React는 이벤트에 응답하는 UI 트리를 생성하는데, 컴포넌트를 (React 대신) 직접 호출하면 부가적인 기능들을 직접 구현해야 한다.</li>\n<li><strong>컴포넌트 타입으로 재조정을 한다</strong>: React가 컴포넌트를 호출하게 되면 React는 트리의 구조를 더욱 많이 알게 된다. 예를 들어 <code class=\"language-text\">&lt;Feed></code> 페이지에서 <code class=\"language-text\">&lt;Profile></code> 페이지로 이동하면 React는 (<code class=\"language-text\">&lt;button></code>을 <code class=\"language-text\">&lt;p></code>로 바꾸는 것처럼) 해당 요소의 호스트 객체를 재사용하지 않는다. 이렇듯 다른 view를 렌더링 하는 경우엔 이와 같이 (기존의) 모든 상태를 날려버리는 것이 바람직하다. <code class=\"language-text\">&lt;input></code> 요소가 우연히 트리상에서 같은 위치에 존재한다고 하더라도 <code class=\"language-text\">&lt;PasswordFrom></code>과 <code class=\"language-text\">&lt;MessengerChat></code>간에 입력 상태를 유지하고 싶지는 않을 것이다.</li>\n<li><strong>React가 재조정을 지연할 수 있다</strong>: React가 컴포넌트 호출 제어권을 가지면 여러 가지 흥미로운 것들을 할 수 있다. 예를 들면, 거대한 컴포넌트를 리렌더링 하는 것이 <a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">메인 스레드를 blocking 하지 않도록</a> 컴포넌트 호출 사이에 브라우저로 하여금 일부 작업을 더 하도록 할 수 있다. React를 뜯어고치지 않고선 이 작업을 수동으로 하는 것은 쉽지 않을 것이다.</li>\n<li><strong>더 나은 디버깅</strong>: 컴포넌트가 React가 인지하고 있는 일급 객체라면 <a href=\"https://github.com/facebook/react-devtools\">풍부한 디버깅 도구</a>들을 만들 수 있게 된다.</li>\n</ul>\n</li>\n<li>마지막 이점은 <strong>지연 평가(lazy evaluation)</strong>에 관한 것이다. 다음 섹션에서 살펴보자.</li>\n</ul>\n<h2 id=\"지연-평가-lazy-evaluation\" style=\"position:relative;\"><a href=\"#%EC%A7%80%EC%97%B0-%ED%8F%89%EA%B0%80-lazy-evaluation\" aria-label=\"지연 평가 lazy evaluation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>지연 평가 (Lazy Evaluation)</h2>\n<ul>\n<li>자바스크립트에서 함수를 호출할 때, 함수에 전달되는 인자들은 호출 전에 평가된다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// (2) 나중에 계산됨</span>\n<span class=\"token function\">eat</span><span class=\"token punctuation\">(</span>\n  <span class=\"token comment\">// (1) 먼저 계산됨</span>\n  <span class=\"token function\">prepareMeal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>자바스크립트 함수가 암묵적으로 side effect를 가질 수 있기 때문에 이는 대개 자바스크립트 개발자들이 생각하는 방식이다. 함수를 직접 호출했다면 (예상치 못한 문제로) 놀랄 수도 있겠지만, 자바스크립트 어딘가에서 결과가 사용될 때까지 실행되지 않는다.</li>\n<li>하지만 React 컴포넌트는 상대적으로 순수하다. 컴포넌트의 (반환) 결과가 화면에 렌더링 되지 않는다는 것을 알고 있다면, 이를 실행할 필요가 없다.</li>\n<li>다음의 예제를 살펴보자:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Story</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> currentUser <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// return {</span>\n  <span class=\"token comment\">//   type: Page,</span>\n  <span class=\"token comment\">//   props: {</span>\n  <span class=\"token comment\">//     user: currentUser,</span>\n  <span class=\"token comment\">//     children: { type: Comments, props: {} }</span>\n  <span class=\"token comment\">//   }</span>\n  <span class=\"token comment\">// }</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Page</span></span> <span class=\"token attr-name\">user</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>currentUser<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Page</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>여기서 <code class=\"language-text\">&lt;Page></code> 컴포넌트는 넘겨받은 <code class=\"language-text\">children</code>을 <code class=\"language-text\">Layout</code> 내부에 사용할 수 있다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Page</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> children <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>(JSX에서 <code class=\"language-text\">&lt;A>&lt;B />&lt;/A></code>와 <code class=\"language-text\">&lt;A children={&lt;B /} /></code>는\n똑같다.)</p>\n<ul>\n<li>하지만 특정 조건에 의해 일찍 반환된다면 어떨까?</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Page</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> user<span class=\"token punctuation\">,</span> children <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>user<span class=\"token punctuation\">.</span>isLoggedIn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Please log in</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token punctuation\">}</span></span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">      </span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Layout</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>만약 <code class=\"language-text\">Comments()</code>와 같이 우리가 직접 <code class=\"language-text\">Comments</code>를 호출했다면 <code class=\"language-text\">Page</code>의 렌더링 여부에 관계없이 무조건 <code class=\"language-text\">Comments</code> 컴포넌트를 실행할 것이다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// {</span>\n<span class=\"token comment\">//   type: Page,</span>\n<span class=\"token comment\">//   props: {</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">//     children: Comments() // 무조건 실행된다!</span></span><span class=\"token comment\">//   }</span>\n<span class=\"token comment\">// }</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Page</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">  </span><span class=\"token punctuation\">{</span><span class=\"token function\">Comments</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Page</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>하지만 <code class=\"language-text\">&lt;Comments /></code>와 같이 React 요소를 넘기게 되면 <code class=\"language-text\">Comments</code>를 실행하지 않는다:</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token comment\">// {</span>\n<span class=\"token comment\">//   type: Page,</span>\n<span class=\"token comment\">//   props: {</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token comment\">//     children: { type: Comments }</span></span><span class=\"token comment\">//   }</span>\n<span class=\"token comment\">// }</span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Page</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">  </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Comments</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\"></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span><span class=\"token class-name\">Page</span></span><span class=\"token punctuation\">></span></span></code></pre></div>\n<ul>\n<li>(React가 컴포넌트를 호출함으로써) React는 컴포넌트를 호출할지 말 지 결정할 수 있다. <code class=\"language-text\">Page</code> 컴포넌트가 <code class=\"language-text\">children</code> prop 대신 <code class=\"language-text\">&lt;h1>Please log in&lt;/h1></code>을 렌더링한다면 React는 (<code class=\"language-text\">children</code> prop으로 넘어온) <code class=\"language-text\">&lt;Comments></code> 함수를 실행하지 않는다.</li>\n<li>요점은, 이렇게 함으로써 불필요한 렌더링을 줄일 수 있게 되고 또한 코드의 취약성을 줄일 수 있게 된다는 것이다.</li>\n</ul>\n<h2 id=\"상태-state\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%83%9C-state\" aria-label=\"상태 state permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상태 (State)</h2>\n<ul>\n<li>호스트 객체는 포커스, 선택, 입력과 같은 모든 종류의 지역 상태를 가질 수 있다. 우리는 동일한 UI를 업데이트할 때 이러한 지역 상태들을 유지하고자 하고, (<code class=\"language-text\">&lt;SignupForm></code>에서 <code class=\"language-text\">&lt;MessengerChat></code>으로 이동하는 것과 같이) 다른 UI로 변경할 때 상태들을 (예측대로) 날려버리길 원한다.</li>\n<li>React 컴포넌트는 자체적으로 이렇게나 유용한 지역 상태를 가질 수 있다. 컴포넌트는 본질적으로 일반적인 함수이지만, React를 통해 UI에 유용한 상태들을 컴포넌트와 결합할 수 있다.</li>\n<li>우리는 이것을 <strong>훅(Hooks)</strong> 이라고 부른다. 예를 들면, <code class=\"language-text\">useState</code>는 hook이다.</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Example</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">You clicked </span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token plain-text\"> times</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>p</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"gatsby-highlight-code-line\"><span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span></span><span class=\"token plain-text\">        Click me</span>\n<span class=\"token plain-text\">      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\"></span>\n<span class=\"token plain-text\">    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">useState</code>는 현재 상태와 상태를 업데이트 하는 함수로 구성된 쌍(pair)를 반환한다. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#array_destructuring\">Array destructuring</a>을 통해 <code class=\"language-text\">useState</code>가 반환하는 상태와 업데이트 함수의 이름을 지정할 수 있다.</li>\n<li><code class=\"language-text\">useState</code>를 비롯한 다른 여러가지 hook들은 <a href=\"https://reactjs.org/docs/hooks-intro.html\">React 공식 문서</a>에서 더 자세히 살펴볼 수 있다.</li>\n</ul>\n<h2 id=\"일관성-consistency\" style=\"position:relative;\"><a href=\"#%EC%9D%BC%EA%B4%80%EC%84%B1-consistency\" aria-label=\"일관성 consistency permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>일관성 (Consistency)</h2>\n<ul>\n<li>재조정 과정을 <a href=\"https://www.youtube.com/watch?v=mDdgfyRB5kg\">non-blocking</a>한 작업들로 분할하여 수행한다고 하더라도, 여전히 단일 동기 흐름(single synchronous swoop)에 호스트 트리 연산을 수행해야만 한다. 이렇게 하면 사용자가 만들어지다 만 UI를 안 볼 수 있게끔 할 수 있고, 사용자가 볼 필요 없는 (어떤 UI를 완성하는 과정의) 중간 상태에 대한 불필요한 레이아웃 작업과 스타일 계산을 수행하지 않아도 된다.</li>\n<li>이러한 이유로, React는 모든 작업을 “렌더링 단계”와 “커밋 단계”로 나눈다. <strong>렌더링 단계</strong>에선 React가 컴포넌트를 호출하여 재조정을 수행하는데, 단계 중간에 방해를 받아도 안전하고 <a href=\"https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html\">추후엔</a> 비동기적으로 수행될 예정이다. <strong>커밋 단계</strong>는 React가 호스트 트리를 조작하는 단계로, 항상 동기적으로 수행된다.</li>\n</ul>","frontmatter":{"title":"UI 런타임으로서의 React","date":"December 22, 2021","category":"react"}}},"pageContext":{"slug":"/react/react-as-a-ui-runtime/","previous":{"fields":{"slug":"/architecture/refactoring-list-1/"},"frontmatter":{"title":"리팩토링 방법들 Part.1"}},"next":null}},"staticQueryHashes":[]}