{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-as-a-ui-runtime/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"0553134f-feb3-542d-afb1-5215bbde1876","excerpt":"이 포스트는 React as a UI Runtime를 번역/요약한 글입니다. 호스트 트리 (Host Tree) 각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다. React 프로그램은 시간에 따라 변할 수도 있는 트리를 출력한다. 이 트리를 “호스트 트리” 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 외부 호스트 환경의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API…","html":"<p>이 포스트는 <a href=\"https://overreacted.io/react-as-a-ui-runtime/\">React as a UI Runtime</a>를 번역/요약한 글입니다.</p>\n<hr class=\"custom-hr\">\n<h2 id=\"호스트-트리-host-tree\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%ED%8A%B8%EB%A6%AC-host-tree\" aria-label=\"호스트 트리 host tree permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 트리 (Host Tree)</h2>\n<ul>\n<li>각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다.</li>\n<li>React 프로그램은 시간에 따라 변할 수도 있는 <strong>트리</strong>를 출력한다. 이 트리를 <strong>“호스트 트리”</strong> 라고 하는데, 이는 이 트리가 React의 일부가 아니라 DOM과 같이 <em>외부 호스트 환경</em>의 일부이기 때문이다. 호스트 트리는 자체적인 명령형(imperative) API가 있고, React는 그 위에 존재하는 레이어이다.</li>\n<li>매우 추상적으로 말하자면, React는 외부 상호작용·네트워크 응답·타이머와 같은 외부 이벤트에 대해 반응하는 복잡한 호스트 트리를 예측 가능한 방식으로 조작할 수 있는 프로그램을 만드는 데 도움을 준다.</li>\n<li>\n<p>React는 다음의 두 원칙에 근거하고 있다:</p>\n<ul>\n<li><strong>안정성</strong>: 호스트 트리는 비교적 안정적이며, 대부분의 업데이트는 트리 전체의 구조를 뜯어고치진 않는다. 만약 모든 상호작용하는 요소들이 매 순간 완전히 바뀌게 된다면 “아니, 버튼이 어디로 간 거야?” 혹은, “화면이 왜 이래?”와 같이 앱을 사용하기 어려울 것이다.</li>\n<li><strong>규칙성</strong>: 호스트 트리는 무작위 형태가 아닌, 일관된 모습과 동작을 지닌 (버튼, 리스트, 아바타와 같은) UI 패턴 으로 나눌 수 있다.</li>\n</ul>\n</li>\n<li>이러한 원칙들은 대부분의 UI에 해당하지만, <a href=\"https://www.youtube.com/watch?v=Uzx9ArZ7MUU\">3D 파이프 스크린 세이버</a>와 같이 일정한 “패턴”이 없는 경우엔 별 도움이 안 된다.</li>\n</ul>\n<h2 id=\"호스트-객체-host-instances\" style=\"position:relative;\"><a href=\"#%ED%98%B8%EC%8A%A4%ED%8A%B8-%EA%B0%9D%EC%B2%B4-host-instances\" aria-label=\"호스트 객체 host instances permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>호스트 객체 (Host Instances)</h2>\n<ul>\n<li>호스트 트리는 <strong>호스트 객체</strong>라고 불리는 노드들로 구성된다. DOM 환경에서 <code class=\"language-text\">document.createElement('div')</code>를 했을 때 생성되는 객체(DOM 노드)와 흡사하다고 할 수 있다.</li>\n<li>호스트 객체는 <code class=\"language-text\">domNode.className</code> 혹은 <code class=\"language-text\">view.tintColor</code>와 같은 고유한 프로퍼티를 가지고 있으며, 다른 호스트 객체를 자식으로 가질 수도 있다.</li>\n<li>또한 DOM의 <code class=\"language-text\">appendChild</code>, <code class=\"language-text\">removeChild</code>와 같이, 호스트 객체를 조작할 수 있는 API도 존재한다. 일반적인 React 앱에선 (React가 대신 처리해 주기 때문에) 이러한 API를 호출할 일이 없을 것이다.</li>\n</ul>\n<h2 id=\"렌더러-renderers\" style=\"position:relative;\"><a href=\"#%EB%A0%8C%EB%8D%94%EB%9F%AC-renderers\" aria-label=\"렌더러 renderers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렌더러 (Renderers)</h2>\n<ul>\n<li><strong>렌더러</strong>는 React로 하여금 특정 호스트 환경과 소통하고, (해당 환경에 있는) 호스트 객체들을 관리하도록 한다. React DOM, React Native와 같은 것들이 렌더러이다. 또한 <a href=\"https://github.com/facebook/react/tree/main/packages/react-reconciler\">나만의 렌더러를 직접 만들 수도 있다.</a></li>\n<li>\n<p>React 렌더러에는 두 가지 동작 모드가 존재한다:</p>\n<ul>\n<li><strong>변경(mutating) 모드</strong>: 대부분의 렌더러들은 변경 모드를 사용하도록 만들어졌다. 이 모드는 DOM이 동작하는 방식인데, 노드를 만들 수 있고, 프로퍼티를 설정할 수 있고, 추후에 자식을 추가하거나 제거할 수도 있다. 호스트 객체들은 가변(mutable)이다.</li>\n<li><strong>지속(persistent) 모드:</strong>: 지속 모드는 <code class=\"language-text\">appendChild()</code>와 같은 메소드를 제공하지 않는 호스트 환경에서 동작하는 모드이다. 이 모드에선 부모의 트리를 복제하여 최상위 자식을 대체하는 방식으로 동작한다. 호스트 트리의 불변성 덕분에 멀티 스레딩을 쉽게할 수 있다. <a href=\"https://reactnative.dev/blog/2018/06/14/state-of-react-native-2018\">React Fabric</a>은 이를 활용한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"react-요소-react-element\" style=\"position:relative;\"><a href=\"#react-%EC%9A%94%EC%86%8C-react-element\" aria-label=\"react 요소 react element permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React 요소 (React Element)</h2>\n<ul>\n<li>(DOM 노드와 같은) 호스트 객체는 호스트 환경에서 가장 작은 구성 요소이다. React에선 React 요소가 가장 작은 구성 요소이다.</li>\n<li>React 요소는 호스트 객체를 묘사할 수 있는 일반적인 자바스크립트 객체이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;button className=\"blue\" /></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>React 요소는 어떠한 호스트 객체와도 연관되지 않는다. 다시 말하지만, React 요소는 단순히 어떤 것이 화면에 그려졌으면 하는지에 대한 정보에 불과하다.</li>\n<li>또한 호스트 객체와 같이 React 요소도 트리 구조를 형성할 수 있다 (여기선 <a href=\"https://overreacted.io/why-do-react-elements-have-typeof-property/\">몇몇 프로퍼티</a>들이 생략되어 있다):</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// JSX는 아래의 객체를 만들기 위한 syntax sugar이다.</span>\n<span class=\"token comment\">// &lt;dialog></span>\n<span class=\"token comment\">//   &lt;button className=\"blue\" /></span>\n<span class=\"token comment\">//   &lt;button className=\"red\" /></span>\n<span class=\"token comment\">// &lt;/dialog></span>\n<span class=\"token punctuation\">{</span>\n  type<span class=\"token operator\">:</span> <span class=\"token string\">'dialog'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'blue'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'button'</span><span class=\"token punctuation\">,</span>\n      props<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> className<span class=\"token operator\">:</span> <span class=\"token string\">'red'</span> <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>하지만, React 요소에는 영구적인 고유 ID가 존재하지 않는다. 이들은 매번 새로 만들어지고 버려진다.</li>\n<li>또, React 요소들은 불변(immutable)이기 때문에, 요소의 자식이나 프로퍼티 등을 변경할 수 없다. 만약 무언가 다른 것을 (화면에) 렌더링 하고 싶다면 새로운 React 요소를 생성해야 한다.</li>\n<li>React 요소를 영화의 프레임으로 생각하면 쉽다. 각 요소들은 특정 순간에 UI가 어떠한 모습이어야 하는지를 나타내고 있고, 변하지 않는다.</li>\n</ul>\n<h2 id=\"진입점-entry-point\" style=\"position:relative;\"><a href=\"#%EC%A7%84%EC%9E%85%EC%A0%90-entry-point\" aria-label=\"진입점 entry point permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>진입점 (Entry Point)</h2>\n<ul>\n<li>각 React 렌더러에는 “진입점”이 존재한다. 진입점은 우리가 React로 하여금 어떤 React 요소 트리를 컨테이너 호스트 객체 내부에 렌더링 할 수 있게 해주는 API라고 할 수 있다.</li>\n<li>예를 들면, React DOM의 진입점은 <code class=\"language-text\">ReactDOM.render</code> 이다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span>\n  <span class=\"token comment\">// 아래의 JSX는 {type: 'button', props: {className: 'blue'}}를 나타낸 것이라 할 수 있다.</span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">className</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>blue<span class=\"token punctuation\">\"</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span>\n  document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'container'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">ReactDOM.render(reactElement, domContainer)</code>라고 하는 것은 “React님, <code class=\"language-text\">domContainer</code> 호스트 트리를 <code class=\"language-text\">reactElement</code>와 같게 해주세요”라고 하는 것과 같다.</li>\n</ul>\n<div class=\"gatsby-highlight has-highlighted-lines\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// ReactDOM 렌더러 어딘가 (간략한 버전)</span>\n<span class=\"gatsby-highlight-code-line\"><span class=\"token keyword\">function</span> <span class=\"token function\">createHostInstance</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">reactElement</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span></span><span class=\"gatsby-highlight-code-line\">  <span class=\"token keyword\">let</span> domNode <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span>reactElement<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></span>  domNode<span class=\"token punctuation\">.</span>className <span class=\"token operator\">=</span> reactElement<span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>className<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> domNode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>","frontmatter":{"title":"UI 런타임으로서의 React","date":"December 22, 2021","category":"react"}}},"pageContext":{"slug":"/react/react-as-a-ui-runtime/","previous":{"fields":{"slug":"/architecture/refactoring-list-1/"},"frontmatter":{"title":"리팩토링 방법들 Part.1"}},"next":null}},"staticQueryHashes":[]}