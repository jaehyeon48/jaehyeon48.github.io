{"componentChunkName":"component---src-templates-blog-post-js","path":"/computer-architecture/performance-issues/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"e9c00d67-fe72-5160-9ac5-d64482ac8452","excerpt":"성능을 위한 설계 컴퓨터의 성능대비 가격은 시간에 따라 큰 폭으로 하락해왔습니다. 일례로, 현재의 노트북 성능이 10~15년전의 IBM 메인프레임 컴퓨터와 맞먹는 정도입니다. 그리고 이러한 기술적 진보덕분에 더 복잡하고 강력한 프로그램 개발이 가능해졌습니다. 컴퓨터 architecture및 organization 관점에서 흥미로운 점은, 현재 컴퓨터의 기초를 이루고 있는 근간들이 50여년 전의 IAS…","html":"<h2 id=\"성능을-위한-설계\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5%EC%9D%84-%EC%9C%84%ED%95%9C-%EC%84%A4%EA%B3%84\" aria-label=\"성능을 위한 설계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>성능을 위한 설계</h2>\n<p>컴퓨터의 성능대비 가격은 시간에 따라 큰 폭으로 하락해왔습니다. 일례로, 현재의 노트북 성능이 10~15년전의 IBM 메인프레임 컴퓨터와 맞먹는 정도입니다. 그리고 이러한 기술적 진보덕분에 더 복잡하고 강력한 프로그램 개발이 가능해졌습니다.</p>\n<p>컴퓨터 architecture및 organization 관점에서 흥미로운 점은, 현재 컴퓨터의 기초를 이루고 있는 근간들이 50여년 전의 <a href=\"https://en.wikipedia.org/wiki/IAS_machine\" target=\"_blank\" rel=\"noreferrer noopener\">IAS 컴퓨터</a>와 크게 다를바 없지만 하드웨어 성능을 최대로 이끌어내기 위한 기술들이 더 정교해졌다는 점입니다. 즉, 논리적 구조(architecture)는 크게 달라진 것이 없지만 하드웨어(organization)가 그만큼 발전했다는 뜻입니다.</p>\n<h3 id=\"마이크로-프로세서microprocessor-속도\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9Cmicroprocessor-%EC%86%8D%EB%8F%84\" aria-label=\"마이크로 프로세서microprocessor 속도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>마이크로 프로세서(Microprocessor) 속도</h3>\n<p>프로세서 제조사들은 하나의 칩에 더 많은 트랜지스터를 집적하는 등의 노력을 통해 프로세서의 하드웨어 성능을 지속적으로 발전시켜왔습니다. 하지만 프로세서를 제대로 활용하지 못한다면, 즉 프로세서가 놀게끔 놔두지 않고 끊임 없이 일을 시키지 못한다면 아무리 프로세서 하드웨어가 발전했다고 해도 무용지물이 되버립니다.</p>\n<p>이에 따라 제조사들이 공정을 개선하는 동안 프로세서 설계자들은 프로세서의 효율을 높이기 위해 노력해왔는데, 어떠한 기법들을 사용했는지 간략히 살펴봅시다:</p>\n<ul>\n<li><code class=\"language-text\">파이프라이닝(Pipelining)</code>: 쉽게 말해 명령어를 처리할 때 <em>분업화</em>하여 처리하는 것을 말합니다. 즉, 명령어 처리 단계를 여러 단계로 나눠 각기 다른 단계에 있는 여러 명령어를 동시에 처리하는 기술입니다. 흔히 <code class=\"language-text\">fetch</code>, <code class=\"language-text\">decode</code>, <code class=\"language-text\">read</code>, <code class=\"language-text\">execute</code>, <code class=\"language-text\">write back</code> 등의 단계로 나누는데, <code class=\"language-text\">fetch</code> 단계에서는 메모리로부터 명령어를 fetch만 하고 명령어를 다음 단계로 넘긴 다음 다른 명령어를 fetch 합니다. 마찬가지로, <code class=\"language-text\">decode</code> 단계 역시 decode만 수행하고 명령어를 다음 단계로 넘기고 다른 명령어를 또 decode 합니다. 만약 파이프라이닝을 사용하지 않는다면 한 명령어를 가져와 해석하고 실행해서 마무리할 때까지 이후의 명령어는 기다려야 하므로 시간 낭비가 발생합니다.</li>\n</ul>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@main/assets/images/computer-architecture/performance-issues/processor-pipelining.png\" alt=\"CPU 파이프라이닝\">\n    <figcaption>CPU 파이프라이닝.</figcaption>\n</figure>\n<ul>\n<li><code class=\"language-text\">분기 예측(Branch Prediction)</code>: <code class=\"language-text\">if 문</code>과 같은 분기 명령에 대해, 어디로 jump할 것인가를 예측하여 jump될 위치(주소)에 있는 명령어를 미리 가지고 와서(prefetch) 버퍼에 저장하는 기술입니다.</li>\n<li><code class=\"language-text\">슈퍼스칼라(Superscalar Execution)</code>: 각 클럭 사이클마다 두 개 이상의 명령어를 issue(명령어를 CPU 프론트엔드에서 CPU 백엔드로 보내는 것) 하는 기술입니다. 이를 위해 여러 개의 파이프라인이 병렬로 사용됩니다.</li>\n</ul>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@main/assets/images/computer-architecture/performance-issues/superscalar.png\" alt=\"CPU 슈퍼스칼라\">\n    <figcaption>CPU 슈퍼스칼라. 출처: https://en.wikipedia.org/wiki/Superscalar_processor</figcaption>\n</figure>\n<ul>\n<li><code class=\"language-text\">데이터 흐름 분석(Data Flow Analysis)</code>: 명령어, 데이터 등의 의존성을 분석해서 명령들을 최적의 순서로 스케줄링하는 기술로, 원래의 순서와 무관하게 명령어들이 준비되었을 때 실행되게끔 스케줄 됩니다.</li>\n<li><code class=\"language-text\">예측 실행(Speculative Execution)</code>: 분기 예측과 데이터 흐름 분석 등을 활용하여, (추측을 통해) 다음번에 수행될 것 같은 명령어를 미리 가져와서 실행하여 그 결과를 임시 저장소(temporary locations)에 저장합니다. 다음의 코드를 살펴봅시다:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  b <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드에서, <code class=\"language-text\">a &lt;= 1</code>을 판단하기 위해 <code class=\"language-text\">a</code>의 값을 읽는 데 시간이 걸린다고 하면 미리 <code class=\"language-text\">b = 2</code>를 실행하여 성능 향상을 꾀하는 것이 바로 예측 실행 기법입니다.</p>\n<p>종합적으로 보자면, 위 기법들은 본질적으로 한 사이클당 최대한 많은 명령을 수행하도록 하여 프로세서의 효율을 높이는 데 사용됩니다. 즉, 프로세서가 놀게끔 놔두지 않겠다는 것이죠 🙀</p>\n<h3 id=\"성능-밸런스-performance-balance\" style=\"position:relative;\"><a href=\"#%EC%84%B1%EB%8A%A5-%EB%B0%B8%EB%9F%B0%EC%8A%A4-performance-balance\" aria-label=\"성능 밸런스 performance balance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>성능 밸런스 (Performance Balance)</h3>\n<p>여태껏 프로세서의 성능은 가히 엄청난 속도로 발전해왔지만, 메인 메모리와 같은 다른 주요 부품들은 그에 미치지 못했습니다. 이렇게 컴퓨터의 일부분은 빠르지만, 다른 부분은 그렇지 못하다면 컴퓨터 전체의 성능은 느린 부분에 의해 좌우됩니다.</p>\n<p>따라서 부품간의 성능 차이를 최소화하는 것이 전체적인 성능 향상에 중요한데, 예를 들어 프로세서와 메인 메모리를 생각해봅시다. 메모리가 프로세서의 성능을 따라가지 못해 명령·데이터가 메모리에서 프로세서로 전달되는 속도가 느리다 보니, 프로세서가 처리할 수 있는 용량보다 더 적은 양의 명령·데이터가 전달되어 결국 프로세서의 효율이 떨어지게 됩니다.</p>\n<p>이러한 성능 간의 밸런스 문제를 해결할 수 있는 몇 가지 방법들을 살펴봅시다:</p>\n<ul>\n<li>메모리를 “deep”하게 만들기보다, “wide”하게 만듦으로써 한 번에 읽을 수 있는 비트수를 증가시킵니다.</li>\n<li>캐싱을 활용하여 메인 메모리에 접근하는 빈도수를 줄입니다.</li>\n<li>더 빠른 버스와 버스 계층 구조를 활용하여 프로세서와 메인 메모리 간의 대역폭(bandwidth)를 높입니다.</li>\n</ul>\n<p>또한, I/O 장치들을 어떻게 다룰 것인가도 중요한데, 컴퓨터가 더욱 빨라지고 더욱 다양한 동작들을 수행할 수 있게 됨에 따라 주변장치들(모니터, 키보드, 마우스, 프린터 등)과 I/O 동작을 하는 경우가 많아졌습니다. 물론 현대의 프로세서들은 이러한 장치들로부터 받아온 데이터를 능숙하게 처리할 수 있지만, 문제는 I/O장치와의 데이터를 주고받는 것이 느리다는 점입니다. 이 문제를 해결하기 위해 캐싱, 버퍼링과 같은 방법 및 더 빠른 버스, 더 정교한 연결 구조를 사용하곤 합니다. 더 나아가서, 멀티 프로세서 구조를 사용하면 이러한 I/O 처리를 좀 더 원활하게 할 수 있습니다.</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@main/assets/images/computer-architecture/performance-issues/typical-io-device-data-rates.png\" alt=\"일반적인 I/O장치 데이터 전송률\">\n    <figcaption>일반적인 I/O장치 데이터 전송률. 출처: Computer Organization and Architecture 10th Edition</figcaption>\n</figure>\n<h3 id=\"칩-구조와-구성-개선\" style=\"position:relative;\"><a href=\"#%EC%B9%A9-%EA%B5%AC%EC%A1%B0%EC%99%80-%EA%B5%AC%EC%84%B1-%EA%B0%9C%EC%84%A0\" aria-label=\"칩 구조와 구성 개선 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>칩 구조와 구성 개선</h3>\n<p>앞서 살펴본 것처럼 프로세서와 장치들간의 성능 밸런스를 맞추는 것도 중요하지만, 프로세서 그 자체의 성능을 높이는 것도 여전히 중요합니다. 프로세서의 성능을 높이기 위한 세 가지 방법들을 간략히 살펴보자면 다음과 같습니다:</p>\n<ul>\n<li>프로세서 하드웨어 그 자체의 성능을 높이는 방법이 있습니다. 즉, 미세공정을 이용하여 하나의 칩에 들어가는 반도체 소자의 개수를 늘리고 클럭을 높이는 것입니다.</li>\n<li>프로세서와 메인 메모리 사이에 존재하는 캐시 메모리들의 용량과 속도를 높이는 방법이 있습니다.</li>\n<li>명령 실행 속도를 높이기 위해 프로세서의 구조와 구성을 개선하는 방법이 있습니다. 흔히 병렬성(parallelism)을 이용하는 방법을 많이 사용합니다.</li>\n</ul>\n<p>전통적으로 프로세서 성능 향상에 가장 큰 영향을 미친 요인은 클럭 스피드와 집적도(logic density)였습니다. 하지만 클럭 스피드가 높아지고 집적도가 높아질수록 다음과 같은 사항이 장애물로 작용하게 됩니다:</p>\n<ul>\n<li>\n<p><strong>소비전력(Power)</strong>: 클럭 스피드와 집적도가 높을수록 소비전력이 높아지고, 이로 인해 <em>열</em>이 많이 발생하게 됩니다. 일반적으로 소비전력은 전기용량(capacitance), 전압(voltage), 진동수(frequency)에 대해 다음과 같은 비례관계를 형성합니다:</p>\n<blockquote>\n<p>소비전력(P) ∝ 전기용량(C) × 전압(V)<sup>2</sup> × 진동수(f)</code></pre></p>\n</blockquote>\n<p>즉, 집적도가 높아지면 전기용량이 증가하고, 클럭 스피드가 증가하면 진동수가 증가하는데, 위 식에서 알 수 있듯 이 두 값이 커질수록 이에 비례하여 소비전력도 높아짐을 알 수 있습니다.</p>\n</li>\n<li><strong>RC Delay</strong>: 전자가 이동하는 속도는 저항(resistance)과 전기용량이 커질수록 느려지는데, 위에서 살펴봤듯이 집적도 증가할수록 전기용량이 증가하고, 또 각 소자들의 크기 혹은 소자를 연결하는 전선들의 크기가 작아질 수록 저항도 증가하게 됩니다. 이러한 요인들 때문에 RC Delay가 증가하게 됩니다.</li>\n<li><strong>Memory Latency and Throughput</strong>: 프로세서의 속도가 빨라짐에 따라 상대적으로 메모리 접근 속도(latency)와 전송 속도(throughput)가 느려지게 됩니다.</li>\n</ul>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@main/assets/images/computer-architecture/performance-issues/typical-io-device-data-rates.png\" alt=\"프로세서 발전 트렌드\">\n    <figcaption>프로세서 발전 트렌드. 출처: https://www.karlrupp.net/2018/02/42-years-of-microprocessor-trend-data/</figcaption>\n</figure>\n<p>위 그림에서 볼 수 있듯, 소비 전력(power)을 줄이기 위해 어느 순간부터 클럭 스피드(frequency)가 더 이상 증가하지 않는다는 사실을 알 수 있습니다. 대신, 프로세서의 성능을 높이기 위해 코어의 개수를 늘리는 방법을 사용하고 있음을 알 수 있습니다.</p>\n<h2 id=\"multicore-mics-and-gpgpus\" style=\"position:relative;\"><a href=\"#multicore-mics-and-gpgpus\" aria-label=\"multicore mics and gpgpus permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Multicore, MICs, and GPGPUs</h2>\n<p>이와 같이 코어의 수를 늘리는 방식을 <strong>멀티코어</strong>라고 합니다. 여러 연구에 따르면 프로세서의 성능 향상은 복잡도의 루트(square root)에 거의 비례한다고 합니다. 또한, 메모리 칩의 전력 소비는 명령 처리 로직에 비해 훨씬 적기 때문에 이러한 방식으로 프로세서를 만들게 되면 더 큰 캐시 메모리를 사용할 수 있게 됩니다.</p>\n<p>하지만 이렇게 병렬 코어 형태가 되면 다른 문제가 발생한다. 어떤 동작(작업)을 병렬화 해야지만 여러개의 코어를 사용하는 이점을 살릴 수 있다는 점이다, 즉 프로그램들을 병렬화를 잘 이용할 수 있게끔 설계하는게 중요해진다.</p>\n<p>아주 simple한 코어 수천 개를 사용하여 주로 그래픽 처리를 하는데 사용하는 <strong>GPU(Graphics Processing Unit)</strong>라는 것이 존재한다. GPU는 부동 소수점 실수 연산과 벡터 연산에서 CPU보다 빠른 성능을 보여주기 때문에, 2000년대 후반부터 GPU를 그래픽 이외의 컴퓨팅 분야에 사용하기 시작했는데, 이것이 <strong>GPGPU(General-Purpose GPU)</strong>이다.</p>\n<h2 id=\"암달의-법칙-amdahls-law\" style=\"position:relative;\"><a href=\"#%EC%95%94%EB%8B%AC%EC%9D%98-%EB%B2%95%EC%B9%99-amdahls-law\" aria-label=\"암달의 법칙 amdahls law permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>암달의 법칙 (Amdahl’s Law)</h2>\n<p>암달의 법칙은 <a href=\"https://en.wikipedia.org/wiki/Gene_Amdahl\" target=\"_blank\" rel=\"noreferrer noopener\">Gene Amdahl</a>{:target=”_blank”}{:rel=“noopener”}이라는 사람이 만들었으며, 쉽게 말해 한 시스템의 일부를 개선할 때 시스템 전체적으로는 얼마만큼의 성능 향상이 있는가? 에 관한 내용이다.</p>\n<p>이 법칙에 따르면, 어떤 시스템을 개선하여 전체 작업 중 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span></span></span></span>만큼 차지하는 부분을 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span></span></span></span>만큼 향상시키면 시스템 전체적으로 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mfrac><mn>1</mn><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mfrac><mi>f</mi><mi>N</mi></mfrac></mrow></mfrac></mrow><annotation encoding=\"application/x-tex\">\\frac{1}{(1 - f) + \\frac{f}{N}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.566798em;vertical-align:-0.7216899999999998em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.845108em;\"><span style=\"top:-2.5191100000000004em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">1</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose mtight\">)</span><span class=\"mbin mtight\">+</span><span class=\"mord mtight\"><span class=\"mopen nulldelimiter sizing reset-size3 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9584142857142857em;\"><span style=\"top:-2.656em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.2255000000000003em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.049em;\"></span></span><span style=\"top:-3.4623857142857144em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size3 size1 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.344em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size3 size6\"></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.7216899999999998em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> 만큼의 성능 향상이 이뤄진다:</p>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/computer_architecture/com_structure_amdahl.png\" alt=\"Equation of amdahl's law\">\n</p>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/computer_architecture/com_structure_amdahl_gen.png\" alt=\"Equation of amdahl's law\">\n</p>\n<p>이 식으로 부터 다음 두 가지 결론을 도출할 수 있다:</p>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/computer_architecture/com_structure_fig_23.png\" alt=\"Illustration of amdahl's law\">\n</p>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/computer_architecture/com_structure_fig_24.png\" alt=\"Amdahl's law for multiprocessors\">\n</p>\n<ol>\n<li><code class=\"language-text\">f</code>가 작은 부분을 개선하면 전체적인 성능 향상에 별다른 영향을 미치지 못한다. (Figure 2.4의 f = 0.5인 경우를 살펴보라!)</li>\n<li><code class=\"language-text\">N</code>이 무한대로 갈수록 결국 전체적인 성능 향상은 <code class=\"language-text\">1 / (1 - f)</code>에 제한된다. 즉, 더 많은 프로세서(코어)의 수를 사용할 수록 얻는 성능 향상 효과가 작아진다.</li>\n</ol>\n<p>누군가는 이러한 결론이 너무 비관적이라고 말한다. 예를 들어, 어떤 서버는 프로세서 개수에 맞춰 여러 스레드를 이용하여 작업들을 병렬로 처리할 수 있다. 또, 많은 데이터베이스 애플리케이션들은 하나의 거대한 작업을 여러 세부 작업들로 나눠 병렬로 처리할 수 있다.</p>\n<p>그럼에도 불구하고, 암달의 법칙은 더 많은 코어수를 사용하는 머신을 개발하는 현 업계가 직면한 문제를 설명한다: 이러한 멀티코어 머신에서 돌아가는 프로그램들은 <em>반드시</em> 이러한 병렬 처리를 활용할 수 있는 방식으로 개발되어야 코어 수의 증가에 따른 성능 향상을 누릴 수 있다는 점이다. 만약 프로그램의 병렬화를 하기 힘든 경우라면, 더욱 많은 코어에 의한 성능 향상을 누리지 못할 것이다.</p>\n<h2 id=\"리틀의-법칙-littles-law\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%ED%8B%80%EC%9D%98-%EB%B2%95%EC%B9%99-littles-law\" aria-label=\"리틀의 법칙 littles law permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>리틀의 법칙 (Little’s Law)</h2>\n<p><a href=\"https://en.wikipedia.org/wiki/John_Little_(academic)\" target=\"_blank\" rel=\"noreferrer noopener\">John Little</a>{:target=”_blank”}{:rel=“noopener”}에 의해 발명된 이 법칙은 어떤 시스템이 정상 상태(steady state)에 도달했을 때, 여러 가지 task들의 대기시간, 서비스 시간들을 설명해주는 법칙이다. 주로 성능 평가에 많이 사용된다. 식은 다음과 같다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">L = λW</code></pre></div>\n<ul>\n<li><strong><em>L</em></strong>: 한 system 내의 평균 아이템의 수</li>\n<li><strong><em>λ</em></strong>: 각 아이템들의 평균 도착 속도</li>\n<li><strong><em>W</em></strong>: system에서 각 아이템의 평균 대기 시간</li>\n</ul>\n<p>예를 들어, 2시간 동안 320명의 손님이 다녀간 식당이 있다고 하자. 각 손님당 평균 식사 시간은 15분 이라고 했을 때, 식당 안의 “평균” 손님 수는 얼마나 될까?</p>\n<p>L = λW 에서 λ: 320명 / 2시간 → 160명 / 1시간, W: 15 / 60분 → 1 / 4시간 이므로 평균 손님수 L은 160 × (1 / 4) = 40명 이다.</p>\n<p>즉 요약하자면, 정상 상태(프로세스가 안정적인 상태)일 때 queuing 시스템에 존재하는 평균적인 item의 수는 item들이 시스템에 들어오는 수와 아이템이 평균적으로 시스템에서 머무르는 수를 곱한것과 같다는 의미이다.</p>\n<h2 id=\"레퍼런스\" style=\"position:relative;\"><a href=\"#%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4\" aria-label=\"레퍼런스 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>레퍼런스</h2>\n<ul>\n<li><a href=\"https://www.amazon.com/Computer-Organization-Architecture-William-Stallings/dp/0134101618/ref=sr_1_3?crid=254TMAUZ6SF0Z&#x26;keywords=Computer+Organization+and+Architecture&#x26;qid=1655859599&#x26;s=books&#x26;sprefix=computer+organization+and+architecture%2Cstripbooks-intl-ship%2C242&#x26;sr=1-3\" target=\"_blank\" rel=\"noreferrer noopener\">Computer Organization and Architecture 10th Edition</a></li>\n</ul>","frontmatter":{"title":"성능 이슈","date":"March 23, 2021","category":"Computer Architecture"}}},"pageContext":{"slug":"/computer-architecture/performance-issues/","previous":{"fields":{"slug":"/computer-architecture/computer-architecture-intro/"},"frontmatter":{"title":"컴퓨터 구조 개론"}},"next":{"fields":{"slug":"/web/cors-on-local-environment/"},"frontmatter":{"title":"로컬 환경에서의 CORS 문제 해결"}}}},"staticQueryHashes":["3128451518"]}