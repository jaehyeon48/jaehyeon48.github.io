{"componentChunkName":"component---src-templates-blog-post-js","path":"/os/what-is-interrupt/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","author":"Jaehyeon Kim","siteUrl":"https://jaehyeon48.github.io","comment":{"disqusShortName":"","utterances":"jaehyeon48/blog-comments"}}},"markdownRemark":{"id":"3551421d-6280-5f73-99a1-3c7564e53ead","excerpt":"인터럽트란? 인터럽트(interrupt)란, (주로 입/출력)하드웨어 장치의 처리, 혹은 예외 상황의 처리가 필요할 때 CPU에게 알려 이를 처리할 수 있도록 하는 일종의 신호입니다. 인터럽트는 여러 목적으로 사용될 수 있으며, 운영체제와 하드웨어 간의 상호작용에 핵심적인 역할을 합니다. CPU에 인터럽트 신호가 들어오면, CPU는 현재 수행 중인 작업을 멈추고 즉시 인터럽트를 처리하기 위한 루틴(ISR, interrupt service routine…","html":"<h2 id=\"인터럽트란\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EB%9E%80\" aria-label=\"인터럽트란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>인터럽트란?</h2>\n<p><strong>인터럽트(interrupt)</strong>란, (주로 입/출력)하드웨어 장치의 처리, 혹은 예외 상황의 처리가 필요할 때 CPU에게 알려 이를 처리할 수 있도록 하는 일종의 <em>신호</em>입니다. 인터럽트는 여러 목적으로 사용될 수 있으며, 운영체제와 하드웨어 간의 상호작용에 핵심적인 역할을 합니다. CPU에 인터럽트 신호가 들어오면, CPU는 현재 수행 중인 작업을 멈추고 즉시 인터럽트를 처리하기 위한 루틴(ISR, interrupt service routine)이 있는 곳으로 제어권을 넘겨 해당 인터럽트를 처리합니다. 이후 처리가 완료되면 CPU는 원래 수행하고 있던 동작을 재개합니다.</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/os/what-is-interrupt/fig1.png\" alt=\"인터럽트 타임라인\">\n    <figcaption>인터럽트 타임라인. 출처: Operating System Concepts (10th Edition)</figcaption>\n</figure>\n<p>각 컴퓨터 시스템마다 고유의 인터럽트 메커니즘이 있지만, 몇몇 공통적인 특성들이 존재합니다. 인터럽트가 발생하면 <em>반드시</em> 제어권을 적절한 ISR에게 넘겨야 합니다. 일반적으로 ISR을 가리키는 포인터 테이블(배열)을 사용하여 인터럽트를 빠르게 처리하는데, 보통 이 포인터 테이블은 메모리의 낮은 주소에 위치합니다.</p>\n<p>이처럼 ISR들의 주소에 대한 배열(테이블)을 <strong>인터럽트 벡터(interrupt vector)</strong>라고 하는데, 인터럽트 벡터는 인터럽트 요청에 포함된 고유 숫자(id)로 해당 인터럽트를 인덱싱하여 이 인터럽트를 처리하는 ISR의 주소를 제공합니다. 윈도우와 UNIX 운영체제들은 이러한 방식으로 인터럽트를 처리합니다:</p>\n<figure>\n    <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io@master/assets/images/os/what-is-interrupt/fig2.png\" alt=\"인터럽트 타임라인\">\n    <figcaption>메모리 상에서의 ISR 메커니즘.</figcaption>\n</figure>\n<p>이후 인터럽트 처리가 끝나면 원래 수행하던 상태로 되돌아와야 하므로 인터럽트가 발생한 당시의 상태를 반드시 어딘가에 저장해야만 합니다. 프로세스의 상태를 <strong>컨텍스트(context)</strong> 라고 하는데, 컨텍스트는 PCB(Process Control Block)에 저장됩니다. 이렇게 프로세스의 상태를 저장함으로써, 인터럽트를 처리하고 나면 다시 원래 상태로 돌아와서 마치 아무일도 일어나지 않은 것 처럼 기존의 동작을 이어서 수행할 수 있습니다.</p>\n<ul>\n<li>\n<img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig3.png\" alt=\"Diagram showing context switch from process to process.\">\n</li>\n<li>\n<p>위 내용을 바탕으로 좀 더 자세히 살펴보자. I/O장치와 같은 대부분의 (외부) 장치들은 프로세서보다 <em>훨씬</em> 느린데, 프로세서가 프린터와 데이터를 주고 받는 상황을 생각해 보자. 매번 write 동작을 수행할 때마다, 프로세서는 프린터가 작업을 마칠 때 까지 기다려야 할 것이다. 다음 그림에 이와 같은 상황이 묘사되어 있다.</p>\n<p align=\"center\">\n<img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig4.png\" alt=\"Program flow of control without interrupts.\">\n</p>\n</li>\n<li>그림의 1, 2, 3번은 I/O 동작을 하지 않는 유저 프로그램을 나타내고, 4번은 I/O와 관련된 프로그램 (실제 I/O 수행을 위한 사전 작업 등), 5번은 I/O 동작을 완료하는 (I/O 동작을 성공적으로 수행했는지, 실패했는지 등에 대한 <code class=\"language-text\">flag</code> 설정과 같은 동작을 수행). 이 때 I/O 장치가 실제로 I/O 동작을 수행하는 단계는 4번과 5번 사이이다.</li>\n<li>인터럽트를 사용하지 않는다면, 프로세서는 4번을 실행한 후, 장치가 동작을 끝마칠 때 까지 기다려야 할 것이다. 동작을 끝마치면 5번을 실행하고 다시 유저 프로그램으로 넘어올 것이다. 엄청나게 비효율적이지 않는가?</li>\n<li>다음은 인터럽트를 사용하는 경우를 나타낸다:</li>\n</ul>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig5.png\" alt=\"Program flow of control without interrupts.\">\n</p>\n<ul>\n<li>위 그림에서 볼 수 있듯, 인터럽트를 이용하면 프로세서는 I/O 장치가 작업을 수행하는 도중에 다른 명령을 수행할 수 있다. 좀 더 자세히 살펴보자면, 유저 프로그램에서 <code class=\"language-text\">WRITE</code> 시스템 콜을 발생시켜 4번에서 I/O장치로 하여금 I/O를 수행할 준비를 시키고 실제 I/O 동작을 하도록 한다.</li>\n<li>그러고 나면 control이 다시 유저프로그램으로 돌아와 명령을 실행하다가 (동시에 I/O 장치가 데이터를 write하고 있다), I/O 동작이 완료되면 인터럽트에 의해 다시 I/O 장치로 control을 넘겨 5번에서 수행된 I/O 관련 처리를 하고, 처리가 완료되면 다시 원래 상태로 돌아와 하던 작업을 이어서 수행한다.</li>\n<li>즉, 인터럽트를 사용하게 되면 CPU를 놀리지 않고 사용할 수 있게되는데, 이로인해 성능이 향상될 수 있다.</li>\n<li>여기서 왼쪽 상황과 오른쪽 상황의 차이점은, 왼쪽 상황의 경우, I/O를 수행하는 시간이 상대적으로 짧아서 유저 프로그램을 실행하는 도중에 인터럽트가 발생하는 상황이고, 오른쪽 상황의 경우, I/O를 수행하는 시간이 상대적으로 길어서, 먼저 발생한 I/O의 수행이 채 끝나기도 전에 두 번째 I/O 요청이 발생하는 경우이다. 이 경우, 먼저 발생한 I/O의 처리가 완료될 때 까지 기다려야 한다.</li>\n</ul>\n<h2 id=\"구현\" style=\"position:relative;\"><a href=\"#%EA%B5%AC%ED%98%84\" aria-label=\"구현 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>구현</h2>\n<ul>\n<li>기본적인 인터럽트 메커니즘은 다음과 같다. 우선, CPU에는 매번 명령을 실행하고 난 후 인터럽트를 감지하는 <strong>interrupt-request line</strong>이라는 전선(wire)이 존재한다. 만약 이 interrupt-request line을 통해 컨트롤러가 발생시킨 시그널을 감지하게 되면 해당 인터럽트의 <strong>interrupt number</strong>를 읽어서, interrupt vector에서 해당 명령에 상응하는 ISR로 이동한 후 해당 routine을 실행한다.</li>\n<li>이 때 인터럽트 핸들러는 동작 수행 도중 변경될 수 있는 모든 상태를 저장하고, 인터럽트 발생 원인을 살펴보고, 적절한 동작을 수행하고, <code class=\"language-text\">return_from_interrupt</code> 과 같은 명령을 실행시켜 인터럽트가 발생하기 전의 원래 상태로 되돌아간다.</li>\n<li>즉, 장치 컨트롤러가 인터럽트를 <em>발생(raise)</em> 시키고, CPU가 <em>감지(catch)</em>해서 적절한 인터럽트 핸들러에게 <em>배치(dispatch)</em>하면 해당 핸들러가 인터럽트를 <em>처리(clear)</em>한다. Figure 1.4에 인터럽트 기반(interrupt-driven) I/O 사이클에 대한 내용이 묘사되어 있다.</li>\n</ul>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig6.png\" alt=\"Interrupt-driven I/O cycle.\">\n</p>\n<ul>\n<li>\n<p>위와 같은 인터럽트 메커니즘을 통해, CPU는 비동기적(asynchronous) 이벤트를 처리할 수 있다. 하지만 현대 운영체제에서는 좀 더 정교한 인터럽트 핸들링 방식이 필요하다:</p>\n<ol>\n<li>중요한 처리(critical processing)을 하는 동안에는 인터럽트 핸들링을 잠시 중단(defer)할 필요가 있다.</li>\n<li>장치에 대한 적절한 인터럽트 핸들러를 dispatch 하는데 효율적인 방법이 필요하다.</li>\n<li>운영체제가 우선순위를 고려하여 인터럽트를 처리할 수 있게끔 multi-level 인터럽트가 필요하다.</li>\n</ol>\n</li>\n<li>현대 컴퓨터 하드웨어에서, 이러한 세가지 특성들은 CPU와 <strong>interrupt-controller hardware</strong>에 의해 처리될 수 있다.</li>\n<li>대부분의 CPU들은 두 개의 interrupt request line을 가지고 있다. 하나는 회복할 수 없는(unrecoverable) 메모리 에러와 같은 이벤트를 처리하는 <strong>non-maskable interrupt</strong>를 위한 것이고, 다른 하나는 인터럽트 되어서는 안되는 중요한(critical) 명령 처리를 위해 잠시 중단 (turn off)시킬 수 있는 <strong>maskable interrupt</strong>를 위한 것이다. maskable interrupt는 장치 컨트롤러가 서비스를 요청할 때 사용된다.</li>\n<li>앞서 살펴본 interrupt vector의 존재 이유를 복기해보자. 인터럽트가 발생했을 때, 하나의 인터럽트 핸들러(generic handler)를 통해 처리한다면 어떤 인터럽트 처리가 필요한지 판단하기 위해 가능한 모든 interrupt source를 찾아야 할 것이다. 이는 비효율적이므로 interrupt vector와 같이 ISR들의 주소를 저장하는 테이블을 통해 인터럽트 처리를 한다.</li>\n<li>하지만 실제로 컴퓨터들은 interrupt vector가 보유한 주소들 보다 더 많은 장치를(즉, 인터럽트 핸들러들) 가지고 있다. 즉, interrupt vector에 모든 장치들의 ISR 주소를 저장할 수 없다는 뜻이다.</li>\n<li>이 문제를 해결할 수 있는 일반적인 방법은 각 interrupt vector의 요소가 인터럽트 핸들러 들이 저장된 리스트의 헤드를 가리키는 <strong>interrupt chaining</strong> 방식을 사용하는 것이다 (즉, 해쉬 테이블 <a href=\"https://www.geeksforgeeks.org/hashing-set-2-separate-chaining/\" target=\"_blank\" rel=\"noreferrer noopener\">separate chaining</a>{:target=”_blank”}{:rel=“noopener”} 방법과 유사하다).</li>\n<li>Figure 1.5는 인텔 프로세서에 대한 interrupt vector를 나타낸 것이다. vector number 0부터 31까지는 non-maskable interrupt, 32 부터 255까지는 maskable interrupt이다.</li>\n</ul>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig7.png\" alt=\"Intel processor event-vector table.\">\n</p>\n<ul>\n<li>인터럽트 메커니즘은 또한 <strong>interrupt priority level</strong>을 구성한다. 이러한 우선순위 레벨을 통해, CPU는 우선순위가 높은 인터럽트 부터 처리할 수 있다.</li>\n</ul>\n<h2 id=\"종류\" style=\"position:relative;\"><a href=\"#%EC%A2%85%EB%A5%98\" aria-label=\"종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>종류</h2>\n<ul>\n<li>가장 주요 인터럽트는 다음과 같다:</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>타입</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>프로그램</td>\n<td>arithmetic overflow, division by zero, illegal machine instruction, 허용된 메모리 공간 이외의 공간에 대한 접근 등에 의해 발생한다.</td>\n</tr>\n<tr>\n<td>타이머</td>\n<td>프로세서 안에 있는 타이머에 의해 발생한다. 프로세서가 특정한 기능을 주기적으로 수행하도록 한다.</td>\n</tr>\n<tr>\n<td>입/출력</td>\n<td>I/O 컨트롤러에 의해 발생하며, 주로 입/출력 동작의 완료, 프로세서로 부터 요청을 받았을 때, 혹은 (다양한) 에러에 의해 발생한다.</td>\n</tr>\n<tr>\n<td>하드웨어 failure</td>\n<td>전원 failure, 혹은 메모리 parity 에러 등에 의해 발생한다.</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>인터럽트는 크게 하드웨어 인터럽트, 소프트웨어 인터럽트로 나눌 수 있다:</li>\n</ul>\n<h3 id=\"하드웨어-인터럽트외부-인터럽트\" style=\"position:relative;\"><a href=\"#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EC%99%B8%EB%B6%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\"하드웨어 인터럽트외부 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>하드웨어 인터럽트(외부 인터럽트)</h3>\n<ul>\n<li>\n<p>CPU, 기타 장치들이 자신에게 발생한 사건을 운영체제에게 알리는 메커니즘 (비동기식 이벤트):</p>\n<ul>\n<li>정전 혹은 전원 공급 이상</li>\n<li>CPU 또는 기타 하드웨어 장치 오류</li>\n<li>timer 인터럽트</li>\n<li>I/O</li>\n<li>etc.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"소프트웨어-인터럽트내부-인터럽트-트랩\" style=\"position:relative;\"><a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8%EB%82%B4%EB%B6%80-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%8A%B8%EB%9E%A9\" aria-label=\"소프트웨어 인터럽트내부 인터럽트 트랩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>소프트웨어 인터럽트(내부 인터럽트, 트랩)</h3>\n<ul>\n<li>\n<p>현재 실행중인 프로세스가 일으키는 소프트웨어적인 사건을 알리는 메커니즘 (동기식 이벤트):</p>\n<ul>\n<li>시스템 콜</li>\n<li>0으로 나누기</li>\n<li>존재하지 않는 메모리 주소에 접근</li>\n<li>오버플로우</li>\n<li>page fault</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"여러개의-인터럽트\" style=\"position:relative;\"><a href=\"#%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8\" aria-label=\"여러개의 인터럽트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>여러개의 인터럽트</h2>\n<ul>\n<li>여태껏 하나의 인터럽트만 발생하는 경우를 살펴보았다.</li>\n<li>하지만 여러 개의 인터럽트가 발생하면 어떻게 될까? 예를 들어, 네트워크를 통해 데이터를 받아서 결과를 출력하는 프로그램이 있다고 하자.</li>\n<li>프린터는 결과를 프린트할 때마다 인터럽트를 발생시킬 것이다. 네트워크 컨트롤러는 데이터가 도착할 때마다 인터럽트를 발생시킬 것인데, 이 때 데이터는 하나의 문자일 수도 있고, 블록 단위일 수도 있을 것이다.</li>\n<li>어찌됐건, <em>프린터 인터럽트가 처리되는 도중에 네트워크 인터럽트가 발생할 수 있다</em>.</li>\n<li>이 경우, 여러 개의 인터럽트를 처리하기 위해 두 가지 방법이 사용될 수 있는데, 우선 첫 번째는 어떤 한 인터럽트가 처리되는 동안은 다른 인터럽트의 발생을 중지시키는 것이다.</li>\n<li>즉, 프로세서가 인터럽트 시그널을 (일단) 무시한다는 뜻이다. 어떤 한 인터럽트가 처리되는 동안 발생한 다른 인터럽트는 대게 pending 상태가 되어, 후에 프로세서가 인터럽트 발생을 다시 허용했을 때 처리된다.</li>\n<li>이 방법은 인터럽트가 발생한 (정확한) 순서대로 처리된다는 점에서 좋은 방법이지만, 상대적 우선순위 혹은 time-critical한 요구를 고려하지 못한다는 점이 있다. 예를 들어, 네트워크로 부터 어떤 데이터가 도착했을 때, (앞으로 도착할) 또 다른 데이터들을 위해 즉시 처리되어야 할 필요가 있다. 하지만 만약 두 번째 데이터가 도착하기 전에 첫 번째 데이터가 처리되지 못한다면, 데이터가 소실될 가능성이 있다.</li>\n<li>두 번째 방법은 인터럽트들 간에 우선순위를 매겨 처리하는 방법이다. 예를 들어, 프린터, 디스크, 네트워크로 구성된 시스템을 생각해보자. 각 장치들의 우선순위는 각각 2, 4, 5 이다 (그림 3.14 참고).</li>\n</ul>\n<p align=\"center\">\n  <img src=\"https://cdn.jsdelivr.net/gh/jaehyeon48/jaehyeon48.github.io/assets/images/os/interrupts/fig8.png\" alt=\"Example time sequence of multiple interrupts.\">\n</p>\n<ul>\n<li><code class=\"language-text\">t = 0</code> 에 유저 프로그램이 시작된다. <code class=\"language-text\">t = 10</code>에 프린터 인터럽트가 발생하여, 유저 프로그램의 정보가 시스템 스택에 저장되고 프로그램의 흐름이 프린터의 interrupt service routine (ISR)로 넘어간다.</li>\n<li>이 루틴이 실행되는 도중, <code class=\"language-text\">t = 15</code>에 네트워크 인터럽트가 발생한다. 네트워크의 우선순위(5)가 프린트(2)보다 높기 때문에, 인터럽트가 accept 된다.</li>\n<li>이번에는 프린터 (프로그램)의 상태가 스택에 저장되고, 프로그램의 흐름이 통신(네트워크) ISR로 넘어간다. 이 루틴을 실행하는 도중, <code class=\"language-text\">t = 20</code>에 디스크 인터럽트가 발생하는데, 디스크의 우선순위(4)가 네트워크(5)보다 낮기 때문에, 디스크 인터럽트는 pending되고 계속해서 통신 ISR이 끝날 때 까지 실행된다.</li>\n<li><code class=\"language-text\">t = 25</code>가 되어 통신 ISR이 종료되면, 프로그램의 흐름이 프로세서의 이전 상태 (프린터 ISR)로 다시 넘어가는데, 이 때 프린터 ISR이 실행되기 전에 pending 되어있던 디스크 인터럽트가 accept되어 프로그램의 흐름이 disk ISR로 넘어가게 된다 (디스크의 우선순위가 프린터보다 높으므로).</li>\n<li><code class=\"language-text\">t = 35</code>에 Disk ISR이 끝나야지만 프린터 ISR이 다시 실행되고, <code class=\"language-text\">t = 40</code>에 프린터 ISR도 종료가 되면 프로그램 흐름이 최종적으로 다시 유저 프로그램으로 넘어가서 모든 인터럽트가 처리되게 된다.</li>\n</ul>\n<h2 id=\"인터럽트-기반-시스템-interrupt-based-system\" style=\"position:relative;\"><a href=\"#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EA%B8%B0%EB%B0%98-%EC%8B%9C%EC%8A%A4%ED%85%9C-interrupt-based-system\" aria-label=\"인터럽트 기반 시스템 interrupt based system permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>인터럽트 기반 시스템 (Interrupt-Based System)</h2>\n<ul>\n<li>현대 운영체제는 <strong>인터럽트 기반 시스템</strong>이다. 즉, 평상시에는 대기 상태에 있다가 interrupt가 발생하면 해당 interrupt의 ISR을 실행시킴으로써 동작하는 시스템인 것이다.</li>\n</ul>\n<h2 id=\"summary\" style=\"position:relative;\"><a href=\"#summary\" aria-label=\"summary permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" width=\"18\" height=\"18\" focusable=\"false\" data-prefix=\"fas\" data-icon=\"link\" viewBox=\"0 0 512 512\"><path fill=\"#05b166\" d=\"M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z\"></path></svg></a>Summary</h2>\n<ul>\n<li>인터럽트는 비동기 이벤트들을 처리하기 위해, 혹은 processing의 효율성을 높이기 위해 사용되며, 주로 장치 컨트롤러 (혹은 hardware fault 발생 시)에 의해 발생된다.</li>\n<li>우선순위가 더 높은 것들을 먼저 처리하기 위해 현대 운영체제들은 인터럽트에 우선순위를 부여하여 사용하고 있으며, 인터럽트들은 자주, 그리고 time-sensitive한 처리에 사용되므로 시스템 성능을 위해 이러한 인터럽트들을 효율적으로 처리하는게 중요하다.</li>\n</ul>","frontmatter":{"title":"인터럽트","date":"March 21, 2021","category":"OS"}}},"pageContext":{"slug":"/os/what-is-interrupt/","previous":{"fields":{"slug":"/os/system-call/"},"frontmatter":{"title":"시스템 콜"}},"next":{"fields":{"slug":"/software-architecture/refactoring-summary-1/"},"frontmatter":{"title":"리팩토링 2판 요약 정리 Ch.1"}}}},"staticQueryHashes":[]}