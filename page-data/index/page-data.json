{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"이 포스트는 A Complete Guide to useEffect를 번역/요약한 글입니다. 원글의 작성일이 2019년 3월인 것을 감안해 주세요! 모든 렌더링은 각자의 Props와 State를 가진다 (Each Render Has Its Own Props and State) 우선 effect에 대해 살펴보기 전에 렌더링부터 살펴봅시다. 여기 카운터 컴포넌…","fields":{"slug":"/react/a-complete-guide-to-useeffect/"},"frontmatter":{"date":"December 24, 2021","title":"useEffect 완벽 가이드","category":"react","draft":false}}},{"node":{"excerpt":"이 포스트는 React as a UI Runtime를 번역/요약한 글입니다. 호스트 트리 (Host Tree) 각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 최적화되어있고, 이는 React도 예외가 아니다. React 프로그램은 시간에 따라 변할 수도 있는 트리를 출력한다. 이 트리를 “호스트 트리” 라고 하는데, 이는 이 트리가 Rea…","fields":{"slug":"/react/react-as-a-ui-runtime/"},"frontmatter":{"date":"December 22, 2021","title":"UI 런타임으로서의 React","category":"react","draft":false}}},{"node":{"excerpt":"Inline Variable Motivation 변수의 이름을 통해 코드의 흐름을 파악할 수 있기 때문에, 일반적으로 변수는 좋은 것으로 취급된다. 하지만 변수의 이름이 원래의 표현식과 다를 바 없는 경우, 혹은 리팩토링 하는데 변수가 방해되는 경우 해당 변수를 인라인하는 것이 좋다. Mechanics 변수의 오른쪽에 있는 표현식(Right-Hand Si…","fields":{"slug":"/architecture/refactoring-list-1/"},"frontmatter":{"date":"December 21, 2021","title":"리팩토링 방법들 Part.1","category":"architecture","draft":false}}},{"node":{"excerpt":"클린 코드를 번역/요약한 글입니다. 스스로를 “프로”라고 부르기 위해선 반드시 클린 코드를 작성할 줄 알아야 한다. 클린 코드를 작성하기 위해 최선을 다해야만 한다. 도입 (Introduction) 클린 코드를 작성하는 방법을 배우는 것은 어렵다. 단순히 원칙이나 패턴들을 외운다고 되는 것이 아니라, 그것들을 몸으로 체득해야만 한다. 이 책을 통해 배운 …","fields":{"slug":"/architecture/clean-code-summary-1/"},"frontmatter":{"date":"December 15, 2021","title":"클린 코드 요약 정리 Ch.1","category":"architecture","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 테스트 만들기 (Building Tests) 리팩토링은 그 자체로 매우 훌륭한 도구이지만, 이것만으론 부족하다. 혹시 모를 실수에 대비해 반드시 견고한 테스트 코드가 있어야 한다. (IDE와 같은 도구에서 제공하는) 자동 리팩토링 기능을 사용한다고 하더라도 테스트 코드를 통해 테스트하는 것이 좋다. 굳이 리팩토링 때…","fields":{"slug":"/architecture/refactoring-summary-4/"},"frontmatter":{"date":"December 14, 2021","title":"리팩토링 2판 요약 정리 Ch.4","category":"architecture","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 코드에서 나는 악취 (Bad Smells in Code) 언제 리팩토링을 시작할 것인지(그리고 언제 멈출 것인지)를 아는 것은 리팩토링의 작동 원리를 아는 것 못지 않게 중요하다. 인스턴스 변수를 제거하는 법이나 계층을 만드는 법을 설명하는 것은 쉽다. 하지만 이것들을 언제 해야 하는지를 설명하는 것은 쉽지 않다. …","fields":{"slug":"/architecture/refactoring_summary_3/"},"frontmatter":{"date":"December 12, 2021","title":"리팩토링 2판 요약 정리 Ch.3","category":"architecture","draft":false}}},{"node":{"excerpt":"버블링과 캡처링 이벤트 버블링과 캡처링은 중첩된 HTML 요소에서 이벤트가 발생했을 때 처리되는 단계들을 설명하는 용어이다. 모든 자바스크립트 이벤트엔 버블링과 캡처링 단계가 존재한다. 이벤트 버블링 이벤트 버블링이란, 어떤 요소에 대해 특정 이벤트가 발생했을 때 해당 이벤트가 상위 부모 요소들로 전달되는 특성을 의미한다. 즉, 우선 해당 요소의 (해당 …","fields":{"slug":"/javascript/event-bubbling-and-capturing/"},"frontmatter":{"date":"December 11, 2021","title":"이벤트 버블링과 캡처링","category":"javascript","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 리팩토링 정의하기 리팩토링 (명사): 소프트웨어의 겉보기 동작(observable behavior)은 그대로 둔 채, 좀 더 이해하기 쉽고 변경에 유연하도록 하기 위해 소프트웨어의 내부 구조에 가해진 변화. 리팩토링 (동사): 소프트웨어의 겉보기 동작은 그대로 둔 채, 리팩토링을 여러 번 적용하여 소프트웨어의 구조를…","fields":{"slug":"/architecture/refactoring_summary_2/"},"frontmatter":{"date":"December 10, 2021","title":"리팩토링 2판 요약 정리 Ch.2","category":"architecture","draft":false}}},{"node":{"excerpt":"이 글은 최범균님의 프로그래밍 초식 시리즈을 요약한 글입니다. 초짜에서 중수가 되려면..? 소프트웨어를 만들려면 언어, 프레임워크, 라이브러리 등 구현 기술, 도구를 (당연히) 익혀야 한다. 하지만 구현 기술 조금 익혔다고 해서 중수 혹은 고수가 되는 것은 아니다. 구현 기술은 단지 여러 기본기 중 하나에 불과하다. 실제로 중수 혹은 고수가 되기 위해선 …","fields":{"slug":"/architecture/programming101-2/"},"frontmatter":{"date":"December 08, 2021","title":"프로그래밍 초식 요약 - 나누기","category":"architecture","draft":false}}},{"node":{"excerpt":"이 글은 최범균님의 프로그래밍 초식 시리즈을 요약한 글입니다. 개발자들의 구현 본능 아무래도 개발자들은 구현을 하는 입장이다 보니, 구현 사항을 들으면 어떻게 구현을 하면 좋을지 자연스럽게 떠올리는 경향이 있는 것 같다: 이를 코드로 “직역”에 가깝게 구현하면 아마 다음과 비슷하게 구현할 수 있을 것같다: 하지만, 시간이 흐르다 보면 처음 코드를 구현할 …","fields":{"slug":"/architecture/programming101-3/"},"frontmatter":{"date":"December 08, 2021","title":"프로그래밍 초식 요약 - What? How?","category":"architecture","draft":false}}},{"node":{"excerpt":"이 글은 최범균님의 프로그래밍 초식 시리즈을 요약한 글입니다. If 조건 역으로 바꾸기  조건이 많거나, 중첩된  조건이 많아지면 코드가 복잡해지고 분석하기 어려워진다.  조건을 덜 복잡하게 하는 여러 방법들 중 가장 쉬운(?) 방법을 살펴보자. 흔한 요구사항 인 경우에만 를 실행한다: 인 경우에, 그리고 인 경우에는 를 실행한다: 하지만, 다음 그림과 …","fields":{"slug":"/architecture/programming101-4/"},"frontmatter":{"date":"December 08, 2021","title":"프로그래밍 초식 요약 - Early return","category":"architecture","draft":false}}},{"node":{"excerpt":"이 글은 최범균님의 프로그래밍 초식 시리즈을 요약한 글입니다. 인지 부하 종종 다음과 같은 형태의 코드를 만날 수 있다: 위 예시들과 같이 변수를 (코드 기준으로) 긴 범위에서 사용한다든가, (어떤 메소드 내에) 변수의 개수가 많거나 계속 증가한다든가, 변수의 용도가 계속해서 변화하게 되면 개발자들이 코드를 보면서 변수들이 어떻게 변화해 나가는지 추적하기…","fields":{"slug":"/architecture/programming101-1/"},"frontmatter":{"date":"December 07, 2021","title":"프로그래밍 초식 요약 - 변수 아끼기","category":"architecture","draft":false}}},{"node":{"excerpt":"SameSite 속성 쿠키의 “SameSite” 속성은 쿠키의 범위(scope)를 제한하여 same-site 요청에 대해서만 해당 쿠키를 첨부할 수 있도록 한다. 이 속성을 통해 CSRF 공격을 어느정도 예방할 수 있다. SameSite 속성값에는 , ,  세 가지가 있는데, 우선 same-site와 cross-site가 무엇인지 부터 간략히 살펴보고자 …","fields":{"slug":"/web/samesite/"},"frontmatter":{"date":"December 07, 2021","title":"SameSite 속성","category":"web","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 서문 읽기 쉬우면서도 변경에 용이한 코드를 유지하는 비결은 리팩토링이다. 리팩토링은 risky한 작업이다. 현재 (잘) 작동하고 있는 코드를 변경함으로 인해 사소한 버그들이 발생할 수 있다. 리팩토링을 적절히, 체계적으로 하지 않으면 몇 일, 심지어는 몇 주전으로 퇴보할 수도 있다. 리팩토링이란 소프트웨어가 수행하는…","fields":{"slug":"/architecture/refactoring_summary_1/"},"frontmatter":{"date":"December 06, 2021","title":"리팩토링 2판 요약 정리 Ch.1","category":"architecture","draft":false}}},{"node":{"excerpt":"브라우저의 이벤트 루프 자바스크립트는 싱글 스레드 기반의 언어이고, 자바스크립트 엔진은 오직 하나의 호출 스택을 사용한다. 즉, 요청이 동기적으로 처리되어 한 번에 한 가지 일만 처리할 수 있음을 의미한다. 이 때, 네트워크 요청과 같이 오버헤드가 큰 요청의 경우 동기적으로 처리된다면 다른 일을 처리할 수 없거나, 렌더링을 block하는 등 여러 문제가 …","fields":{"slug":"/javascript/browser_event_loop/"},"frontmatter":{"date":"October 03, 2020","title":"브라우저 환경에서의 이벤트 루프","category":"javascript","draft":false}}},{"node":{"excerpt":"2편 브라우저의 주요 구성 요소 유저 인터페이스: 주소창, 북마크바, 앞/뒤로 가기 버튼 등 사이트 화면이 나오는 곳을 제외한 부분. 브라우저 엔진: UI와 렌더링 엔진을 제어. 렌더링 엔진: 요청한 내용(content)을 보여주는 역할을 함. 예를 들어, 요청한 내용이 HTML이라면 HTML(과 CSS)를 파싱하여 화면에 렌더링함. 네트워크: HTTP …","fields":{"slug":"/web/how_browsers_work_1/"},"frontmatter":{"date":"August 29, 2020","title":"브라우저는 어떻게 동작하는가? Part1","category":"web","draft":false}}},{"node":{"excerpt":"1편 Critical Rendering Path 브라우저가 HTML, CSS, JS 파일들을 분석하여 화면의 픽셀로 변환하는 과정을 Critical Rendering Path, CRP라고 한다. 이 포스트에서는 브라우저가 서버로 부터 응답을 받은 이후 CRP를 진행하는 과정을 살펴보자. 파싱 DOM 버로 부터 응답으로 HTML 데이터를 받으면 브라우저는 …","fields":{"slug":"/web/how_browsers_work_2/"},"frontmatter":{"date":"August 29, 2020","title":"브라우저는 어떻게 동작하는가? Part2","category":"web","draft":false}}},{"node":{"excerpt":"원문 1편 Git Repository 생성 일반적으로 Git repository를 생성하는 데에는 크게 두 가지 방법이 존재한다: 아직 VCS로 관리되고 있지 않은 로컬 디렉토리를 Git repository로 변경. 외부의 Git repository를 . 기존에 존재하는 디렉토리를 Git repository로 초기화 우선, CLI를 통해 Git repos…","fields":{"slug":"/git/git_pro_summary_2/"},"frontmatter":{"date":"August 28, 2020","title":"Git Pro 2nd Edition 요약 Part2","category":"git","draft":false}}},{"node":{"excerpt":"원문 2편 Chapter1. Getting Started 버전 컨트롤 이란? 여러 파일들의 시간에 따른 변화들을 기록하여, 추후 해당 버전들로 돌아갈 수 있도록 관리하는 시스템. 이 때 버전 컨트롤 시스템으로 관리하는 파일들의 타입은 프로그래밍 파일뿐만이 아니라 어떠한 파일들도 될 수 있다. 버전 컨트롤 시스템을 사용하여 파일들을 관리하면 특정 파일들만,…","fields":{"slug":"/git/git_pro_summary_1/"},"frontmatter":{"date":"August 27, 2020","title":"Git Pro 2nd Edition 요약 Part1","category":"git","draft":false}}},{"node":{"excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 1편 보러가기 3편 보러가기 클로저를 활용하는 사례: AJAX와 이벤트 클로저는 다음과 같이 주로 콜백을 사용하는 경우 맞닥뜨리게 된다:  콜백은 미래의 어느 시점에 Ajax로 부터 응답이 오면 호출될 것이다. 물론 콜백이 …","fields":{"slug":"/javascript/closure_2/"},"frontmatter":{"date":"August 22, 2020","title":"자바스크립트 클로저 Part2","category":"javascript","draft":false}}},{"node":{"excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 1편 보러가기 2편 보러가기 앞서 살펴본 바로는 클로저가 변수 단위로 적용되는 것 같았다. 하지만 다음과 같은 경우는 어떨까? 내부 함수 는 , ,  변수 중 어떠한 것도 명시적으로 클로저로 감싸고 있지는 않다. 그렇지만 을…","fields":{"slug":"/javascript/closure_3/"},"frontmatter":{"date":"August 22, 2020","title":"자바스크립트 클로저 Part3","category":"javascript","draft":false}}},{"node":{"excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 7: Using Closures 2편 보러가기 3편 보러가기 이 글 에서 살펴본 POLE 원칙에 의하면, identifier의 불필요한 노출을 최소화 하기 위해 함수/블록 스코프를 적절히 활용하는 것이 좋다. 이렇게 하면 코드의 가독성이 더 좋아지고 유지보…","fields":{"slug":"/javascript/closure_1/"},"frontmatter":{"date":"August 21, 2020","title":"자바스크립트 클로저 Part1","category":"javascript","draft":false}}},{"node":{"excerpt":"1부 보러가기 var, 그리고 let 앞서 1부 마지막에 살펴본 코드에서  부분을 유심히 살펴보자. 왜 으로 선언하지 않고 로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical)이유가 존재한다. 일단  변수는 자바스크립트 초창기 시절부터 항상 함수 스코프를 가지는, 즉 “함수 전체에 속하는” 변수였다. 어디에서 선언되건 관…","fields":{"slug":"/javascript/limiting_scope_exposure_2/"},"frontmatter":{"date":"August 20, 2020","title":"자바스크립트 변수 노출 최소화 하기 Part2","category":"javascript","draft":false}}},{"node":{"excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables 언제 변수를 사용할 수 있을까? 스코프 내에 있는 변수는 어느순간 부터 사용 가능한 걸까? 변수가 선언(생성)된 시점부터 사용할 수 있지 않을까?? 꼭 그렇지만은 않다. 다음…","fields":{"slug":"/javascript/hoisting/"},"frontmatter":{"date":"August 19, 2020","title":"자바스크립트 호이스팅","category":"javascript","draft":false}}},{"node":{"excerpt":"2부 보러가기 이벤트 루프란? 이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation들을 커널에 맡기는 방식으로 진행하는데, 대부분의 현대 운영체제들은 멀티 스레드이므로 백그라운드에서 여러 operation들을 동시에 실행…","fields":{"slug":"/javascript/nodejs_event_loop_1/"},"frontmatter":{"date":"August 19, 2020","title":"Node.js의 이벤트 루프 Part1","category":"javascript","draft":false}}},{"node":{"excerpt":"2부 보러가기 이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 6: Limiting Scope Exposure 이 글에서는 서로 다른 레벨의 (함수 및 블록) 스코프를 사용하여 프로그램을 구조화 하는 방법을 알아보고, 특히 변수의 과노출(over exposure)를 어떻게, 그리고 왜 해야 하는지에 대해…","fields":{"slug":"/javascript/limiting_scope_exposure_1/"},"frontmatter":{"date":"August 19, 2020","title":"자바스크립트 변수 노출 최소화 하기 Part1","category":"javascript","draft":false}}},{"node":{"excerpt":"1부 보러가기 Poll phase Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase에 진입하면 우선  를 살펴보고, 해당 큐에 파일 읽기 콜백, TCP 통신 콜백등과 같은 작업들이 존재한다면 해당 작업들을 수행한다. 이…","fields":{"slug":"/javascript/nodejs_event_loop_2/"},"frontmatter":{"date":"August 19, 2020","title":"Node.js의 이벤트 루프 Part2","category":"javascript","draft":false}}}]}},"pageContext":{}},"staticQueryHashes":["3128451518"]}