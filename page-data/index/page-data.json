{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"Jaehyeon's Dev Blog","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"왜 아키텍처가 중요한가? NGINX의 아키텍처를 살펴보기 전에, 우선 아키텍처의 중요성에 대해 간단히 살펴보고 가봅시다. 일반적으로, 프로그램의 기본 베이스는 프로세스와 스레드입니다. (넓은 시각에서 보자면, 프로세스와 스레드는 메모리를 공유하는 정도의 차이 이외엔 거의 같다고 볼 수도 있습니다). 프로세스와 스레드는 CPU 코어에서 실행될 수 있는 명령…","fields":{"slug":"/nginx/nginx-architecture/"},"frontmatter":{"date":"April 21, 2022","title":"NGINX의 아키텍처","category":"nginx","draft":false}}},{"node":{"excerpt":"자바스크립트로 프로그래밍을 하다가 한 번쯤은 아래와 같은 에러를 만나보셨을 겁니다: 이는 에러에서 설명하고 있듯이, 자바스크립트의 콜 스택의 크기가 꽉 차서 더 이상의 스택 프레임을 생성할 수 없다는 뜻입니다. 즉, 너무 많은 재귀 호출로 인해 더 이상 함수를 호출할 수 없다는 것이라고 할 수 있겠습니다: 예를 들어, 다음과 같은 재귀 함수를 실행해보면 …","fields":{"slug":"/javascript/prevent-stack-overflow-in-js/"},"frontmatter":{"date":"April 15, 2022","title":"자바스크립트에서 재귀호출로 인한 스택 오버플로우를 막는 방법","category":"JavaScript","draft":false}}},{"node":{"excerpt":"자바스크립트의 연산들은 특정 타입에 대해서 수행됩니다. 만약 어떤 연산에 대해 연산자가 기대하는 것과는 다른 타입의 입력을 주게 되면 (예를 들어 덧셈  연산의 피연산자로 객체를 사용하는 경우) 자바스크립트는 해당 입력의 타입을 자동으로 변환합니다. 이를 암묵적인(implicit) 타입 변환, 혹은 강제 타입 변환(type coercion)이라고도 하는데…","fields":{"slug":"/javascript/type-conversion/"},"frontmatter":{"date":"April 08, 2022","title":"자바스크립트의 타입 변환","category":"JavaScript","draft":false}}},{"node":{"excerpt":"Overview 필요한 데이터를 매번 서버에서 가공해 제공하는 것은 이 자체로 오랜 시간이 소요됩니다. 하지만 만약 사용자의 같은 요청에 응답하는 리소스가 동일한 경우 서버가 매번 같은 작업으로 데이터를 가공하지 않고도 이전에 (클라이언트가) 가져온 리소스를 재사용함으로써 성능을 크게 향상시킬 수 있습니다. 즉, 원본 서버로의 요청 수를 최소화하여 네트워…","fields":{"slug":"/web/http-cache/"},"frontmatter":{"date":"March 29, 2022","title":"HTTP 캐시","category":"Web","draft":false}}},{"node":{"excerpt":"⚠️ 이 포스트에서 “자바스크립트”라는 말은 사실 엄밀히 말해 “ECMAScript”를 말하는 것입니다. 하지만 편의를 위해 ECMAScript를 자바스크립트라고 하겠습니다. Environment Record(환경 레코드) 우선 자바스크립트의 실행 컨텍스트에 대해 살펴보기 전에, Environment Record(환경 레코드)에 대해 살펴봅시다. 환경 레코…","fields":{"slug":"/javascript/execution-context-and-closure/"},"frontmatter":{"date":"February 23, 2022","title":"자바스크립트 실행 컨텍스트와 클로저","category":"JavaScript","draft":false}}},{"node":{"excerpt":"⚠️ 이 포스트는 구글 크롬 브라우저를 기반으로 하고 있습니다. 구현 세부 사항은 브라우저마다 다를 수 있습니다. 브라우저의 주요 구성 요소 우선 브라우저의 구성 요소부터 살펴봅시다. 브라우저는 아래와 같이 크게 7가지의 구성 요소로 나눌 수 있습니다: 유저 인터페이스(User Interface): 사용자가 브라우저를 통해 상호 작용할 수 있도록 돕는 컴포…","fields":{"slug":"/web/how-browsers-work/"},"frontmatter":{"date":"February 21, 2022","title":"브라우저의 동작 원리","category":"Web","draft":false}}},{"node":{"excerpt":"개요 이전 프로젝트를 진행할 때 사이트 디자인을 참고하다가 업비트의 스크롤바가 신기했었습니다. 처음엔 ::-webkit-scrollbar로 커스터마이징한 줄 알았는데 알고보니 자체적으로 만든거였습니다..! 이전 프로젝트에선  기능을 이용하여 스크롤바를 커스터마이징 했지만, 스크롤바가 차지하는 공간으로 인해 레이아웃을 잡을 때 왼쪽/오른쪽 대칭을 맞추는게 …","fields":{"slug":"/react/super-simple-react-scrollbar/"},"frontmatter":{"date":"February 08, 2022","title":"초간단 React 커스텀 스크롤바 만들기","category":"React","draft":false}}},{"node":{"excerpt":"개요 이전 프로젝트에서 react-toastify라는 토스트 메시지 라이브러리를 사용한 적이 있는데, 이번 프로젝트에선 외부 라이브러리 대신 토스트 기능을 직접 구현해 보고 싶어서 조사를 하게 되었습니다. 우선 ReactDOM.render를 이용하여 가 아닌 에 메시지를 띄우기로 하였는데, 그 이유는 부모 요소의 불필요한 css 속성을 물려받지 않을 수 …","fields":{"slug":"/react/super-simple-react-toast/"},"frontmatter":{"date":"February 05, 2022","title":"초간단 React Toast 만들기","category":"React","draft":false}}},{"node":{"excerpt":"문제링크 접근 배열의 모든 원소들의 곱을 미리 구한다음 나눗셈을 이용하여 정답을 구하는 방법이외에 의 시간으로 정답을 구하는 방법은 다음과 같이 각 원소의 왼쪽, 오른쪽 곱을 각각 구하여 이들을 구하는 방법이 있을 수 있습니다: 자바스크립트 풀이","fields":{"slug":"/algorithms/leetcode/238/"},"frontmatter":{"date":"January 19, 2022","title":"LeetCode No.238 - Product of Array Except Self","category":"Algorithms","draft":false}}},{"node":{"excerpt":"문제링크 접근 우선 주어진 배열 를 오름차순으로 정렬한 후, 기준이 되는  포인터를 잡아서 정수 3개의 합을 구하는 문제를 2개의 합을 구하는 문제로 바꿉니다.  포인터를 기준으로 하는 와  포인터를 움직여서,  세 수의 합을 구하는 방식으로 접근하였습니다: 그러다 세 수의 합이 0보다 작으면  포인터를 오른쪽으로, 반대로 0보다 크면  포인터를 왼쪽으로…","fields":{"slug":"/algorithms/leetcode/15/"},"frontmatter":{"date":"January 17, 2022","title":"LeetCode No.15 - 3Sum","category":"Algorithms","draft":false}}},{"node":{"excerpt":"문제링크 접근 먼저, 특정 칸 에 물을 채우기 위한 조건을 생각해보면 다음과 같습니다: 위 그림과 같이, 에 채울 수 있는 물의 양은 왼쪽에 있는 블럭들 중 가장 높은 블록의 높이 와 오른쪽 블럭들 중 가장 높은 블록의 높이 에 대해 로 계산됩니다. 이에 착안하여, ,  두 개의 포인터를 이용해 ,  중 더 낮은 쪽이 높은쪽으로 움직이도록 하면 정답을 구…","fields":{"slug":"/algorithms/leetcode/42/"},"frontmatter":{"date":"January 17, 2022","title":"LeetCode No.42 - Trapping Rain Water","category":"Algorithms","draft":false}}},{"node":{"excerpt":"문제링크 접근 문자열을 한 번 순회하는 포인터를 기준으로 짝수 길이의 팰린드롬과 홀수 길이의 팰린드롬을 탐색하는 슬라이딩 윈도우 두 개를 돌리는 방식으로 접근했습니다. 자바스크립트 구현","fields":{"slug":"/algorithms/leetcode/5/"},"frontmatter":{"date":"January 14, 2022","title":"LeetCode No.5 - Longest Palindromic Substring","category":"Algorithms","draft":false}}},{"node":{"excerpt":"문제링크 접근 문제에 나와있듯이 애너그램이란 어떤 단어 혹은 구(phrase)를 재배열하여 만든 단어 혹은 구 입니다. 이 말에서 착안하여 배열 에 있는 각 문자열들을 정렬하여  자료구조의 key로 사용하고, 해당 key에 대응하는 값으로 같은 애너그램 그룹에 속하는 문자열들의 배열을 둘 수 있습니다. 자바스크립트 풀이","fields":{"slug":"/algorithms/leetcode/49/"},"frontmatter":{"date":"January 14, 2022","title":"LeetCode No.49 - Group Anagrams","category":"Algorithms","draft":false}}},{"node":{"excerpt":"인증 (Authentication) 인증이란, 유저가 자신이 “누구다”라고 주장했을 때 그것이 사실인지를 검증하는 절차라고 할 수 있습니다. 즉, 유저가 자신의 신원(identification)을 주장했을 때 그 주장이 사실인지 아닌지를 판별하는 절차입니다. “입증”이라고도 할 수 있을 것 같습니다. 일반적으로 유저에게 비밀번호를 묻거나, 지문/얼굴 인식…","fields":{"slug":"/web/authentication-vs-authorization/"},"frontmatter":{"date":"January 12, 2022","title":"인증(Authentication)과 인가(Authorization)","category":"Web","draft":false}}},{"node":{"excerpt":"OAuth 2.0 이란? OAuth 2.0(Open Authorization)은 서드 파티 앱이 자원 소유자 혹은 앱 자기 자신을 대신하여 HTTP 서비스에 대한 제한된 접근 권한을 얻을 수 있게 해주는 인가 프레임워크(authorization framework) 입니다. 기존의 전통적인 클라이언트-서버 인증 모델을 살펴보자면, 접근이 제한된 자원(pro…","fields":{"slug":"/web/oauth2/"},"frontmatter":{"date":"January 12, 2022","title":"OAuth 2.0","category":"Web","draft":false}}},{"node":{"excerpt":"Async 함수와 await 자바스크립트의  함수는 프로미스를 좀 더 편하게 사용할 수 있도록 해주는 문법입니다. 다음의 예를 살펴봅시다: 위 코드를 기존의 프로미스 방식으로 바꾸면 다음과 같습니다: 이 예제에서 볼 수 있듯,  함수 내부에서 프로미스 기반의 코드를 마치 동기식으로 동작하는 것처럼 작성할 수 있습니다. 또한  키워드를 사용하여 해당 프로미…","fields":{"slug":"/javascript/async-and-await/"},"frontmatter":{"date":"January 11, 2022","title":"자바스크립트 async & await","category":"JavaScript","draft":false}}},{"node":{"excerpt":"Iteration 프로토콜 자바스크립트의 iteration 프로토콜은 데이터 소스(sources)와 데이터 소비자(consumer) 개체(entity)를 연결하는 역할을 합니다. Iteration은 데이터 소스가 구현한  이라는 인터페이스를 데이터 소비자가 사용하는 방식으로 동작합니다: 자바스크립트 iteration 프로토콜에는 iterable 프로토콜과…","fields":{"slug":"/javascript/iteration-protocol/"},"frontmatter":{"date":"January 10, 2022","title":"자바스크립트 Iteration 프로토콜","category":"JavaScript","draft":false}}},{"node":{"excerpt":"Iteration 프로토콜을 모르신다면 이것부터 살펴보시는 것을 추천합니다! 제너레이터(Generator)란? 자바스크립트에서 제너레이터란 제너레이터 함수(generator function)을 통해 생성한 객체로,  이자 인 객체입니다. Iteration 작업을 할 때 ,  객체들을 직접 다루기 까다로울 수 있기 때문에, 제너레이터를 이용하여 좀 더 쉽게…","fields":{"slug":"/javascript/generator/"},"frontmatter":{"date":"January 10, 2022","title":"자바스크립트 제너레이터","category":"JavaScript","draft":false}}},{"node":{"excerpt":"나머지 연산 vs. 모듈로 연산 나머지 연산을 , 모듈로 연산을 라고 한다면, 이들의 연산 결과는 다음과 같습니다: 두 피연산자의 부호가 같은경우 다음과 같습니다: 하지만 두 피연산자의 부호가 다른 경우 그 결과는 달라집니다: 위 예제에서 볼 수 있듯이 나머지(remainder)연산 결과의 부호는 피제수(dividend) 즉 첫 번째 피연산자와 동일하고,…","fields":{"slug":"/javascript/remainder-vs-modulo/"},"frontmatter":{"date":"January 09, 2022","title":"나머지 연산과 모듈로 연산","category":"JavaScript","draft":false}}},{"node":{"excerpt":"📢   여기서 소개하는 정렬은 오름차순정렬을 기준으로 합니다.   개의 원소를 저장하는 배열를 라고 표현하겠습니다. 개념 일반적으로 선택 정렬은 에서 가장 큰 요소를 찾아 이 요소와 배열의 끝자리에 있는 요소랑 자리를 바꾸는 방식으로 동작하는 알고리즘입니다. 매 번 배열을 돌 때마다 맨 끝으로 옮겨진 요소는 자기 자리(정렬된 위치)를 찾게 되고, 이를 반…","fields":{"slug":"/algorithms/sorting/selection-sort/"},"frontmatter":{"date":"January 07, 2022","title":"선택 정렬","category":"Algorithms","draft":false}}},{"node":{"excerpt":"📢   여기서 소개하는 정렬은 오름차순정렬을 기준으로 합니다.   개의 원소를 저장하는 배열를 라고 표현하겠습니다. 개념 삽입 정렬은 이미 정렬되어 있는 길이가 인 배열에 하나의 원소를 더해서, 길이가 인 정렬된 배열을 만드는 과정을 반복합니다. 선택 정렬과 버블 정렬이 개 짜리 배열에서 시작하여 그 크기를 하나씩 줄여나가는데 반해, 삽입 정렬은 한 개짜…","fields":{"slug":"/algorithms/sorting/insertion-sort/"},"frontmatter":{"date":"January 07, 2022","title":"삽입 정렬","category":"Algorithms","draft":false}}},{"node":{"excerpt":"📢 여기서 소개하는 정렬은 오름차순정렬을 기준으로 합니다. 개의 원소를 저장하는 배열를 라고 표현하겠습니다. 개념 병합 정렬은 주어진 배열을 반으로 나눈다음, 이렇게 나뉘어진 두 배열을 각각 독립적으로 정렬한 뒤 다시 합치는 과정을 수행하는 정렬 알고리즘 입니다. 자신보다 크기가 절반인 문제를 두 개 푼 다음 병합하는 과정을 재귀적으로 반복한다고 할 수 …","fields":{"slug":"/algorithms/sorting/merge-sort/"},"frontmatter":{"date":"January 07, 2022","title":"병합 정렬","category":"Algorithms","draft":false}}},{"node":{"excerpt":"역사 옛날에 Unix가 개발이 한창이고 브라이언 커니핸과 데니스 리치가 The C Programming Language를 집필할 당시, 악센트가 없는 영문자만 잘 표현하면 되었습니다. 이는 숫자 32부터 127 사이를 이용하는 ASCII를 통해 모든 글자를 표현할 수 있었습니다. 공백 문자는 32, 대문자 는 65와 같은 식으로요. 단 7비트만 가지고 이…","fields":{"slug":"/computer-architecture/unicode-and-character-sets/"},"frontmatter":{"date":"January 06, 2022","title":"유니코드와 Character Set에 관하여","category":"Computer Architecture","draft":false}}},{"node":{"excerpt":"이진 탐색이란? 어떤 그룹 내에 존재하는 요소를 찾고자 할 때, 가장 일반적인 방법은 해당 그룹의 요소를 하나하나 살펴보는 것입니다. 이를 선형 탐색(linear search)라고 하는데, 이러한 알고리즘은 의 시간복잡도를 갖습니다. 이때 그룹 내의 요소들이 일정한 순서로 정렬되어 있다면 이진 탐색(binary search) 기법을 활용할 수 있습니다. …","fields":{"slug":"/algorithms/searching/binary-search/"},"frontmatter":{"date":"January 05, 2022","title":"이진 탐색","category":"Algorithms","draft":false}}},{"node":{"excerpt":"문제링크 접근 우선 이진 탐색을 활용하여 피벗을 찾습니다. 이렇게 찾은 피벗을 기준으로 나뉜 두 배열은 각자 정렬된 상태이므로 이 두 배열에 대해 이진 탐색을 수행하여 최종 결과값을 도출하고자 하였습니다. 피벗을 찾는 아이디어는 다음과 같습니다: 위 그림과 같이, 오름차순으로 정렬된 배열이 피벗을 기준으로 둘로 나뉜 상황에서, 아래의 그림처럼 와  그리고…","fields":{"slug":"/algorithms/leetcode/33/"},"frontmatter":{"date":"January 05, 2022","title":"LeetCode No.33","category":"Algorithms","draft":false}}},{"node":{"excerpt":"📢   여기서 소개하는 정렬은 오름차순정렬을 기준으로 합니다.   개의 원소를 저장하는 배열를 라고 표현하겠습니다. 개념 일반적으로 버블 정렬은 두 개의 포인터를 이용하여 이웃한 요소쌍(pair)을 비교해가면서 순서대로 되어 있지 않은 요소들의 자리를 바꿔나가는 방식으로 진행됩니다. 각 패스(pass)마다 이 과정을 거치며, 최대 n번의 패스를 수행합니다…","fields":{"slug":"/algorithms/sorting/bubble-sort/"},"frontmatter":{"date":"January 05, 2022","title":"버블 정렬","category":"Algorithms","draft":false}}},{"node":{"excerpt":"IEEE 754에 대해 잘 모르시는 분들은 컴퓨터는 어떻게 숫자를 표현하는가를 보고 오시는 것을 추천합니다! Number.MAX_SAFE_INTEGER 우선, 자바스크립트에서 “안전”하게 정수를 표현할 수 있는 최대값이 왜  ()인가에 대해 알아봅시다. 이때 “안전”하다는 말은 정수를 정확하게 나타낼 수 있고, 올바르게 값을 비교할 수 있다는 의미입니다.…","fields":{"slug":"/javascript/max-values/"},"frontmatter":{"date":"January 04, 2022","title":"자바스크립트 MAX_SAFE_INTEGER와 MAX_VALUE","category":"JavaScript","draft":false}}},{"node":{"excerpt":"정수 표현 이진수로 표현 우리 인간은 10진법을 사용하여 수를 표현합니다. 가령, 987은 9가 100개, 8이 10개, 7이 1개 있다는 것을 의미하죠. 혹은, 정수를 다음과 같이 표기할 수도 있습니다:  이진수도 위와 비슷한 방법으로 표현할 수 있죠:  물론 분수를 표현하는 것도 가능합니다:  16진수로 표현 위와 같이 이진수로 수를 표현하다 보면 그…","fields":{"slug":"/computer-architecture/how-computers-represent-numbers/"},"frontmatter":{"date":"January 03, 2022","title":"컴퓨터는 어떻게 숫자를 표현하는가","category":"Computer Architecture","draft":false}}},{"node":{"excerpt":"알고리즘 분석이란? 알고리즘 분석이란, 알고리즘의 자원(resource) (실행 시간, 메모리, 통신 등등..) 사용량을 분석하는 것을 의미합니다. 시간복잡도 (Time Complexity) 알고리즘의 실행 시간은 실행환경 (컴퓨터의 성능, 운영체제, 프로그래밍 언어, 컴파일러 등)에 따라 달라질 수 있습니다. 이로 인해 알고리즘의 “정확한” 실행 시간을…","fields":{"slug":"/algorithms/algorithm-analysis/"},"frontmatter":{"date":"January 03, 2022","title":"알고리즘 분석","category":"Algorithms","draft":false}}},{"node":{"excerpt":"점화식이란 점화식이란 쉽게 말해, 어떤 함수를 자기 자신과 똑같은 함수를 이용하여 나타내는 것입니다. 동일한 함수가 등호 혹은 부등호의 양쪽에 나타나는데, 이 때 양쪽 함수의 변수 크기는 다릅니다. 예를 들어, 의 점화식은 으로, 피보나치 수열의 점화식은 로 나타낼 수 있습니다. 점화식은 재귀 함수의 복잡도를 구하는데 유용한데, 병합 정렬의 핵심부를 예로…","fields":{"slug":"/algorithms/recurrence-relation/"},"frontmatter":{"date":"January 03, 2022","title":"점화식","category":"Algorithms","draft":false}}},{"node":{"excerpt":"프로미스란? ECMAScript 2022 명세서에 따르면, 프로미스는 (아마도 비동기식으로 동작할 가능성이 높은) 지연된 계산의 최종 결과물에 대해 일종의 프록시로서 사용되는 객체입니다. 즉, 프로미스 객체는 (주로) 비동기 동작의 결과(🠖성공 or 실패)와 동작의 결과값을 나타내는 데에 흔히 사용됩니다. 어떤 동작의 중간 상태를 나타내는 객체라고 볼 수…","fields":{"slug":"/javascript/promise-states/"},"frontmatter":{"date":"December 31, 2021","title":"자바스크립트 프로미스와 프로미스 상태들","category":"JavaScript","draft":false}}},{"node":{"excerpt":"이 포스트는 The Elements of UI Engineering를 번역한 글입니다. 이전 포스트에서 저는 우리의 지식의 빈틈을 인정하는 것에 관해 이야기했습니다. 제가 평범함에 안주하라고 권유하는 것처럼 보이실 수도 있겠지만, 아닙니다! 이곳은 광범위한 분야입니다. 저는 여러분이 “어디에서나 시작할 수 있고”, 기술을 특정 순서로 배울 필요가 없다고 …","fields":{"slug":"/react/the-elements-of-ui-engineering/"},"frontmatter":{"date":"December 30, 2021","title":"UI 엔지니어링의 요소들","category":"React","draft":false}}},{"node":{"excerpt":"이 글은 Kent C. Dodds의 Avoid Nesting when you’re Testing 포스트를 번역한 글입니다. 제가 보여드리고 싶은 것은 React 컴포넌트 테스트에 적용된 일반적인 테스팅 원칙입니다. 비록 예제가 React이긴 하지만, 개념이 제대로 전달되었으면 좋겠네요. 💡 제가 하려는 말은 중첩 그 자체가 나쁘다는 말이 아닙니다만, 중첩…","fields":{"slug":"/testing/avoid-nesting-when-youre-testing/"},"frontmatter":{"date":"December 28, 2021","title":"테스팅할 때 중첩은 피하세요","category":"Testing","draft":false}}},{"node":{"excerpt":"이 포스트는 How to use React Context effectively를 번역한 글입니다. React로 애플리케이션 상태관리 하기에서 지역 상태와 React 컨텍스트를 같이 사용하여 React 애플리케이션의 상태를 잘 관리할 수 있는 방법을 소개해 드렸습니다. 여기서는 해당 포스트에서 보여드렸던 몇 가지 예제를 바탕으로, 어떻게 하면 컨텍스트 co…","fields":{"slug":"/react/how-to-use-react-context-effectively/"},"frontmatter":{"date":"December 28, 2021","title":"React 컨텍스트 효율적으로 사용하기","category":"React","draft":false}}},{"node":{"excerpt":"이 포스트는 Application State Management with React를 번역/요약한 글입니다. 어느 애플리케이션에서나 상태를 관리하는 것은 아마도 가장 힘든 부분일 것입니다. 이것이 상태관리 라이브러리들이 그토록 많이 존재할 뿐만 아니라, 계속해서 새로 생겨나는 이유입니다. (심지어 몇몇 라이브러리는 상태관리 라이브러리의 라이브러리 이기도 …","fields":{"slug":"/react/application-state-management-with-react/"},"frontmatter":{"date":"December 27, 2021","title":"React로 애플리케이션 상태관리 하기","category":"React","draft":false}}},{"node":{"excerpt":"이 글은 Kent C. Dodds의 Inversion of Control 포스트를 번역한 글입니다. egghead.io의 “IoC 구현하기” 영상 만약 여러분이 한 곳 이상에서 사용되는 코드를 작성해보신 경험이 있다면, 아래의 경험을 해보신 적이 있을 수도 있을 겁니다: 함수, React 컴포넌트, React 훅과 같이 재사용 가능한 코드를 만들어서 동료…","fields":{"slug":"/javascript/inversion-of-control/"},"frontmatter":{"date":"December 26, 2021","title":"제어의 역전","category":"JavaScript","draft":false}}},{"node":{"excerpt":"이 포스트는 A Complete Guide to useEffect를 번역/요약한 글입니다. 원글의 작성일이 2019년 3월인 것을 감안해 주세요! 모든 렌더링은 각자의 Props와 State를 가진다 (Each Render Has Its Own Props and State) 우선 effect에 대해 살펴보기 전에 렌더링부터 살펴봅시다. 여기 카운터 컴포넌…","fields":{"slug":"/react/a-complete-guide-to-useeffect/"},"frontmatter":{"date":"December 24, 2021","title":"useEffect 완벽 가이드","category":"React","draft":false}}},{"node":{"excerpt":"이 포스트는 React as a UI Runtime를 번역한 글입니다. 호스트 트리 (Host Tree) 어떤 프로그램은 숫자를 출력하고, 또 어떤 프로그램은 텍스트를 출력합니다. 이렇듯 각기 다른 프로그래밍 언어들과 이들의 런타임 환경은 특정 용도에 맞춰 최적화되는데, React도 예외는 아닙니다. React 프로그램들은 주로 시간에 따라 변경될 수도 …","fields":{"slug":"/react/react-as-a-ui-runtime/"},"frontmatter":{"date":"December 22, 2021","title":"UI 런타임으로서의 React","category":"React","draft":false}}},{"node":{"excerpt":"Inline Variable Motivation 변수의 이름을 통해 코드의 흐름을 파악할 수 있기 때문에, 일반적으로 변수는 좋은 것으로 취급된다. 하지만 변수의 이름이 원래의 표현식과 다를 바 없는 경우, 혹은 리팩토링 하는데 변수가 방해되는 경우 해당 변수를 인라인하는 것이 좋다. Mechanics 변수의 오른쪽에 있는 표현식(Right-Hand Si…","fields":{"slug":"/software-architecture/refactoring-list-1/"},"frontmatter":{"date":"December 21, 2021","title":"리팩토링 방법들 Part.1","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"클린 코드를 번역/요약한 글입니다. 스스로를 “프로”라고 부르기 위해선 반드시 클린 코드를 작성할 줄 알아야 한다. 클린 코드를 작성하기 위해 최선을 다해야만 한다. 도입 (Introduction) 클린 코드를 작성하는 방법을 배우는 것은 어렵다. 단순히 원칙이나 패턴들을 외운다고 되는 것이 아니라, 그것들을 몸으로 체득해야만 한다. 이 책을 통해 배운 …","fields":{"slug":"/software-architecture/clean-code-summary-1/"},"frontmatter":{"date":"December 15, 2021","title":"클린 코드 요약 정리 Ch.1","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 테스트 만들기 (Building Tests) 리팩토링은 그 자체로 매우 훌륭한 도구이지만, 이것만으론 부족하다. 혹시 모를 실수에 대비해 반드시 견고한 테스트 코드가 있어야 한다. (IDE와 같은 도구에서 제공하는) 자동 리팩토링 기능을 사용한다고 하더라도 테스트 코드를 통해 테스트하는 것이 좋다. 굳이 리팩토링 때…","fields":{"slug":"/software-architecture/refactoring-summary-4/"},"frontmatter":{"date":"December 14, 2021","title":"리팩토링 2판 요약 정리 Ch.4","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 코드에서 나는 악취 (Bad Smells in Code) 언제 리팩토링을 시작할 것인지(그리고 언제 멈출 것인지)를 아는 것은 리팩토링의 작동 원리를 아는 것 못지 않게 중요하다. 인스턴스 변수를 제거하는 법이나 계층을 만드는 법을 설명하는 것은 쉽다. 하지만 이것들을 언제 해야 하는지를 설명하는 것은 쉽지 않다. …","fields":{"slug":"/software-architecture/refactoring-summary-3/"},"frontmatter":{"date":"December 12, 2021","title":"리팩토링 2판 요약 정리 Ch.3","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"버블링과 캡처링 이벤트 버블링과 캡처링은 중첩된 HTML 요소에서 이벤트가 발생했을 때 처리되는 단계들을 설명하는 용어이다. 모든 자바스크립트 이벤트엔 버블링과 캡처링 단계가 존재한다. 이벤트 버블링 이벤트 버블링이란, 어떤 요소에 대해 특정 이벤트가 발생했을 때 해당 이벤트가 상위 부모 요소들로 전달되는 특성을 의미한다. 즉, 우선 해당 요소의 (해당 …","fields":{"slug":"/javascript/event-bubbling-and-capturing/"},"frontmatter":{"date":"December 11, 2021","title":"이벤트 버블링과 캡처링","category":"JavaScript","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 리팩토링 정의하기 리팩토링 (명사): 소프트웨어의 겉보기 동작(observable behavior)은 그대로 둔 채, 좀 더 이해하기 쉽고 변경에 유연하도록 하기 위해 소프트웨어의 내부 구조에 가해진 변화. 리팩토링 (동사): 소프트웨어의 겉보기 동작은 그대로 둔 채, 리팩토링을 여러 번 적용하여 소프트웨어의 구조를…","fields":{"slug":"/software-architecture/refactoring-summary-2/"},"frontmatter":{"date":"December 10, 2021","title":"리팩토링 2판 요약 정리 Ch.2","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"SameSite 속성 쿠키의 “SameSite” 속성은 쿠키의 범위(scope)를 제한하여 same-site 요청에 대해서만 해당 쿠키를 첨부할 수 있도록 한다. 이 속성을 통해 CSRF 공격을 어느정도 예방할 수 있다. SameSite 속성값에는 , ,  세 가지가 있는데, 우선 same-site와 cross-site가 무엇인지 부터 간략히 살펴보고자 …","fields":{"slug":"/web/samesite/"},"frontmatter":{"date":"December 07, 2021","title":"SameSite 속성","category":"Web","draft":false}}},{"node":{"excerpt":"리팩토링 2판을 번역/요약한 글입니다. 서문 읽기 쉬우면서도 변경에 용이한 코드를 유지하는 비결은 리팩토링이다. 리팩토링은 risky한 작업이다. 현재 (잘) 작동하고 있는 코드를 변경함으로 인해 사소한 버그들이 발생할 수 있다. 리팩토링을 적절히, 체계적으로 하지 않으면 몇 일, 심지어는 몇 주전으로 퇴보할 수도 있다. 리팩토링이란 소프트웨어가 수행하는…","fields":{"slug":"/software-architecture/refactoring-summary-1/"},"frontmatter":{"date":"December 06, 2021","title":"리팩토링 2판 요약 정리 Ch.1","category":"Software Architecture","draft":false}}},{"node":{"excerpt":"로컬 환경에서 자바스크립트 관련 테스팅을 할 게 있어서 다음과 같은 html파일을 로컬환경에서 실행시켰더니 CORS 에러가 발생했습니다. 에러의 원인 이 문제의 근본적인 원인은 동일 출처 정책 (same-origin policy) 입니다. 동일 출처 정책이란, 어떤 출처(origin)에서 불러온 문서 혹은 스크립트가 다른 출처에서 가져온 리소스와 상호작용…","fields":{"slug":"/web/cors-on-local-environment/"},"frontmatter":{"date":"April 02, 2021","title":"로컬 환경에서의 CORS 문제 해결","category":"Web","draft":false}}},{"node":{"excerpt":"멀티프로그래밍(단일 CPU 상에서 여러 개의 프로그램이 동시에 실행되는 것)의 목적은 프로세스를 항상 사용함으로써 CPU를 놀도록 놔두지 않는 것, 즉 CPU를 최대한 효율적으로 사용하는 것입니다. 또한 시분할 시스템(Time sharing system)의 목적은 각 프로세스에 (매우)짧은 시간 간격으로 CPU를 할당하여 사용자가 여러 개의 프로세스와 동…","fields":{"slug":"/os/process-scheduling/"},"frontmatter":{"date":"March 16, 2021","title":"프로세스 스케줄링","category":"OS","draft":false}}},{"node":{"excerpt":"프로세스의 개념 초창기 컴퓨터들은 어느 한순간에 하나의 프로그램만 실행할 수 있었습니다. 하지만 현대의 컴퓨터들은 여러 개의 프로그램이 동시에 메모리에 적재(load)되어 실행될 수 있는 형태로 발전하였습니다. 이러한 발전으로 인해 여러 프로그램들을 서로 구분해야 할 필요가 생겼고, 이에 따라 프로세스(process)라는 개념이 탄생하게 됩니다. 프로세스…","fields":{"slug":"/os/process/"},"frontmatter":{"date":"March 15, 2021","title":"프로세스","category":"OS","draft":false}}},{"node":{"excerpt":"단일형 구조 (Monolithic Structure) 단일형 구조는 가장 단순한 형태로서, 커널의 모든 기능이 하나의 형태로 구현되어 있습니다. 즉, 커널이 마치 하나의 프로그램처럼 동작합니다. 초창기 UNIX 운영 체제에서 사용되었으며, 커널 프로그램과 시스템 프로그램 두 부분으로 나뉘어 구성됩니다. 이후 UNIX가 발전함에 따라 이 두 부분 이외에 인…","fields":{"slug":"/os/os-architectures/"},"frontmatter":{"date":"March 13, 2021","title":"운영 체제의 구조","category":"OS","draft":false}}},{"node":{"excerpt":"인터럽트란 무엇인가 인터럽트(interrupt)란, (주로 입/출력)하드웨어 장치의 처리, 혹은 예외 상황의 처리가 필요할 때 CPU에게 알려 이를 처리할 수 있도록 하는 일종의 신호입니다. 인터럽트는 여러 목적으로 사용될 수 있으며, 운영 체제와 하드웨어 간의 상호작용에 핵심적인 역할을 합니다. CPU에 인터럽트 신호가 들어오면, CPU는 현재 수행 중…","fields":{"slug":"/os/what-is-interrupt/"},"frontmatter":{"date":"March 12, 2021","title":"인터럽트란?","category":"OS","draft":false}}},{"node":{"excerpt":"시스템 콜이란? 시스템 콜(system call)이란 운영 체제가 제공하는 일종의 인터페이스로서, 유저 프로그램이 운영 체제의 기능을 사용할 수 있도록 합니다. 예시로, 어떤 파일을 읽고 그 내용을 다른 파일에 복사하는 프로그램을 생각해 봅시다. 이 경우 프로그램에게 입력 파일과 출력 파일의 이름을 전달해줘야 합니다. 이때, UNIX  명령을 이용하여  …","fields":{"slug":"/os/system-call/"},"frontmatter":{"date":"March 11, 2021","title":"시스템 콜","category":"OS","draft":false}}},{"node":{"excerpt":"운영 체제란 무엇인가 운영 체제 (Operating System)란, 쉽게 말해 컴퓨터의 하드웨어를 관리하는 소프트웨어라고 할 수 있습니다. 즉, 우리가 일상 생활에서 많이 사용하는 브라우저, 엑셀, 워드 같은 애플리케이션 프로그램들이 컴퓨터 하드웨어 위에서 원활히 동작할 수 있도록 일종의 중간 계층 역할을 하는 프로그램이라고 할 수 있습니다. 데스크톱,…","fields":{"slug":"/os/os-introduction/"},"frontmatter":{"date":"March 10, 2021","title":"운영 체제란?","category":"OS","draft":false}}},{"node":{"excerpt":"브라우저의 이벤트 루프 자바스크립트는 싱글 스레드 기반의 언어이고, 자바스크립트 엔진은 오직 하나의 호출 스택을 사용한다. 즉, 요청이 동기적으로 처리되어 한 번에 한 가지 일만 처리할 수 있음을 의미한다. 이 때, 네트워크 요청과 같이 오버헤드가 큰 요청의 경우 동기적으로 처리된다면 다른 일을 처리할 수 없거나, 렌더링을 block하는 등 여러 문제가 …","fields":{"slug":"/javascript/browser-event-loop/"},"frontmatter":{"date":"October 03, 2020","title":"브라우저 환경에서의 이벤트 루프","category":"JavaScript","draft":false}}},{"node":{"excerpt":"원문 2편 Chapter1. Getting Started 버전 컨트롤 이란? 여러 파일들의 시간에 따른 변화들을 기록하여, 추후 해당 버전들로 돌아갈 수 있도록 관리하는 시스템. 이 때 버전 컨트롤 시스템으로 관리하는 파일들의 타입은 프로그래밍 파일뿐만이 아니라 어떠한 파일들도 될 수 있다. 버전 컨트롤 시스템을 사용하여 파일들을 관리하면 특정 파일들만,…","fields":{"slug":"/git/git-pro-summary-1/"},"frontmatter":{"date":"August 27, 2020","title":"Git Pro 2nd Edition 요약 Part1","category":"Git","draft":false}}},{"node":{"excerpt":"1부 보러가기 var, 그리고 let 앞서 1부 마지막에 살펴본 코드에서  부분을 유심히 살펴보자. 왜 으로 선언하지 않고 로 선언했을까? 여기엔 의미론적인(semantic) 이유와 기술적인(technical)이유가 존재한다. 일단  변수는 자바스크립트 초창기 시절부터 항상 함수 스코프를 가지는, 즉 “함수 전체에 속하는” 변수였다. 어디에서 선언되건 관…","fields":{"slug":"/javascript/limiting-scope-exposure-2/"},"frontmatter":{"date":"August 20, 2020","title":"자바스크립트 변수 노출 최소화 하기 Part2","category":"JavaScript","draft":false}}},{"node":{"excerpt":"이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 5: The (Not So) Secret Lifecycle of Variables 언제 변수를 사용할 수 있을까? 스코프 내에 있는 변수는 어느순간 부터 사용 가능한 걸까? 변수가 선언(생성)된 시점부터 사용할 수 있지 않을까?? 꼭 그렇지만은 않다. 다음…","fields":{"slug":"/javascript/hoisting/"},"frontmatter":{"date":"August 19, 2020","title":"자바스크립트 호이스팅","category":"JavaScript","draft":false}}},{"node":{"excerpt":"2부 보러가기 이벤트 루프란? 이벤트 루프란 Node.js가 싱글 스레드(≈ 콜스택이 하나)로 동작함에도 불구하고 I/O 동작들을 non-blocking 방식으로 처리할 수 있게 해주는 녀석이다. 주로 operation들을 커널에 맡기는 방식으로 진행하는데, 대부분의 현대 운영체제들은 멀티 스레드이므로 백그라운드에서 여러 operation들을 동시에 실행…","fields":{"slug":"/javascript/nodejs-event-loop-1/"},"frontmatter":{"date":"August 19, 2020","title":"Node.js의 이벤트 루프 Part1","category":"JavaScript","draft":false}}},{"node":{"excerpt":"2부 보러가기 이 글은 아래의 원문을 번역/요약한 글입니다. You Don’t Know JS Yet/Chapter 6: Limiting Scope Exposure 이 글에서는 서로 다른 레벨의 (함수 및 블록) 스코프를 사용하여 프로그램을 구조화 하는 방법을 알아보고, 특히 변수의 과노출(over exposure)를 어떻게, 그리고 왜 해야 하는지에 대해…","fields":{"slug":"/javascript/limiting-scope-exposure-1/"},"frontmatter":{"date":"August 19, 2020","title":"자바스크립트 변수 노출 최소화 하기 Part1","category":"JavaScript","draft":false}}},{"node":{"excerpt":"1부 보러가기 Poll phase Poll phase 에서는 일정시간동안 대기(blocking)하면서 새로운 I/O operation이 들어오는지 “polling(watching)“한다. 이벤트 루프가 Poll phase에 진입하면 우선  를 살펴보고, 해당 큐에 파일 읽기 콜백, TCP 통신 콜백등과 같은 작업들이 존재한다면 해당 작업들을 수행한다. 이…","fields":{"slug":"/javascript/nodejs-event-loop-2/"},"frontmatter":{"date":"August 19, 2020","title":"Node.js의 이벤트 루프 Part2","category":"JavaScript","draft":false}}}]}},"pageContext":{}},"staticQueryHashes":["3128451518"]}